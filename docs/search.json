[
  {
    "objectID": "Chapters/03-unittests.html",
    "href": "Chapters/03-unittests.html",
    "title": "5  Unit tests in Zig",
    "section": "",
    "text": "5.1 Introducing the test block\nIn Zig, unit tests are written inside a test declaration, or, how I prefer to call it, inside a test block. Every test block is written by using the keyword test. You can optionally use a string literal to write a label, which is responsible for identifying the specific group of unit tests that you are writing inside this specific test block.\nIn the example below, we are testing if the sum of two objects (a and b) is equal to 4. The expect() function from the Zig Standard Library is a function that receives a logical test as input. If this logical test results in true, then, the test passes. But if it results in false, then, the test fails.\nYou can write any Zig code you want inside of each test block. Part of this code might be some necessary commands to setup your testing environment, or just initializing some necessary objects.\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\ntest \"testing simple sum\" {\n    const a: u8 = 2;\n    const b: u8 = 2;\n    try expect((a + b) == 4);\n}\nYou can have multiple test blocks written on the same Zig module. Also, you can mix test blocks with your source code, with no problems or consequences. If you mix test blocks with your normal source code, when you execute the build, build-exe, build-obj or build-lib commands from the zig compiler that we exposed at Section 1.2.4, these test blocks are automatically ignored by the compiler.\nIn other words, the zig compiler only builds and execute your tests when you ask it to. By default, the compiler always ignore test blocks written in your Zig modules. The compiler normally checks only if there are any syntax errors in these test blocks.\nIf you look at the source code for most of the files present in the Zig Standard Library1, you can see that the test blocks are written together with the normal source code of the library. You can see this for example, at the array_list module2. So, the standard that the Zig developers decided to adopt is to keep their unit tests together with the source code of the functionality that they are testing.\nEach programmer might have a different opinion on this. Some of them might prefer to keep unit tests separate from the actual source code of their application. If that is your case, you can simply create a separate tests folder in your project, and start writing Zig modules that contains only unit tests (as would normally do on a Python project with pytest, for example), and everything will work fine. It boils down to which is your preference here.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#how-to-run-your-tests",
    "href": "Chapters/03-unittests.html#how-to-run-your-tests",
    "title": "5  Unit tests in Zig",
    "section": "5.2 How to run your tests",
    "text": "5.2 How to run your tests\nIf the zig compiler ignores any test block by default, how can you compile and run your unit tests? The answer is the test command from the zig compiler. By running zig test command, the compiler will find every instance of test block in your Zig module, and, it will compile and run the unit tests you wrote.\nzig test simple_sum.zig\n1/1 simple_sum.test.testing simple sum... OK\nAll 1 tests passed.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-memory-allocations",
    "href": "Chapters/03-unittests.html#testing-memory-allocations",
    "title": "5  Unit tests in Zig",
    "section": "5.3 Testing memory allocations",
    "text": "5.3 Testing memory allocations\nOne of the advantages of Zig is that it offers great tools that hep us, programmers, to avoid (but also detect) memory problems, such as memory leaks and double-frees. The defer keyword is specially helpful in this regard.\nWhen developing your source code, you, the programmer, is responsible for making sure that your code do not produce such problems. However, you can also use a special type of allocator object in Zig, that is capable of automatically detect such problems for you. This is the std.testing.allocator object. This allocator object offers some basic memory safety detection features, which are capable of detecting memory leaks.\nAs we described at Section 2.1.5, to allocate memory on the heap, you need to use an allocator object, and your functions that use these objects to allocate memory on the heap, should receive an allocator object as one of it’s inputs. Every memory on the heap that you allocate using these allocator objects, must also be freed using this same allocator object.\nSo, if you want to test the memory allocations performed by your functions, and make sure that you don’t have problems in these allocations, you can simply write unit tests for these functions, where you provide the std.testing.allocator object as input to these functions.\nLook at the example below, where I’m defining a function that clearly causes a memory leak. Because we allocate memory with the allocator object, but we do not free this allocated memory in any point. So, when the function returns, we lose the reference to the buffer object, which contains the allocated memory, and, as a result, we can no longer free this memory.\nNotice that, inside a test block I execute this function with the std.testing.allocator. Since no visible errors were raised inside the test block, the zig compiler completes the process indicating that the unit tests performed inside the test block labeled as \"memory leak have all passed. But despite this result, the allocator object was capable of looking deeper in our program, and detecting the memory leak. As a result, this allocator object returns a message “tests leaked memory”, and also, a stack trace showing the exact point where the memory was leaked.\n\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nfn some_memory_leak(allocator: Allocator) !void {\n    const buffer = try allocator.alloc(u32, 10);\n    _ = buffer;\n    // Return without freeing the\n    // allocated memory\n}\n\ntest \"memory leak\" {\n    const allocator = std.testing.allocator;\n    try some_memory_leak(allocator);\n}\n\nTest [1/1] leak_memory.test.memory leak...\n    [gpa] (err): memory address 0x7c1fddf39000 leaked: \n./ZigExamples/debugging/leak_memory.zig:4:39: 0x10395f2\n    const buffer = try allocator.alloc(u32, 10);\n                                      ^\n./ZigExamples/debugging/leak_memory.zig:12:25: 0x10398ea\n    try some_memory_leak(allocator);\n\n... more stack trace",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-errors",
    "href": "Chapters/03-unittests.html#testing-errors",
    "title": "5  Unit tests in Zig",
    "section": "5.4 Testing errors",
    "text": "5.4 Testing errors\nOne commom style of unit tests are those that look for specific errors in your functions. In other words, you write a unit test that tries to assert if a specific function call returns any error, or a specific type of error.\nIn C++ you would normally write this stye of unit test using, for example, the functions REQUIRE_THROWS() or CHECK_THROWS() from the Catch2 test framework3. In the case of a Python project, you would use the raises() function from pytest4. While in Rust, you would probably use assert_eq!() in conjunction with Err().\nBut in Zig, we use the expectError() function, from the std.testing module. With this function, you can test if a specific function call returns the exact type of error that you expect it to return. To use this function, you first write try expectError(). Then, on the first argument, you provide the type of error that you are expecting from the function call. Then, on the second argument, you write the function call you expect to fail.\nThe code example below demonstrates such type of unit test in Zig. Notice that, inside the function alloc_error() we are allocating 100 bytes of memory, or, an array of 100 elements, for the object ibuffer. However, in the test block, we are using the FixedBufferAllocator() allocator object, which is limited to 10 bytes of space, because the object buffer, which we provided to the allocator object, have only 10 bytes of space.\nThat is why, the alloc_error() function raises an OutOfMemory error on this case. Because this function is trying to allocate more space than the allocator object allows. So, in essence, we are testing for a specific type of error, which is OutOfMemory. If the alloc_error() function returns any other type of error, then, the expectError() function would make the entire test fail.\n\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nconst expectError = std.testing.expectError;\nfn alloc_error(allocator: Allocator) !void {\n    var ibuffer = try allocator.alloc(u8, 100);\n    defer allocator.free(ibuffer);\n    ibuffer[0] = 2;\n}\n\ntest \"testing error\" {\n    var buffer: [10]u8 = undefined;\n    var fba = std.heap.FixedBufferAllocator.init(&buffer);\n    const allocator = fba.allocator();\n    try expectError(error.OutOfMemory, alloc_error(allocator));\n}\n\n1/1 oom.test.testing error... OK\nAll 1 tests passed.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-for-simple-equalities",
    "href": "Chapters/03-unittests.html#testing-for-simple-equalities",
    "title": "5  Unit tests in Zig",
    "section": "5.5 Testing for simple equalities",
    "text": "5.5 Testing for simple equalities\nIn Zig, there are some different ways you can test for an equality. You already saw that we can use expect() with the logical operator == to essentially reproduce an equality test. But we also have some helper functions that you should know about, specially expectEqual(), expectEqualSlices() and expectEqualStrings().\n\nconst std = @import(\"std\");\ntest \"arrays are equal?\" {\n    const array1 = [3]u32{1, 2, 3};\n    const array2 = [3]u32{1, 2, 3};\n    try std.testing.expectEqualSlices(\n        u32, &array1, &array2\n    );\n}\n\n1/1 oom.test.arrays are equal?... OK\nAll 1 tests passed.\n\nconst std = @import(\"std\");\ntest \"strings are equal?\" {\n    const str1 = \"hello, world!\";\n    const str2 = \"hello, world!\";\n    try std.testing.expectEqualStrings(\n        str1, str2\n    );\n}\n\n1/1 oom.test.arrays are equal?... OK\nAll 1 tests passed.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#footnotes",
    "href": "Chapters/03-unittests.html#footnotes",
    "title": "5  Unit tests in Zig",
    "section": "",
    "text": "https://github.com/ziglang/zig/tree/master/lib/std↩︎\nhttps://github.com/ziglang/zig/blob/master/lib/std/array_list.zig↩︎\nhttps://github.com/catchorg/Catch2/tree/devel↩︎\nhttps://docs.pytest.org/en/7.1.x/reference/reference.html#pytest-raises↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  }
]