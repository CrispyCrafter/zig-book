[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An Introduction to Zig",
    "section": "",
    "text": "Welcome\nWelcome! This is the initial page for the “Open Access” HTML version of the book “Introduction to Zig”, written by Pedro Duarte Faria. This book provides an introduction to the Zig programming language, which is a new general-purpose low-level language for building robust and optimal software.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#book-metadata",
    "href": "index.html#book-metadata",
    "title": "An Introduction to Zig",
    "section": "Book metadata",
    "text": "Book metadata\nThis book was compiled using the following versions of Zig and Quarto:\n\nSystem version: Linux, 6.5.0-41-generic, 22.04.2-Ubuntu, x86_64.\nZig version: 0.13.0-dev.266+0b0625ccf.\nQuarto version: 1.4.549.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html",
    "href": "Chapters/01-zig-weird.html",
    "title": "1  Introducing Zig",
    "section": "",
    "text": "1.1 What is Zig?\nZig is a modern, low-level, and general-purpose programming language. Some programmers interpret Zig as the “modern C language”. It is a simple language like C, but with some modern features.\nIn the author’s personal interpretation, Zig is tightly connected with “less is more”. Instead of trying to become a modern language by adding more and more features, many of the core improvements that Zig brings to the table are actually about removing annoying and evil behaviours/features from C and C++. In other words, Zig tries to be better by simplifying the language, and by having more consistent and robust behaviour. As a result, analyzing, writing and debugging applications become much easier and simpler in Zig, than it is in C or C++.\nThis philosophy becomes clear with the following phrase from the official website of Zig:\nThis phrase is specially true for C++ programmers. Because C++ is a gigantic language, with tons of features, and also, there are lots of different “flavors of C++”. These elements are what makes C++ so much complex and hard to learn. Zig tries to go in the opposite direction. Zig is a very simple language, more closely related to other simple languages such as C and Go.\nThe phrase above is still important for C programmers too. Because, even C being a simple language, it is still hard sometimes to read and understand C code. For example, pre-processor macros in C are an evil source of confusion. They really makes it hard sometimes to debug C programs. Because macros are essentially a second language embedded in C that obscures your C code. With macros, you are no longer 100% sure about which pieces of code are being sent to the compiler. It obscures the actual source code that you wrote.\nYou don’t have macros in Zig. In Zig, the code you write, is the actual code that get’s compiled by the compiler. You don’t have evil features that obscures you code. You also don’t have hidden control flow happening behind the scenes. And, you also don’t have functions or operators from the standard library that make hidden memory allocations behind your back.\nBy being a simpler language, Zig becomes much more clear and easier to read/write, but at the same time, it also achieves a much more robust state, with more consistent behaviour in edge situations. Once again, less is more.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#what-is-zig",
    "href": "Chapters/01-zig-weird.html#what-is-zig",
    "title": "1  Introducing Zig",
    "section": "",
    "text": "“Focus on debugging your application rather than debugging your programming language knowledge”.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#hello-world-in-zig",
    "href": "Chapters/01-zig-weird.html#hello-world-in-zig",
    "title": "1  Introducing Zig",
    "section": "1.2 Hello world in Zig",
    "text": "1.2 Hello world in Zig\nWe begin our journey in Zig by creating a small “Hello World” program. To start a new Zig project in your computer, you simply call the init command from the zig compiler. Just create a new directory in your computer, then, init a new Zig project inside this directory, like this:\nmkdir hello_world\ncd hello_world\nzig init\ninfo: created build.zig\ninfo: created build.zig.zon\ninfo: created src/main.zig\ninfo: created src/root.zig\ninfo: see `zig build --help` for a menu of options\n\n1.2.1 Understanding the project files\nAfter you run the init command from the zig compiler, some new files are created inside of your current directory. First, a “source” (src) directory is created, containing two files, main.zig and root.zig. Each .zig file is a separate Zig module, which is simply a text file that contains some Zig code.\nThe main.zig file for example, contains a main() function, which represents the entrypoint of your program. It is where the execution of your program begins. As you would expect from a C, C++, Rust or Go, to build an executabe program in Zig, you also need to declare a main() function in your module. So, the main.zig module represents an executable program written in Zig.\nOn the other side, the root.zig module does not contain a main() function. Because it represents a library written in Zig. Libraries are different than executables. They don’t need to have an entrypoint to work. So, you can choose which file (main.zig or root.zig) you want to follow depending on which type of project (executable or library) you want to develop.\ntree .\n.\n├── build.zig\n├── build.zig.zon\n└── src\n    ├── main.zig\n    └── root.zig\n\n1 directory, 4 files\nNow, in addition to the source directory, two other files were created in our working directory: build.zig and build.zig.zon. The first file (build.zig) represents a build script written in Zig. In other words, this file contain Zig code that executes the necessary steps to build the entire project.\nIn general, low-level languages normally use a compiler to build your source code into binary executables or binary libraries. Nevertheless, this process of compiling your source code and building binary executables or binary libraries from it, became a real challenge in the programming world, once the projects became bigger and bigger. As a result, programmers created “build systems”, which are a second set of tools designed to make this process of compiling and building complex projects, easier.\nExamples of build systems are CMake, GNU Make, GNU Autoconf and Ninja, which are used to build complex C and C++ projects. With these systems, you can write scripts, which are called “build scripts”. They simply are scripts that describes the necessary steps to compile/build your project.\nHowever, these are separate tools, that do not belong to C/C++ compilers, like gcc or clang. As a result, in C/C++ projects, you have not only to install and manage your C/C++ compilers, but you also have to install and manage these build systems separately.\nBut instead of using a separate build system, in Zig, we use the Zig language itself to write build scripts. In other words, Zig contains a native build system in it. And we can use this build system to write small scripts in Zig, which describes the necessary steps to build/compile our Zig project1. So, everything you need to build a complex Zig project is the zig compiler, and nothing more.\nNow that we described this topic in more depth, let’s focus on the second generated file (build.zig.zon), which is the Zig package manager configuration file, where you can list and manage the dependencies of your project. Yes, Zig have a package manager (like pip in Python, cargo in Rust, or npm in Javascript) called Zon, and this build.zig.zon file is similar to the package.json file in Javascript projects, or, the Pipfile in Python projects.\n\n\n1.2.2 Looking at the root.zig file\nLet’s take a look at the root.zig file, and start to analyze some of the syntax of Zig. The first thing that you might notice, is that every line of code that have an expression in it, ends with a semicolon character (;). This is similar syntax to other languages such as C, C++ and Rust, which have the same rule.\nAlso, notice the @import() call at the first line. We use this built-in function to import functionality from other Zig modules into our current module. In other words, the @import() function works similarly to the #include pre-processor in C or C++, or, to the import statement in Python or Javascript code. In this example, we are importing the std module, which gives you access to the Zig standard library.\nIn this root.zig file, we can also see how assignments (i.e. creating new objects) are made in Zig. You can create a new object in Zig by using the following syntax (const|var) name = value;. In the example below, we are creating two constant objects (std and testing). At Section 1.5 we talk more about objects in general.\n\nconst std = @import(\"std\");\nconst testing = std.testing;\n\nexport fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\nFunctions in Zig are declared similarly to functions in Rust, using the fn keyword. In the example above, we are declaring a function called add(), which have two arguments named a and b, and returns a integer number (i32) as result.\nMaybe Zig is not exactly a strongly-typed language, because you do not need necessarily to specify the type of every single object you create across your source code. But you do have to explicitly specify the type of every function argument, and also, the return type of every function you create in Zig. So, at least in function declarations, Zig is a strongly-typed language.\nWe specify the type of an object or a function argument in Zig, by using a colon character (:) followed by the type after the name of this object/function argument. With the expressions a: i32 and b: i32, we know that, both a and b arguments have type i32, which is a signed 32 bit integer. In this part, the syntax in Zig is identical to the syntax in Rust, which also specifies types by using the colon character.\nLastly, we have the return type of the function at the end of the line, before we open the curly braces to start writing the function’s body, which, in the example above is again a signed 32 bit integer (i32) value. This specific part is different than it is in Rust. Because in Rust, the return type of a function is specified after an arrow (-&gt;). While in Zig, we simply declare the return type directly after the parentheses with the function arguments.\nWe also have an export keyword before the function declaration. This keyword is similar to the extern keyword in C. It exposes the function to make it available in the library API.\nIn other words, if you have a project where you are currently building a library for other people to use, you need to expose your functions so that they are available in the library’s API, so that users can use it. If we removed the export keyword from the add() function declaration, then, this function would be no longer exposed in the library object built by the zig compiler.\nHaving that in mind, the keyword export is a keyword used in libraries written in Zig. So, if you are not currently writing a library in your project, then, you do not need to care about this keyword.\n\n\n1.2.3 Looking at the main.zig file\nNow that we have learned a lot about Zig’s syntax from the root.zig file, let’s take a look at the main.zig file. A lot of the elements we saw in root.zig are also present in main.zig. But we have some other elements that we did not have seen yet, so let’s dive in.\nFirst, look at the return type of the main() function in this file. We can see a small change. Now, the return type of the function (void) is accompanied by an exclamation mark (!). What this exclamation mark is telling us, is that this main() function might also return an error.\nSo, in this example, the main() function can either return void, or, return an error. This is an interesting feature of Zig. If you write a function, and, something inside of the body of this function might return an error, then, you are forced to:\n\neither add the exclamation mark to the return type of the function, to make it clear that this function might return an error.\nor explicitly handle this error that might occur inside the function, to make sure that, if this error does happen, you are prepared, and your function will no longer return an error because you handled the error inside your function.\n\nIn most programming languages, we normally handle (or deals with) an error through a try catch pattern, and Zig, this is no different. But, if we look at the main() function below, you can see that we do have a try keyword in the 5th line. But we do not have a catch keyword in this code.\nThis means that, we are using the keyword try to execute a code that might return an error, which is the stdout.print() expression. But because we do not have a catch keyword in this line, we are not treating (or dealing with) this error. So, if this expression do return an error, we are not catching and solving this error in any way. That is why the exclamation mark was added to the return type of the function.\nSo, in essence, the try keyword executes the expression stdout.print(). If this expression returns a valid value, then, the try keyword do nothing essentially. It simply passes this value forward. But, if the expression do return an error, then, the try keyword will unwrap and return this error from the function, and also print it’s stack trace to stderr.\nThis might sound weird to you, if you come from a high-level language. Because in high-level languages, such as Python, if an error occurs somewhere, this error is automatically returned and the execution of your program will automatically stops, even if you don’t want to stop the execution. You are obligated to face the error.\nBut if you come from a low-level language, then, maybe, this idea do not sound so weird or distant to you. Because in C for example, normally functions doesn’t raise errors, or, they normally don’t stop the execution. In C, error handling is done by constantly checking the return value of the function. So, you run the function, and then, you use an if statement to check if the function returned a value that is valid, or, if it returned an error. If an error was returned from the function, then, the if statement will execute some code that fixes this error.\nSo, at least for C programmers, they do need to write a lot of if statements to constantly check for errors around their code. And because of that, this simple feature from Zig, might be extraordinary for them. Because this try keyword can automatically unwrap the error, and warn you about this error, and let you deal with it, without any extra work from the programmer.\n\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n\nNow, another thing that you might have noticed in this code example, is that the main() function is marked with the pub keyword. This keyword means “public”. It marks the main() function as a public function from this module.\nIn other words, every function that you declare in your Zig module is, by default, a private (or “static”) function that belongs to this Zig module, and can only be used (or called) from within this same module. Unless, you explicitly mark this function as a public function with the pub keyword. This means that the pub keyword in Zig do essentially the opposite of what the static keyword do in C/C++.\nBy making a function “public”, you allow other Zig modules to access and call this function, and use it for they own purposes. all these other Zig modules need to do is, to import your module with the @import() built-in function. Then, they get access to all public functions that are present in your Zig module.\n\n\n1.2.4 Compiling your source code\nYou can compile your Zig modules into a binary executable by running the build-exe command from the zig compiler. You simply list all the Zig modules that you want to build after the build-exe command, separated by spaces. In the example below, we are compiling the module main.zig.\nzig build-exe src/main.zig\nSince we are building an executable, the zig compiler will look for a main() function declared in any of the files that you list after the build-exe command. If the compiler does not find a main() function declared somewhere, a compilation error will be raised, warning about this mistake.\nThe zig compiler also offers a build-lib and build-obj commands, which work the exact same way as the build-exe command. The only difference is that, they compile your Zig modules into a portale C ABI library, or, into object files, respectively.\nIn the case of the build-exe command, a binary executable file is created by the zig compiler in the root directory of your project. If we take a look now at the contents of our current directory, with a simple ls command, we can see the binary file called main that was created by the compiler.\nls\nbuild.zig  build.zig.zon  main  src\nIf I execute this binary executable, I get the “Hello World” message in the terminal , as we expected.\n./main\nHello, world!\n\n\n1.2.5 Compile and execute at the same time\nOn the previous section, I presented the zig build-exe command, which compiles Zig modules into an executable file. However, this means that, in order to execute the executable file, we have to run two different commands. First, the zig build-exe command, and then, we call the executable file created by the compiler.\nBut what if we wanted to perform these two steps, all at once, in a single command? We can do that by using the zig run command.\nzig run src/main.zig\nHello, world!\n\n\n1.2.6 Compiling the entire project\nJust as I described at Section 1.2.1, as our project grows in size and complexity, we usually prefer to organize the compilation and build process of the project into a build script, using some sort of “build system”.\nIn other words, as our project grows in size and complexity, the build-exe, build-lib and build-obj commands become harder and header to use directly. Because then we start to list multiple and multiple modules at the same time. We also start to adding built-in compilation flags to customize the build process for our needs, etc. It becomes a lot of work to write the necessary commands by hand.\nIn C/C++ projects, programmers usually opt to use CMake, Makefile or configure scripts to organize this process. However, in Zig, we have a native build system in the language itself. So, we can write build scripts in Zig to compile and build Zig projects. Then, all we need to do, is to call the zig build command to build our project.\nSo, when you execute the zig build command, the zig compiler will search for a Zig module named build.zig inside your current directory, which should be your build script, containing the necessary code to compile and build your project. If the compiler do find this build.zig file in your directory, then, the compiler will essentially execute a zig run command over this build.zig file, to compile and execute this build script, which in turn, will compile and build your entire project.\nzig build\nAfter you execute this “build project” command, a zig-out directory is created in the root of your project directory, where you can find the binary executables and libraries created from your Zig modules accordingly to the build commands that you specified at build.zig. We will talk more about the build system in Zig latter in this book.\nIn the example below, I’m executing the binary executable named hello_world that was generated by the compiler after the zig build command.\n./zig-out/bin/hello_world\nHello, world!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#high-level-languages-vs-low-level-languages",
    "href": "Chapters/01-zig-weird.html#high-level-languages-vs-low-level-languages",
    "title": "1  Introducing Zig",
    "section": "1.3 High-level languages vs Low-level languages",
    "text": "1.3 High-level languages vs Low-level languages\nThis book will definitely help you, on your journey to learn Zig. But there is a limit on how much a book can do. So you will need extra resources, and more strategies if you want to trully be good at Zig.\nYou will need more resources, not because Zig is necessarily a hard language to learn, but because it is a low-level language. I’m emphasizing that, because not many people think much about the consequences of this fact. As I sad earlier, Zig is a very simple language, with very simple syntax. But because it is a low-level language, you will have to write (at least) as twice amount of Zig code to do a similar job that you would do on a high-level language, such as Python or Javascript.\nIn other words, with a low-level language you get much more control and power, but you also get a lot more responsibilities. You have to be much more explicit and include much more details in your code to make it work properly. This is an intrinsic characteristic present in all low-level languages, such as C, C++ and Rust.\nAnother side of the problem with low-level languages is that they require a different set of skills and knowledges from you, and this creates a skill (or knowledge) gap for a lot of professionals. I mean, high-level languages are so much easier, that you, as a professional, can work and focus on other things, or other aspects of your profession that might be equally important to your career, such as: doing a graduate course, or learning more about business strategy, product development, and soft skills (such as communication skills, personal development).\nJust as a simple example, a part of the readers of this book probably work with Websites and APIs in the Web, using either Javascript, Python or PHP. These high-level languages include multiple layers of abstractions in them, which will help you to work quicker and with ease. As a consequence, dealing with APIs in these languages is much simpler. Because you don’t have to learn all of these very specific terms and technical knowledge about how HTTP actually works at the lowest level. All you really need to know, is which library to use, and how to assemble the parts that make a HTTP Request.\nIn contrast, when working with a low-level language, most of the times you have to implement a HTTP Server from scratch, or, to use a library that helps you get there, but doesn’t include a high amount of abstractions. As a result of that, you need to learn a lot of details about how HTTP actually works at the lowest level. You will probably need to learn: 1) some details about the HTTP Protocol specification; 2) a lot of technical terms about web sockets (such as “listen”, “bind socket”, “accept connection”); 3) how to create TCP connections using IP addresses; 4) learn about the difference between IPv4 and IPv6. In essence, when you work with a low-level language, you have to know much more details about everything you do.\nAnother topic that makes low-level languages much harder to learn than high-level languages is compilation. In low-level languages, you have to use a compiler to compile your source code into binary executables or libraries. But compiling the same source code in multiple platforms, for multiple targets, is actually incredibly hard, and a real challenge in our modern world. Differences between the manufacturing and architecture of each computer, or, the differences between the operational system used, make this really hard on low-level languages, specially in C and C++.\nThis compilation problem arises very quickly when we are developing big libraries (or applications) in C or C++ that are, at the same time, cross-platform and highly optimized. As I described at Section 1.2.1, this is the whole reason why we created a whole set of separate tools named “build systems”. To abstract some of these barriers that exists in the compilation process at low-level languages.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#how-to-learn-zig",
    "href": "Chapters/01-zig-weird.html#how-to-learn-zig",
    "title": "1  Introducing Zig",
    "section": "1.4 How to learn Zig?",
    "text": "1.4 How to learn Zig?\nNow, you might have the following thought:\n\nOk! I understand that low-level languages are harder than high-level languages. But how do I learn Zig? Which tips you have for me?\n\nFirst of all, you can join a community with Zig programmers to get some help:\n\nReddit forum: https://www.reddit.com/r/Zig/;\nDiscord, Slack, Telegram, and others: https://github.com/ziglang/zig/wiki/Community;\n\nNow, one of the best ways to learn Zig is to simply read Zig code. Try to read Zig code often, and things will become more clear. A C/C++ programmer would also probably give you this same tip. Because this strategy really works!\nNow, where do you read Zig code? I personally think that, the best way of reading Zig code is to read the source code of the Zig Standard Library. Also, a great alternative is to read code from large Zig codebases, such as Bun. Both of these assets are available on GitHub, and this is great, because we can use the GitHub search bar in our advantage, to find Zig code that fits our description.\nThe Zig Standard Library is available at the lib/std folder2 on the official GitHub repository of Zig. Access this folder, and start exploring the Zig modules. If want to search for a use case for a specific Zig function, remember to include lang:Zig in the GitHub search bar. This will limit the search to only Zig modules.\nAlso, a great alternative is to consult online resources and documentations. Here is a quick list of resources that I personally use from time to time to learn more about the language each day:\n\nZig Language Reference: https://ziglang.org/documentation/master/;\nZig Standard Library Reference: https://ziglang.org/documentation/master/std/;\nZig Guide: https://zig.guide/;\nKarl Seguin Blog: https://www.openmymind.net/;\nZig News: https://zig.news/;\nRead the code written by one of Zig core team members: https://github.com/kubkon;\nSome livecoding sessions are transmitted in the Zig Showtime Youtube Channel: https://www.youtube.com/@ZigSHOWTIME/videos;\n\nAnother great strategy to learn Zig, or honestly, to learn any language you want, is to practice writing Zig code by solving Advent of Code exercises3. There are people that already took the time to learn and solve the exercises, and they posted their solutions on GitHub as well, so, in case you need some resource to compare while solving the exercises, you can look at these two repositories:\n\nhttps://github.com/SpexGuy/Zig-AoC-Template;\nhttps://github.com/fjebaker/advent-of-code-2022;",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-assignments",
    "href": "Chapters/01-zig-weird.html#sec-assignments",
    "title": "1  Introducing Zig",
    "section": "1.5 Creating new objects in Zig (i.e. identifiers)",
    "text": "1.5 Creating new objects in Zig (i.e. identifiers)\nLet’s talk more about objects in Zig. Readers that have past experience with other programming languages might know the concept of “object” through a different name, such as: “variable” or “identifier”. In this book, I choose to use the name “object”.\nTo create a new object (or a new “identifier”) in Zig, we use the keywords const or var. These keywords specificy if the object that you are creating is mutable or not.\nIf you use const, then, the object you are creating is a constant (or immutable) object, meaning that, once you declare this object, you can no longer change the value stored inside this object.\nOn the other side, if you use var, then, you are creating a variable (or mutable) object. So, you can change the value of this object as many times you want. Using the keyword var in Zig is similar to using the keywords let mut in Rust.\n\n1.5.1 Constant objects vs variable objects\nIn the code example below, we are creating a new constant object called age. This object stores a number representing the age of someone. However, this code example does not compiles succesfully. Because on the next line of code, we are trying to change the value of the object age to 25.\nThe zig compiler detects that we are trying to change the value of an object/identifier that is constant, and because of that, the compiler will raise a compilation error, warning us about the mistake.\n\nconst age = 24;\n// The line below is not valid!\nage = 25;\n\nt.zig:10:5: error: cannot assign to constant\n    age = 25;\n      ~~^~~\nIn contrast, if you use var, then, the object created is a variable object. With var you can declare this object in your source code, and then, change the value of this object how many times you want over future points in your source code.\nSo, using the same code example exposed above, if I change the declaration of the age object to use the var keyword, then, the program gets compiled succesfully. Because now, the zig compiler detects that we are changing the value of an object that allows this behaviour, because it is an “variable object”.\n\nvar age: u8 = 24;\nage = 25;\n\n\n\n1.5.2 There is no such thing as unused objects\nEvery object (being constant or variable) that you declare in Zig must be used in some way. You can give this object to a function call, as a function argument, or, you can use it in another expression to calculate the value of another object, or, you can call a method that belongs to this particular object.\nIt doesn’t matter in which way you use it. As long as you use it. If you try to break this rule, i.e. if your try to declare a object, but not use it, the zig compiler will not compile your Zig source code, and it will issue a error message warning that you have unused objects in your code.\nLet’s demonstrate this with an example. In the source code below, we declare a constant object called age. If you try to compile a simple Zig program with this line of code below, the compiler will return an error as demonstrated below:\n\nconst age = 15;\n\nt.zig:4:11: error: unused local constant\n    const age = 15;\n          ^~~\nEverytime you declare a new object in Zig, you have two choices:\n\nyou either use the value of this object;\nor you explicitly discard the value of the object;\n\nTo explicitly discard the value of any object (constant or variable), all you need to do is to assign this object to an special character in Zig, which is the underscore (_). When you assign an object to a underscore, like in the example below, the zig compiler will automatically discard the value of this particular object.\nYou can see in the example below that, this time, the compiler did not complain about any “unused constant”, and succesfully compiled our source code.\n\n// It compiles!\nconst age = 15;\n_ = age;\n\nNow, remember, everytime you assign a particular object to the underscore, this object is essentially destroyed. It is discarded by the compiler. This means that you can no longer use this object further in your code. It doesn’t exist anymore.\nSo if you try to use the constant age in the example below, after we discarded it, you will get a loud error message from the compiler (talking about a “pointless discard”) warning you about this mistake.\n\n// It does not compile.\nconst age = 15;\n_ = age;\n// Using a discarded value!\nstd.debug.print(\"{d}\\n\", .{age + 2});\n\nt.zig:7:5: error: pointless discard\n    of local constant\nThis same rule applies to variable objects. Every variable object must also be used in some way. And if you assign a variable object to the underscore, this object also get’s discarded, and you can no longer use this object.\n\n\n1.5.3 You must mutate every variable objects\nEvery variable object you create in your source code must be mutated at some point in your source code. In other words, if you declare an object as a variable object, with the keyword var, if you do not change the value of this object at some point in the future, the zig compiler will detect this, and it will raise an error warning you about this mistake.\nThe concept behind this is that, every object you create in Zig should be explicitly constant, unless you really need an object whose value will change during the execution of your program.\nSo, if I try to declare a variable object such as where_i_live below, and I do not change the value of this object in some way, the zig compiler raises an error about ““.\n\nvar where_i_live = \"Belo Horizonte\";\n_ = where_i_live;\n\nt.zig:7:5: error: local variable is never mutated\nt.zig:7:5: note: consider using 'const'",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#primitive-data-types",
    "href": "Chapters/01-zig-weird.html#primitive-data-types",
    "title": "1  Introducing Zig",
    "section": "1.6 Primitive Data Types",
    "text": "1.6 Primitive Data Types\nZig have many different primitive data types available for you to use. You can see the full list of available data types at the Language Reference page4.\nBut here is a quick list:\n\nUnsigned integers: u8, 8-bit integer; u16, 16-bit integer; u32, 32-bit integer; u64, 64-bit integer; u128, 128-bit integer.\nSigned integers: i8, 8-bit integer; i16, 16-bit integer; i32, 32-bit integer; i64, 64-bit integer; i128, 128-bit integer.\nFloat number: f16, 16-bit floating point; f32, 32-bit floating point; f64, 64-bit floating point; f128, 128-bit floating point;\nBoolean: bool, represents true or false values.\nC ABI compatible types: c_long, c_char, c_short, c_ushort, c_int, c_uint, and many others.\nPointer sized integers: isize and usize.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-arrays",
    "href": "Chapters/01-zig-weird.html#sec-arrays",
    "title": "1  Introducing Zig",
    "section": "1.7 Arrays",
    "text": "1.7 Arrays\nYou create arrays in Zig by using a syntax that resembles the C syntax. First, you specify the size of the array (i.e. the number of elements that will be stored in the array) you want to create inside a pair of brackets.\nThen, you specify the data type of the elements that will be stored inside this array. All elements present in an array in Zig must have the same data type. For example, you cannot mix elements of type f32 with elements of type i32 in the same array.\nAfter that, you simply list the values that you want to store in this array inside a pair of curly braces. In the example below, I am creating two constant objets that contain different arrays. The first object contains an array of 4 integer values, while the second object, an array of 3 floating point values.\nNow, you should notice that in the object ls, I am not explicitly specifying the size of the array inside of the brackets. Instead of using a literal value (like the value 4 that I used in the ns object), I am using the special character underscore (_). This syntax tells the zig compiler to fill this field with the number of elements listed inside of the curly braces. So, this syntax [_] is for lazy (or smart) programmers who leave the job of counting how many elements there are in the curly braces for the compiler.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst ls = [_]f64{432.1, 87.2, 900.05};\n_ = ns; _ = ls;\n\n\n1.7.1 Selecting elements of the array\nOne very commom activity is to select specific portions of an array you have in your source code. In Zig, you can select a specific element from your array, by simply providing the index of this particular element inside brackets after the object name. In the example below, I am selecting the third element from the ns array. Notice that Zig is a “zero-index” based language, like C, C++, Rust, Python, and many other languages.\n\nconst ns = [4]u8{48, 24, 12, 6};\ntry stdout.print(\"{d}\\n\", .{ ns[2] });\n\n12\n\n\nIn contrast, you can also select specific slices (or sections) of your array, by using a range selector. Some programmers also call these selectors of “slice selectors”, and they also exist in Rust, and have the exact same syntax as in Zig. Anyway, a range selector is a special expression in Zig that defines a range of indexes, and it have the syntax start..end.\nIn the example below, at the second line of code, the sl object stores a slice (or a portion) of the ns array. More precisely, the elements at index 1 and 2 in the ns array.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..3];\n_ = sl;\n\nWhen you use the start..end syntax, the “end tail” of the range selector is non-inclusive, meaning that, the index at the end is not included in the range that is selected from the array. Therefore, the syntax start..end actually means start..end - 1 in practice.\nYou can also use the syntax start.. in your range selector. Which tells the zig compiler to select the portion of the array that begins at the start index until the last element of the array. In the example below, we are selecting the range from index 1 until the end of the array.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..];\n_ = sl;\n\n\n\n1.7.2 More on slices\nAs we discussed before, in Zig, you can select specific portions of an existing array. This is called slicing in Zig (Sobeston 2024), because when you select a portion of an array, you are creating a slice object from that array.\nA slice object is essentially a pointer object accompained by a length number. The pointer object points to the first element in the slice, and the length number tells the zig compiler how many elements there are in this slice.\n\nSlices can be thought of as a pair of [*]T (the pointer to the data) and a usize (the element count) (Sobeston 2024).\n\nThrough the pointer contained inside the slice you can access the elements (or values) that are inside this range (or portion) that you selected from the original array. But the length number (which you can access through the len property of your slice object) is the really big improvement (over C arrays for example) that Zig brings to the table here.\nBecause with this length number the zig compiler can easily check if you are trying to access an index that is out of the bounds of this particular slice, or, if you are causing any buffer overflow problems. In the example below, we access the len property of the slice sl, which tells us that this slice have 2 elements in it.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..3];\ntry stdout.print(\"{d}\\n\", .{sl.len});\n\n2",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-zig-control-flow",
    "href": "Chapters/01-zig-weird.html#sec-zig-control-flow",
    "title": "1  Introducing Zig",
    "section": "1.8 Control flow",
    "text": "1.8 Control flow\nSometimes, you need to make decisions in your program. Maybe you need to decide wether to execute or not a specific piece of code. Or maybe, you need to apply the same operation over a sequence of values. These kinds of tasks, involve using structures that are capable of changing the “control flow” of our program.\nIn computer science, the term “control flow” usually refers to the order in which expressions (or commands) are evaluated in a given language or program. But this term is also used to refer to structures that are capable of changing this “evaluation order” of the commands executed by a given language/program.\nThese structures are better known by a set of terms, such as: loops, if/else statements, switch statements, among others. So, loops and if/else statements are examples of structures that can change the “control flow” of our program. The keywords continue and break are also examples of symbols that can change the order of evaluation, since they can move our program to the next iteration of a loop, or make the loop stop completely.\n\n1.8.1 If/else statements\nAn if/else statement performs an “conditional flow operation”. A conditional flow control (or choice control) allows you to execute or ignore a certain block of commands based on a logical condition. Many programmers and computer science professionals also use the term “branching” in this case. In essence, we use if/else statements to use the result of a logical test to decide whether or not to execute a given block of commands.\nIn Zig, we write if/else statements by using the keywords if and else. We start with the if keyword followed by a logical test inside a pair of parentheses, and then, a pair of curly braces with contains the lines of code to be executed in case the logical test returns the value true.\nAfter that, you can optionally add an else statement. Just add the else keyword followed by a pair of curly braces, with the lines of code to executed in case the logical test defined in the if returns false.\nIn the example below, we are testing if the object x contains a number that is greater than 10. Judging by the output printed to the console, we know that this logical test returned false. Because the output in the console is compatible with the line of code present in the else branch of the if/else statement.\n\nconst x = 5;\nif (x &gt; 10) {\n    try stdout.print(\n        \"x &gt; 10!\\n\", .{}\n    );\n} else {\n    try stdout.print(\n        \"x &lt;= 10!\\n\", .{}\n    );\n}\n\nx &lt;= 10!\n\n\n\n\n1.8.2 For loops\nA loop allows you to execute the same lines of code multiple times, thus, creating a “repetition space” in the execution flow of your program. Loops are particularly useful when we want to replicate the same function (or the same set of commands) over several different inputs.\nThere are different types of loops available in Zig. But the most essential of them all is probably the for loop. A for loop is used to apply the same piece of code over the elements of a slice or an array.\nFor loops in Zig have a slightly different syntax that you are probably used to see in other languages. You start with the for keyword, then, you list the items that you want to iterate over inside a pair of parentheses. Then, inside of a pair of pipes (|) you should declare an identifier that will serve as your iterator, or, the “repetition index of the loop”.\n\nfor (items) |value| {\n    // code to execute\n}\n\nThat is, instead of using a (value in items) syntax, in Zig, for loops use the syntax (items) |value|. In the example below, you can see that we are looping through the items of the array stored in the object name, and printing to the console the decimal representation of each character in this array.\nIf we wanted, we could also iterate through a slice (or a portion) of the array, instead of iterating through the entire array stored in the name object. Just use a range selector to select the section you want. For example, I could provide the expression name[0..2] to the for loop, to iterate just through the first 3 elements in the array.\n\nconst name = [_]u8{'P','e','d','r','o'};\nfor (name) |char| {\n    try stdout.print(\n        \"{d} | \", .{char}\n    );\n}\n\n80 | 101 | 100 | 114 | 111 | \n\n\nIn the above example we are using the value itself of each element in the array as our iterator. But there are many situations where we need to use an index instead of the actual values of the items.\nYou can do that by providing a second set of items to iterate over. More precisely, you provide the range selector 0.. to the for loop. So, yes, you can use two different iterators at the same time in a for loop in Zig.\nBut remember from Section 1.5 that, every object you create in Zig must be used in some way. So if you declare two iterators in your for loop, you must use both iterators inside the for loop body. But if you want to use just the index iterator, and not use the “value iterator”, then, you can discard the value iterator by maching the value items to the underscore character, like in the example below:\n\nfor (name, 0..) |_, i| {\n    try stdout.print(\"{d} | \", .{i});\n}\n\n0 | 1 | 2 | 3 | 4 |\n\n\n1.8.3 While loops\nA while loop is created from the while keyword. While a for loop iterates through the items of an array, a while loop will loop continuously, and infinitely, until a logical test (specified by you) becomes false.\nYou start with the while keyword, then, you define a logical expression inside a pair of parentheses, and the body of the loop is provided inside a pair of curly braces, like in the example below:\n\nvar i: u8 = 1;\nwhile (i &lt; 5) {\n    try stdout.print(\"{d} | \", .{i});\n    i += 1;\n}\n\n1 | 2 | 3 | 4 | \n\n\n\n\n1.8.4 Using break and continue\nIn Zig, you can explicitly stop the execution of a loop, or, jump to the next iteration of the loop, using the keywords break and continue, respectively. The while loop present in the example below, is at first sight, an infinite loop. Because the logical value inside the parenthese will always be equal to true. What makes this while loop stop when the i object reaches the count 10? Is the break keyword!\nInside the while loop, we have an if statement that is constantly checking if the i variable is equal to 10. Since we are increasing the value of this i variable at each iteration of the while loop. At some point, this i variable will be equal to 10, and when it does, the if statement will execute the break expression, and, as a result, the execution of the while loop is stopped.\nNotice the expect() function from the Zig standard library after the while loop. This expect() function is an “assert” type of function. This function checks if the logical test provided is equal to true. If this logical test is false, the function raises an assertion error. But it is equal to true, then, the function will do nothing.\n\nvar i: usize = 0;\nwhile (true) {\n    if (i == 10) {\n        break;\n    }\n    i += 1;\n}\ntry std.testing.expect(i == 10);\ntry stdout.print(\"Everything worked!\", .{});\n\nEverything worked!\n\n\nSince this code example was executed succesfully by the zig compiler, without raising any errors, then, we known that, after the execution of while loop, the i variable is equal to 10. Because if it wasn’t equal to 10, then, an error would be raised by expect().\nNow, in the next example, we have an use case for the continue keyword. The if statement is constantly checking if the current index is a multiple of 2. If it is, then we jump to the next iteration of the loop directly. But it the current index is not a multiple of 2, then, the loop will simply print this index to the console.\n\nconst ns = [_]u8{1,2,3,4,5,6};\nfor (ns) |i| {\n    if ((i % 2) == 0) {\n        continue;\n    }\n    try stdout.print(\"{d} | \", .{i});\n}\n\n1 | 3 | 5 |",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-structs-and-oop",
    "href": "Chapters/01-zig-weird.html#sec-structs-and-oop",
    "title": "1  Introducing Zig",
    "section": "1.9 Structs and OOP",
    "text": "1.9 Structs and OOP\nZig is a language more closely related to C (which is a procedural language), than it is to C++ or Java (which are object-oriented languages). Because of that, you do not have advanced OOP (Object-Oriented Programming) patterns available in Zig, such as classes, interfaces or class inheritance. Nonetheless, OOP in Zig is still possible by using struct definitions.\nWith struct definitions, you can create (or define) a new data type in Zig. These struct definitions work the same way as they work in C. You give a name to this new struct (or, to this new data type you are creating), then, you list the data members of this new struct. You can also register functions inside this struct, and they become the methods of this particular struct (or data type), so that, every object that you create with this new type, will always have these methods available and associated with them.\nIn C++, when we create a new class, we normally have a constructor method (or, a constructor function) to construct or to instantiate every object of this particular class, and you also have a destructor method (or a destructor function) that is the function responsible for destroying every object of this class.\nIn Zig, we normally declare the constructor and the destructor methods of our structs, by declaring an init() and a deinit() methods inside the struct. This is just a naming convention that you will find across the entire Zig standard library. So, in Zig, the init() method of a struct is normally the constructor method of the class represented by this struct. While the deinit() method is the method used for destroying an existing instance of that struct.\nBoth the init() and deinit() methods are used extensively in Zig code, and you will see both of them at Section 2.2.7. In this section, I presented the ArenaAllocator(), which is a special type of allocator object that receives a second (child) of allocator object at instantiation. We used the init() to create a new ArenaAllocator() object, then, on the next line, we also used the deinit() method in conjunction with the defer keyword, to destroy this arena allocator object at the end of the current scope.\nBut, as another example, let’s build a simple User struct to represent an user of some sort of system. If you look at the User struct below, you can see the struct keyword, and inside of a pair of curly braces, we write the struct’s body.\nNotice the data members of this struct, id, name and email. Every data member have it’s type explicitly annotated, with the colon character (:) syntax that we described earlier at Section 1.2.2. But also notice that every line in the struct body that describes a data member, ends with a comma character (,). So every time you declare a data member in your Zig code, always end the line with a comma character, instead of ending it with the traditional semicolon character (;).\nNext, also notice in this example, that we registrated an init() function as a method of this User struct. This init() method is the constructor method that you use to instantiate every new User object. That is why this init() function return an User object as result.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst User = struct {\n    id: u64,\n    name: []const u8,\n    email: []const u8,\n\n    pub fn init(id: u64,\n                name: []const u8,\n                email: []const u8) User {\n\n        return User {\n            .id = id,\n            .name = name,\n            .email = email\n        };\n    }\n\n    pub fn print_name(self: User) !void {\n        try stdout.print(\"{s}\\n\", .{self.name});\n    }\n};\n\npub fn main() !void {\n    const u = User.init(1, \"pedro\", \"email@gmail.com\");\n    try u.print_name();\n}\n\npedro\n\n\nThe pub keyword plays an important role in struct declarations, and OOP in Zig. Every method that you declare in your struct that is marked with the keyword pub, becomes a public method of this particular struct.\nSo every method that you create in your struct, is, at first, a private method of that struct. Meaning that, this method can only be called from within this struct. But, if you mark this method as public, with the keyword pub, then, you can call the method directly from the User object you have in your code.\nIn other words, the functions marked by the keyword pub are members of the public API of that struct. For example, if I did not marked the print_name() method as public, then, I could not execute the line u.print_name(). Because I would not be authorized to call this method directly in my code.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#anonymous-struct-literals",
    "href": "Chapters/01-zig-weird.html#anonymous-struct-literals",
    "title": "1  Introducing Zig",
    "section": "1.10 Anonymous struct literals",
    "text": "1.10 Anonymous struct literals\nIn traditional struct literals, you can specify the type of the struct literal you are writing just before the opening curly braces. So, I could write a struct literal of type User that we defined in the previous section like this:\n\nconst eu = User {\n    .id = 1,\n    .name = \"Pedro\",\n    .email = \"someemail@gmail.com\"\n};\n_ = eu;\n\nHowever, in Zig, we can also write an anonymous struct literal. That is, you can write a struct literal, but not especify explicitly the type of this particular struct. An anonymous struct is written by using the syntax .{}. So, we essentially replace the explicit type of the struct literal with a dot character (.).\nWhen you do that, the type of this struct literal is automatically inferred by the zig compiler. In essence, the zig compiler will look for some hint of what is the type of that struct. It can be the type annotation of an function argument, or the return type annotation of the function you are using, or the type annotation of a variable. If the compiler do find such type annotation, then, it will use this type in your literal struct.\nAnonymous structs are very commom to use on function arguments in Zig. One example that you have seen already constantly, is the print() function from the stdout. This function takes two arguments. The first argument, is a template string, which should contain string format specifiers in it, which tells how the values provided in the second argument should be printed into the message.\nWhile the second argument is a struct literal that lists the values to be printed into the template message specified in the first argument. You normally want to use an anonymous struct literal here, so that, the zig compiler do the job of specifying the type of this particular anonymous struct for you.\n\nconst std = @import(\"std\");\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n\nHello, world!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-zig-strings",
    "href": "Chapters/01-zig-weird.html#sec-zig-strings",
    "title": "1  Introducing Zig",
    "section": "1.11 How strings work in Zig?",
    "text": "1.11 How strings work in Zig?\nThe first project that we are going to build and discuss in this book is a base64 encoder/decoder (Chapter 3). But in order for us to build such a thing, we need to get a better understanding on how strings work in Zig. So let’s discuss this specific aspect of Zig.\nIn Zig, a string literal (or a string object if you prefer) is a pointer to a null-terminated array of bytes. Each byte in this array is represented by an u8 value, which is an unsigned 8 bit integer, so, it is equivalent to the C data type unsigned char.\nZig always assumes that this sequence of bytes is UTF-8 encoded. This might not be true for every sequence of bytes you have it, but is not really Zig’s job to fix the encoding of your strings (you can use iconv5 for that). Today, most of the text in our modern world, specially on the web, should be UTF-8 encoded. So if your string literal is not UTF-8 encoded, then, you will likely have problems in Zig.\nLet’s take for example the word “Hello”. In UTF-8, this sequence of characters (H, e, l, l, o) is represented by the sequence of decimal numbers 72, 101, 108, 108, 111. In xecadecimal, this sequence is 0x48, 0x65, 0x6C, 0x6C, 0x6F. So if I take this sequence of hexadecimal values, and ask Zig to print this sequence of bytes as a sequence of characters (i.e. a string), then, the text “Hello” will be printed into the terminal:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const bytes = [_]u8{0x48, 0x65, 0x6C, 0x6C, 0x6F};\n    try stdout.print(\"{s}\\n\", .{bytes});\n}\n\nHello\n\n\nIf you want to see the actual bytes that represents a string in Zig, you can use a for loop to iterate trough each byte in the string, and ask Zig to print each byte as an hexadecimal value to the terminal. You do that by using a print() statement with the X formatting specifier, like you would normally do with the printf() function6 in C.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"This is an example of string literal in Zig\";\n    try stdout.print(\"Bytes that represents the string object: \", .{});\n    for (string_literal) |byte| {\n        try stdout.print(\"{X} \", .{byte});\n    }\n    try stdout.print(\"\\n\", .{});\n}\n\nBytes that represents the string object: 54 68 69 \n   73 20 69 73 20 61 6E 20 65 78 61 6D 70 6C 65 20 6F\n  F 66 20 73 74 72 69 6E 67 20 6C 69 74 65 72 61 6C 2\n  20 69 6E 20 5A 69 67 \n\n\n\n1.11.1 Strings in C\nAt first glance, this looks very similar to how C treats strings as well. That is, string values in C are also treated internally as an array of bytes, and this array is also null-terminated.\nBut one key difference between a Zig string and a C string, is that Zig also stores the length of the array inside the string object. This small detail makes your code safer, because is much easier for the Zig compiler to check if you are trying to access an element that is “out of bounds”, i.e. if your trying to access memory that does not belong to you.\nTo achieve this same kind of safety in C, you have to do a lot of work that kind of seems pointless. So getting this kind of safety is not automatic and much harder to do in C. For example, if you want to track the length of your string troughout your program in C, then, you first need to loop through the array of bytes that represents this string, and find the null element ('\\0') position to discover where exactly the array ends, or, in other words, to find how much elements the array of bytes contain.\nTo do that, you would need something like this in C. In this example, the C string stored in the object array is 25 bytes long:\n#include &lt;stdio.h&gt;\nint main() {\n    char* array = \"An example of string in C\";\n    int index = 0;\n    while (1) {\n        if (array[index] == '\\0') {\n            break;\n        }\n        index++;\n    }\n    printf(\"Number of elements in the array: %d\\n\", index);\n}\nNumber of elements in the array: 25\nBut in Zig, you do not have to do this, because the object already contains a len field which stores the length information of the array. As an example, the string_literal object below is 43 bytes long:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"This is an example of string literal in Zig\";\n    try stdout.print(\"{d}\\n\", .{string_literal.len});\n}\n\n43\n\n\n\n\n1.11.2 A better look at the object type\nNow, we can inspect better the type of objects that Zig create. To check the type of any object in Zig, you can use the @TypeOf() function. If we look at the type of the simple_array object below, you will find that this object is a array of 4 elements. Each element is a signed integer of 32 bits which corresponds to the data type i32 in Zig. That is what an object of type [4]i32 is.\nBut if we look closely at the type of the string_literal object below, you will find that this object is a constant pointer (hence the *const annotation) to an array of 43 elements (or 43 bytes). Each element is a single byte (more precisely, an unsigned 8 bit integer - u8), that is why we have the [43:0]u8 portion of the type below. In other words, the string stored inside the string_literal object is 43 bytes long. That is why you have the type *const [43:0]u8 below.\nIn the case of string_literal, it is a constant pointer (*const) because the object string_literal is declared as constant in the source code (in the line const string_literal = ...). So, if we changed that for some reason, if we declare string_literal as a variable object (i.e. var string_literal = ...), then, string_literal would be just a normal pointer to an array of unsigned 8-bit integers (i.e. * [43:0]u8).\nNow, if we create an pointer to the simple_array object, then, we get a constant pointer to an array of 4 elements (*const [4]i32), which is very similar to the type of the string_literal object. This demonstrates that a string object (or a string literal) in Zig is already a pointer to an array.\nJust remember that a “pointer to an array” is different than an “array”. So a string object in Zig is a pointer to an array of bytes, and not simply an array of bytes.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"This is an example of string literal in Zig\";\n    const simple_array = [_]i32{1, 2, 3, 4};\n    try stdout.print(\"Type of array object: {}\", .{@TypeOf(simple_array)});\n    try stdout.print(\n        \"Type of string object: {}\",\n        .{@TypeOf(string_literal)}\n    );\n    try stdout.print(\n        \"Type of a pointer that points to the array object: {}\",\n        .{@TypeOf(&simple_array)}\n    );\n}\n\nType of array object: [4]i32\nType of string object: *const [43:0]u8\nType of a pointer that points to\n    the array object: *const [4]i32\n\n\n1.11.3 Byte vs unicode points\nIs important to point out that each byte in the array is not necessarily a single character. This fact arises from the difference between a single byte and a single unicode point.\nThe encoding UTF-8 works by assigning a number (which is called a unicode point) to each character in the string. For example, the character “H” is stored in UTF-8 as the decimal number 72. This means that the number 72 is the unicode point for the character “H”. Each possible character that can appear in a UTF-8 encoded string have its own unicode point.\nFor example, the Latin Capital Letter A With Stroke (Ⱥ) is represented by the number (or the unicode point) 570. However, this decimal number (570) is higher than the maximum number stored inside a single byte, which is 255. In other words, the maximum decimal number that can be represented with a single byte is 255. That is why, the unicode point 570 is actually stored inside the computer’s memory as the bytes C8 BA.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"Ⱥ\";\n    try stdout.print(\"Bytes that represents the string object: \", .{});\n    for (string_literal) |char| {\n        try stdout.print(\"{X} \", .{char});\n    }\n}\n\nBytes that represents the string object: C8 BA \n\n\nThis means that to store the character Ⱥ in an UTF-8 encoded string, we need to use two bytes together to represent the number 570. That is why the relationship between bytes and unicode points is not always 1 to 1. Each unicode point is a single character in the string, but not always a single byte corresponds to a single unicode point.\nAll of this means that if you loop trough the elements of a string in Zig, you will be looping through the bytes that represents that string, and not through the characters of that string. In the Ⱥ example above, the for loop needed two iterations (instead of a single iteration) to print the two bytes that represents this Ⱥ letter.\nNow, all english letters (or ASCII letters if you prefer) can be represented by a single byte in UTF-8. As a consequence, if your UTF-8 string contains only english letters (or ASCII letters), then, you are lucky. Because the number of bytes will be equal to the number of characters in that string. In other words, in this specific situation, the relationship between bytes and unicode points is 1 to 1.\nBut on the other side, if your string contains other types of letters… for example, you might be working with text data that contains, chinese, japanese or latin letters, then, the number of bytes necessary to represent your UTF-8 string will likely be much higher than the number of characters in that string.\nIf you need to iterate through the characters of a string, instead of its bytes, then, you can use the std.unicode.Utf8View struct to create an iterator that iterates through the unicode points of your string.\nIn the example below, we loop through the japanese characters “アメリカ”. Each of the four characters in this string is represented by three bytes. But the for loop iterates four times, one iteration for each character/unicode point in this string:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    var utf8 = (\n        (try std.unicode.Utf8View.init(\"アメリカ\"))\n            .iterator()\n    );\n    while (utf8.nextCodepointSlice()) |codepoint| {\n        try stdout.print(\n            \"got codepoint {}\\n\",\n            .{std.fmt.fmtSliceHexUpper(codepoint)}\n        );\n    }\n}\n\ngot codepoint E382A2\ngot codepoint E383A1\ngot codepoint E383AA\ngot codepoint E382AB",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#other-parts-of-zig",
    "href": "Chapters/01-zig-weird.html#other-parts-of-zig",
    "title": "1  Introducing Zig",
    "section": "1.12 Other parts of Zig",
    "text": "1.12 Other parts of Zig\nWe already learned a lot about Zig’s syntax, and also, some pretty technical details about it. Just as quick recap:\n\nWe talked about how to write functions at Section 1.2.2 and Section 1.2.3.\nHow to create new objects/identifiers in Zig at Section 1.2.2 and specially at Section 1.5.\nBasic control flow syntax at Section 1.8.\nHow strings work in Zig at Section 1.11.\nHow to use arrays and slices at Section 1.7.\nHow to import functionality from other Zig modules at Section 1.2.2.\nHow Object-Oriented programming can be done in Zig through Struct declarations at Section 1.9.\n\nBut, for now, this amount of knowledge is enough for us to continue with this book. Later, over the next chapters we will still talk more about other parts of Zig’s syntax that are also equally important as the other parts. Such as:\n\nEnums;\nPointers;\nError handling with try and catch;\nUnit tests;\nVectors;\nBuild System;\n\n\n\n\n\nSobeston. 2024. “Zig Guide.” https://zig.guide/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#footnotes",
    "href": "Chapters/01-zig-weird.html#footnotes",
    "title": "1  Introducing Zig",
    "section": "",
    "text": "https://ziglang.org/learn/overview/#zig-build-system.↩︎\nhttps://github.com/ziglang/zig/tree/master/lib/std↩︎\nhttps://adventofcode.com/↩︎\nhttps://ziglang.org/documentation/master/#Primitive-Types.↩︎\nhttps://www.gnu.org/software/libiconv/↩︎\nhttps://cplusplus.com/reference/cstdio/printf/↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html",
    "href": "Chapters/01-memory.html",
    "title": "2  Memory and Allocators in Zig",
    "section": "",
    "text": "2.1 Memory spaces\nEvery object that you create in your Zig source code needs to be stored somewhere, in your computer’s memory. Depending on where and how you define your object, Zig will use a different “memory space”, or a different type of memory to store this object.\nEach type of memory normally serves for different purposes. In Zig, there are 3 types of memory (or 3 different memory spaces) that we care about. They are:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#memory-spaces",
    "href": "Chapters/01-memory.html#memory-spaces",
    "title": "2  Memory and Allocators in Zig",
    "section": "",
    "text": "Global data register (or the “global data section”);\nStack;\nHeap;\n\n\n2.1.1 Compile-time known versus runtime known\nOne strategy that Zig uses to decide where it will store each object that you declare, is by looking at the value of this particular object. More specifically, by investigating if this value is known at “compile-time” or at “runtime”.\nWhen you write a program in Zig, the values of some of the objects that you write in your program are known at compile time. Meaning that, when you compile your Zig source code, during the compilation process, the zig compiler can figure it out what is the exact value of a particular object that exists in your source code. Knowing the length (or the size) of each object is also important. So the length (or the size) of each object that you write in your program is, in some cases, known at compile time.\nThe zig compiler cares more about knowing the length (or the size) of a particular object , than to know it’s actual value. But, if the zig compiler knows the value of the object, then, it automatically knows the size of this object. Because it can simply calculate the size of the object by looking at the size of the value.\nTherefore, the priority for the zig compiler is to discover the size of each object in your source code. If the value of the object in question is known at compile-time, then, the zig compiler automatically knows the size/length of this object. But if the value of this object is not known at compile-time, then, the size of this object is only known at compile-time if, and only if, the type of this object have a known fixed size.\nIn order to a type have a known fixed size, this type must have data members whose size is fixed. If this type includes, for example, a variable sized array in it, then, this type do not have a known fixed size. Because this array can have any size at runtime (i.e. it can be an array of 2 elements, or 50 elements, or 1 thousand elements, etc.).\nFor example, a string object, which internally is an array of constant u8 values ([]const u8) have a variable size. It can be a string object with 100 or 500 characters in it. If we do not know at compile-time, which exact string will be stored inside this string object, then, we cannot calculate the size of this string object at compile-time. So, any type, or any struct declaration that you make, that includes a string data member that do not have an explicit fixed size, makes this type, or this new struct that you are declaring, a type that do not have a known fixed size at compile-time.\nIn contrast, if the type or this struct that you are declaring, includes a data member that is an array, but this array have a known fixed size, like [60]u8 (which declares an array of 60 u8 values), then, this type, or, this struct that you are declaring, becomes a type with a known fixed size at compile-time. And because of that, in this case, the zig compiler do not need to known at compile-time the exact value of any object of this type. Since the compiler can find the necessary size to store this object by looking at the size of it’s type.\nLet’s look at an example. In the source code below, we have two constant objects (name and array) declared. Because the values of these particular objects are written down, in the source code itself (\"Pedro\" and the number sequence from 1 to 4), the zig compiler can easily discover the values of these constant objects (name and array) during the compilation process. This is what “known at compile time” means. It refers to any object that you have in your Zig source code whose value can be identified at compile time.\n\nconst name = \"Pedro\";\nconst array = [_]u8{1, 2, 3, 4};\n_ = name; _ = array;\n\nfn input_length(input: []const u8) usize {\n    const n = input.len;\n    return n;\n}\n\nThe other side of the spectrum are objects whose values are not known at compile time. Function arguments are a classic example of this. Because the value of each function argument depends on the value that you assign to this particular argument, when you call the function.\nFor example, the function input_length() contains an argument named input, which is an array of constant u8 integers ([]const u8). Is impossible to know at compile time the value of this particular argument. And it also is impossible to know the size/length of this particular argument. Because it is an array that do not have a fixed size specified explicitly in the argument type annotation.\nSo, we know that this input argument will be an array of u8 integers. But we do not know at compile-time, it’s value, and neither his size. This information is known only at runtime, which is the period of time when you program is executed. As a consequence, the value of the expression input.len is also known only at runtime. This is an intrinsic characteristic of any function. Just remember that the value of function arguments is usually not “compile-time known”.\nHowever, as I mentioned earlier, what really matters to the compiler is to know the size of the object at compile-time, and not necessarily it’s value. So, although we don’t know the value of the object n, which is the result of the expression input.len, at compile-time, we do know it’s size. Because the expression input.len always return a value of type usize, and the type usize have a known fixed size.\n\n\n2.1.2 Global data register\nThe global data register is a specific section of the executable of your Zig program, that is responsible for storing any value that is known at compile time.\nEvery constant object whose value is known at compile time that you declare in your source code, is stored in the global data register. Also, every literal value that you write in your source code, such as the string \"this is a string\", or the integer 10, or a boolean value such as true, is also stored in the global data register.\nHonestly, you don’t need to care much about this memory space. Because you can’t control it, you can’t deliberately access it or use it for your own purposes. Also, this memory space does not affect the logic of your program. It simply exists in your program.\n\n\n2.1.3 Stack vs Heap\nIf you are familiar with system’s programming, or just low-level programming in general, you probably have heard of the “duel” between Stack vs Heap. These are two different types of memory, or different memory spaces, which are both available in Zig.\nThese two types of memory don’t actually duel with each other. This is a commom mistake that beginners have, when seeing “x vs y” styles of tabloid headlines. These two types of memory are actually complementary to each other. So, in almost every Zig program that you ever write, you will likely use a combination of both. I will describe each memory space in detail over the next sections. But for now, I just want to stablish the main difference between these two types of memory.\nIn essence, the stack memory is normally used to store values whose length is fixed and known at compile time. In contrast, the heap memory is a dynamic type of memory space, meaning that, it is used to store values whose length might grow during the execution (runtime) of your program (Chen and Guo 2022).\nLengths that grow during runtime are intrinsically associated with “runtime known” type of values. In other words, if you have an object whose length might grow during runtime, then, the length of this object becomes not known at compile time. If the length is not known at compile-time, the value of this object also becomes not known at compile-time. These types of objects should be stored in the heap memory space, which is a dynamic memory space, which can grow or shrink to fit the size of your objects.\n\n\n2.1.4 Stack\nThe stack is a type of memory that uses the power of the stack data structure, hence the name. A “stack” is a type of data structure that uses a “last in, first out” (LIFO) mechanism to store the values you give it to. I imagine you are familiar with this data structure. But, if you are not, the Wikipedia page1 , or, the Geeks For Geeks page2 are both excellent and easy resources to fully understand how this data structure works.\nSo, the stack memory space is a type of memory that stores values using a stack data structure. It adds and removes values from the memory by following a “last in, first out” (LIFO) principle.\nEvery time you make a function call in Zig, an amount of space in the stack is reserved for this particular function call (Chen and Guo 2022; Zig Software Foundation 2024). The value of each function argument given to the function in this function call is stored in this stack space. Also, every local object that you declare inside the function scope is usually stored in this same stack space.\nLooking at the example below, the object result is a local object declared inside the scope of the add() function. Because of that, this object is stored inside the stack space reserved for the add() function. The r object (which is declared outside of the add() function scope) is also stored in the stack. But since it is declared in the “outer” scope, this object is stored in the stack space that belongs to this outer scope.\n\nconst r = add(5, 27);\n_ = r;\n\nfn add(x: u8, y: u8) u8 {\n    const result = x + y;\n    return result;\n}\n\nSo, any object that you declare inside the scope of a function is always stored inside the space that was reserved for that particular function in the stack memory. This also counts for any object declared inside the scope of your main() function for example. As you would expect, in this case, they are stored inside the stack space reserved for the main() function.\nOne very important detail about the stack memory is that it frees itself automatically. This is very important, remember that. When objects are stored in the stack memory, you don’t have the work (or the responsibility) of freeing/destroying these objects. Because they will be automatically destroyed once the stack space is freed at the end of the function scope.\nSo, once the function call returns (or ends, if you prefer to call it this way) the space that was reserved in the stack is destroyed, and all of the objects that were in that space goes away with it. This mechanism exists because this space, and the objects within it, are not necessary anymore, since the function “finished it’s business”. Using the add() function that we exposed above as an example, it means that the object result is automatically destroyed once the function returns.\n\n\n\n\n\n\nImportant\n\n\n\nLocal objects that are stored in the stack space of a function are automatically freed/destroyed at the end of the function scope.\n\n\nThis same logic applies to any other special structure in Zig that have it’s own scope by surrounding it with curly braces ({}). For loops, while loops, if else statements, etc. For example, if you declare any local object in the scope of a for loop, this local object is accessible only within the scope of this particular for loop. Because once the scope of this for loop ends, the space in the stack reserved for this for loop is freed. The example below demonstrates this idea.\n\n// This does not compile succesfully!\nconst a = [_]u8{0, 1, 2, 3, 4};\nfor (0..a.len) |i| {\n    const index = i;\n    _ = index;\n}\n// Trying to use an object that was\n// declared in the for loop scope,\n// and that does not exist anymore.\nstd.debug.print(\"{d}\\n\", index);\n\nOne important consequence of this mechanism is that, once the function returns, you can no longer access any memory address that was inside the space in the stack reserved for this particular function. Because this space was destroyed. This means that, if this local object is stored in the stack, you cannot make a function that returns a pointer to this object.\nThink about that for a second. If all local objects in the stack are destroyed at the end of the function scope, why would you even consider returning a pointer to one of these objects? This pointer is at best, invalid, or, more likely, “undefined”.\nConclusion, is totally fine to write a function that returns the local object itself as result, because then, you return the value of that object as the result. But, if this local object is stored in the stack, you should never write a function that returns a pointer to this local object. Because the memory address pointed by the pointer no longer exists.\nSo, using again the add() function as an example, if you rewrite this function so that it returns a pointer to the local object result, the zig compiler will actually compile you program, with no warnings or erros. At first glance, it looks that this is good code that works as expected. But this is a lie!\nIf you try to take a look at the value inside of the r object, or, if you try to use this r object in another expression or function call, then, you would have undefined behaviour, and major bugs in your program (Zig Software Foundation 2024, see “Lifetime and Ownership”3 and “Undefined Behaviour”4 sections).\n\n// This code compiles succesfully. But it has\n// undefined behaviour. Never do this!!!\n\n// The `r` object is undefined!\nconst r = add(5, 27);\n_ = r;\n\nfn add(x: u8, y: u8) *const u8 {\n    const result = x + y;\n    return &result;\n}\n\nThis “invalid pointer to stack variable” problem is very known across many programming language communities. If you try to do the same thing, for example, in a C or C++ program (i.e. returning an address to a local object stored in the stack), you would also get undefined behaviour in the program.\n\n\n\n\n\n\nImportant\n\n\n\nIf a local object in your function is stored in the stack, you should never return a pointer to this local object from the function. Because this pointer will always become undefined after the function returns, since the stack space of the function is destroyed at the end of it’s scope.\n\n\nBut what if you really need to use this local object in some way after your function returns? How can you do this? The answer is: “in the same you would do if this was a C or C++ program. By returning an address to an object stored in the heap”. The heap memory have a much more flexible lifecycle, and allows you to get a valid pointer to a local object of a function that already returned from it’s scope.\n\n\n2.1.5 Heap\nOne important limitation of the stack, is that, only objects whose length/size is known at compile-time can be stored in it. In contrast, the heap is a much more dynamic (and flexible) type of memory. It is the perfect type of memory to use on objects whose size/length might grow during the execution of your program.\nVirtually any application that behaves as a server is a classic use case of the heap. A HTTP server, a SSH server, a DNS server, a LSP server, … any type of server. In summary, a server is a type of application that runs for long periods of time, and that serves (or “deals with”) any incoming request that reaches this particular server.\nThe heap is a good choice for this type of system, mainly because the server does not know upfront how many requests it will receive from users, while it is active. It could be one single request, or, 5 thousand requests, or, it could also be zero requests. The server needs to have the ability to allocate and manage it’s memory according to how many requests it receives.\nAnother key difference between the stack and the heap, is that the heap is a type of memory that you, the programmer, have complete control over. This makes the heap a more flexible type of memory, but it also makes it harder to work with it. Because you, the programmer, is responsible for managing everything related to it. Including where the memory is allocated, how much memory is allocated, and where this memory is freed.\n\nUnlike stack memory, heap memory is allocated explicitly by programmers and it won’t be deallocated until it is explicitly freed (Chen and Guo 2022).\n\nTo store an object in the heap, you, the programmer, needs to explicitly tells Zig to do so, by using an allocator to allocate some space in the heap. At Section 2.2, I will present how you can use allocators to allocate memory in Zig.\n\n\n\n\n\n\nImportant\n\n\n\nEvery memory you allocate in the heap needs to be explicitly freed by you, the programmer.\n\n\nThe majority of allocators in Zig do allocate memory on the heap. But some exceptions to this rule are ArenaAllocator() and FixedBufferAllocator(). The ArenaAllocator() is a special type of allocator that works in conjunction with a second type of allocator. On the other side, the FixedBufferAllocator() is an allocator that works based on buffer objects created on the stack. This means that the FixedBufferAllocator() makes allocations only on the stack.\n\n\n2.1.6 Summary\nAfter discussing all of these boring details, we can quickly recap what we learned. In summary, the Zig compiler will use the following rules to decide where each object you declare is stored:\n\nevery literal value (such as \"this is string\", 10, or true) is stored in the global data section.\nevery constant object (const) whose value is known at compile-time is also stored in the global data section.\nevery object (constant or not) whose length/size is known at compile time is stored in the stack space for the current scope.\nif an object is created with the method alloc() or create() of an allocator object, this object is stored in the memory space used by this particular allocator object. Most of allocators available in Zig use the heap memory, so, this object is likely stored in the heap (FixedBufferAllocator() is an exception to that).\nthe heap can only be accessed through allocators. If your object was not created through the alloc() or create() methods of an allocator object, then, he is most certainly not an object stored in the heap.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#sec-allocators",
    "href": "Chapters/01-memory.html#sec-allocators",
    "title": "2  Memory and Allocators in Zig",
    "section": "2.2 Allocators",
    "text": "2.2 Allocators\nOne key aspect about Zig, is that there are “no hidden-memory allocations” in Zig. What that really means, is that “no allocations happen behind your back in the standard library” (Sobeston 2024).\nThis is a known problem, specially in C++. Because in C++, there are some operators that do allocate memory behind the scene, and there is no way for you to known that, until you actually read the source code of these operators, and find the memory allocation calls. Many programmers find this behaviour annoying and hard to keep track of.\nBut, in Zig, if a function, an operator, or anything from the standard library needs to allocate some memory during it’s execution, then, this function/operator needs to receive (as input) an allocator provided by the user, to actually be able to allocate the memory it needs.\nThis creates a clear distinction between functions that “do not” from those that “actually do” allocate memory. Just look at the arguments of this function. If a function, or operator, have an allocator object as one of it’s inputs/arguments, then, you know for sure that this function/operator will allocate some memory during it’s execution.\nAn example is the allocPrint() function from the Zig standard library. With this function, you can write a new string using format specifiers. So, this function is, for example, very similar to the function sprintf() in C. In order to write such new string, the allocPrint() function needs to allocate some memory to store the output string.\nThat is why, the first argument of this function is an allocator object that you, the user/programmer, gives as input to the function. In the example below, I am using the GeneralPurposeAllocator() as my allocator object. But I could easily use any other type of allocator object from the Zig standard library.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nconst name = \"Pedro\";\nconst output = try std.fmt.allocPrint(\n    allocator,\n    \"Hello {s}!!!\",\n    .{name}\n);\ntry stdout.print(\"{s}\\n\", .{output});\n\nHello Pedro!!!\n\n\nYou get a lot of control over where and how much memory this function can allocate. Because it is you, the user/programmer, that provides the allocator for the function to use. This makes “total control” over memory management easier to achieve in Zig.\n\n2.2.1 What are allocators?\nAllocators in Zig are objects that you can use to allocate memory for your program. They are similar to the memory allocating functions in C, like malloc() and calloc(). So, if you need to use more memory than you initially have, during the execution of your program, you can simply ask for more memory using an allocator.\nZig offers different types of allocators, and they are usually available through the std.heap module of the standard library. So, just import the Zig standard library into your Zig module (with @import(\"std\")), and you can start using these allocators in your code.\nFurthermore, every allocator object is built on top of the Allocator interface in Zig. This means that, every allocator object you find in Zig must have the methods alloc(), create(), free() and destroy(). So, you can change the type of allocator you are using, but you don’t need to change the function calls to the methods that do the memory allocation (and the free memory operations) for your program.\n\n\n2.2.2 Why you need an allocator?\nAs we described at Section 2.1.4, everytime you make a function call in Zig, a space in the stack is reserved for this function call. But the stack have a key limitation which is: every object stored in the stack have a known fixed length.\nBut in reality, there are two very commom instances where this “fixed length limitation” of the stack is a deal braker:\n\nthe objects that you create inside your function might grow in size during the execution of the function.\nsometimes, it is impossible to know upfront how many inputs you will receive, or how big this input will be.\n\nAlso, there is another instance where you might want to use an allocator, which is when you want to write a function that returns a pointer to a local object. As I described at Section 2.1.4, you cannot do that if this local object is stored in the stack. However, if this object is stored in the heap, then, you can return a pointer to this object at the end of the function. Because you (the programmer) control the lyfetime of any heap memory that you allocate. You decide when this memory get’s destroyed/freed.\nThese are commom situations where the stack is not good for. That is why you need a different memory management strategy to store these objects inside your function. You need to use a memory type that can grow together with your objects, or that you can control the lyfetime of this memory. The heap fit this description.\nAllocating memory on the heap is commonly known as dynamic memory management. As the objects you create grow in size during the execution of your program, you grow the amount of memory you have by allocating more memory in the heap to store these objects. And you that in Zig, by using an allocator object.\n\n\n2.2.3 The different types of allocators\nAt the moment of the writing of this book, in Zig, we have 6 different allocators available in the standard library:\n\nGeneralPurposeAllocator().\npage_allocator().\nFixedBufferAllocator() and ThreadSafeFixedBufferAllocator().\nArenaAllocator().\nc_allocator() (requires you to link to libc).\n\nEach allocator have it’s own perks and limitations. All allocators, except FixedBufferAllocator() and ArenaAllocator(), are allocators that use the heap memory. So any memory that you allocate with these allocators, will be placed in the heap.\n\n\n2.2.4 General-purpose allocators\nThe GeneralPurposeAllocator(), as the name suggests, is a “general purpose” allocator. You can use it for every type of task. In the example below, I’m allocating enough space to store a single integer in the object some_number.\n\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const some_number = try allocator.create(u32);\n    defer allocator.destroy(some_number);\n\n    some_number.* = @as(u32, 45);\n}\n\nWhile useful, you might want to use the c_allocator(), which is a alias to the C standard allocator malloc(). So, yes, you can use malloc() in Zig if you want to. Just use the c_allocator() from the Zig standard library. However, if you do use c_allocator(), you must link to Libc when compiling your source code with the zig compiler, by including the flag -lc in your compilation process. If you do not link your source code to Libc, Zig will not be able to find the malloc() implementation in your system.\n\n\n2.2.5 Page allocator\nThe page_allocator() is an allocator that allocates full pages of memory in the heap. In other words, every time you allocate memory with page_allocator(), a full page of memory in the heap is allocated, instead of just a small piece of it.\nThe size of this page depends on the system you are using. Most systems use a page size of 4KB in the heap, so, that is the amount of memory that is normally allocated in each call by page_allocator(). That is why, page_allocator() is considered a fast, but also “wasteful” allocator in Zig. Because it allocates a big amount of memory in each call, and you most likely will not need that much memory in your program.\n\n\n2.2.6 Buffer allocators\nThe FixedBufferAllocator() and ThreadSafeFixedBufferAllocator() are allocator objects that work with a fixed sized buffer that is stored in the stack. So these two allocators only allocates memory in the stack. This also means that, in order to use these allocators, you must first create a buffer object, and then, give this buffer as an input to these allocators.\nIn the example below, I am creating a buffer object that is 10 elements long. Notice that I give this buffer object to the FixedBufferAllocator() constructor. Now, because this buffer object is 10 elements long, this means that I am limited to this space. I cannot allocate more than 10 elements with this allocator object. If I try to allocate more than that, the alloc() method will return an OutOfMemory error value.\n\nvar buffer: [10]u8 = undefined;\nfor (0..buffer.len) |i| {\n    buffer[i] = 0; // Initialize to zero\n}\n\nvar fba = std.heap.FixedBufferAllocator.init(&buffer);\nconst allocator = fba.allocator();\nconst input = try allocator.alloc(u8, 5);\ndefer allocator.free(input);\n\n\n\n2.2.7 Arena allocator\nThe ArenaAllocator() is an allocator object that takes a child allocator as input. The idea behind the ArenaAllocator() in Zig is similar to the concept of “arenas” in the programming language Go5. It is an allocator object that allows you to allocate memory as many times you want, but free all memory only once. In other words, if you have, for example, called 5 times the method alloc() of an ArenaAllocator() object, you can free all the memory you allocated over these 5 calls at once, by simply calling the deinit() method of the same ArenaAllocator() object.\nIf you give, for example, a GeneralPurposeAllocator() object as input to the ArenaAllocator() constructor, like in the example below, then, the allocations you perform with alloc() will actually be made with the underlying object GeneralPurposeAllocator() that was passed. So, with an arena allocator, any new memory you ask for is allocated by the child allocator. The only thing that an arena allocator really do is helping you to free all the memory you allocated multiple times with just a single command. In the example below, I called alloc() 3 times. So, if I did not used an arena allocator, then, I would need to call free() 3 times to free all the allocated memory.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nvar aa = std.heap.ArenaAllocator.init(gpa.allocator());\ndefer aa.deinit();\nconst allocator = aa.allocator();\n\nconst in1 = allocator.alloc(u8, 5);\nconst in2 = allocator.alloc(u8, 10);\nconst in3 = allocator.alloc(u8, 15);\n_ = in1; _ = in2; _ = in3;\n\n\n\n2.2.8 The alloc() and free() methods\nIn the code example below, we are accessing the stdin, which is the standard input channel, to receive an input from the user. We read the input given by the user with the readUntilDelimiterOrEof() method.\nNow, after reading the input of the user, we need to store this input somewhere in our program. That is why I use an allocator in this example. I use it to allocate some amount of memory to store this input given by the user. More specifically, the method alloc() of the allocator object is used to allocate an array capable of storing 50 u8 values.\nNotice that this alloc() method receives two inputs. The first one, is a type. This defines what type of values the allocated array will store. In the example below, we are allocating an array of unsigned 8-bit integers (u8). But you can create an array to store any type of value you want. Next, on the second argument, we define the size of the allocated array, by specifying how much elements this array will contain. In the case below, we are allocating an array of 50 elements.\nAt Section 1.11 we described that strings in Zig are simply arrays of characters. Each character is represented by an u8 value. So, this means that the array that was allocated in the object input is capable of storing a string that is 50-characters long.\nSo, in essence, the expression var input: [50]u8 = undefined would create an array for 50 u8 values in the stack of the current scope. But, you can allocate the same array in the heap by using the expression var input = try allocator.alloc(u8, 50).\n\nconst std = @import(\"std\");\nconst stdin = std.io.getStdIn();\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var input = try allocator.alloc(u8, 50);\n    defer allocator.free(input);\n    for (0..input.len) |i| {\n        input[i] = 0; // initialize all fields to zero.\n    }\n    // read user input\n    const input_reader = stdin.reader();\n    _ = try input_reader.readUntilDelimiterOrEof(\n        input,\n        '\\n'\n    );\n    std.debug.print(\"{s}\\n\", .{input});\n}\n\nAlso, notice that in this example, we use the keyword defer to run a small piece of code at the end of the current scope, which is the expression allocator.free(input). When you execute this expression, the allocator will free the memory that it allocated for the input object.\nWe have talked about this at Section 2.1.5. You should always explicitly free any memory that you allocate using an allocator! You do that by using the free() method of the same allocator object you used to allocate this memory. The defer keyword is used in this example only to help us execute this free operation at the end of the current scope.\n\n\n2.2.9 The create() and destroy() methods\nWith the alloc() and free() methods, you can allocate memory to store multiple elements at once. In other words, with these methods, we always allocate an array to store multiple elements at once. But what if you need enough space to store just a single item? Should you allocate an array of a single element through alloc()?\nThe answer is no! In this case, you should use the create() method of the allocator object. Every allocator object offers the create() and destroy() methods, which are used to allocate and free memory for a single item, respectively.\nSo, in essence, if you want to allocate memory to store an array of elements, you should use alloc() and free(). But if you need to store just a single item, then, the create() and destroy() methods are ideal for you.\nIn the example below, I’m defining a struct to represent an user of some sort. It could be an user for a game, or a software to manage resources, it doesn’t mater. Notice that I use the create() method this time, to store a single User object in the program. Also notice that I use the destroy() method to free the memory used by this object at the end of the scope.\n\nconst std = @import(\"std\");\nconst User = struct {\n    id: usize,\n    name: []const u8,\n\n    pub fn init(id: usize, name: []const u8) User {\n        return .{ .id = id, .name = name };\n    }\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const user = try allocator.create(User);\n    defer allocator.destroy(user);\n\n    user.* = User.init(0, \"Pedro\");\n}\n\n\n\n\n\nChen, Jenny, and Ruohao Guo. 2022. “Stack and Heap Memory.” Introduction to Data Structures and Algorithms with C++. https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/.\n\n\nSobeston. 2024. “Zig Guide.” https://zig.guide/.\n\n\nZig Software Foundation. 2024. “Language Reference.” Zig Software Foundation. https://ziglang.org/documentation/master/.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#footnotes",
    "href": "Chapters/01-memory.html#footnotes",
    "title": "2  Memory and Allocators in Zig",
    "section": "",
    "text": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)↩︎\nhttps://www.geeksforgeeks.org/stack-data-structure/↩︎\nhttps://ziglang.org/documentation/master/#Lifetime-and-Ownership↩︎\nhttps://ziglang.org/documentation/master/#Undefined-Behavior↩︎\nhttps://go.dev/src/arena/arena.go↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html",
    "href": "Chapters/01-base64.html",
    "title": "3  Building a base64 encoder/decoder",
    "section": "",
    "text": "3.1 How the base64 algorithm work?\nNow, how exactly the algorithm behind the base64 encoding works? Let’s discuss that. First, I will explain the base64 scale, which is the scale of 64 characters that represents the base64 encoding system.\nAfter that, I explain the algorithm behind a base64 encoder, which is the part of the algorithm that is responsible for encoding messages into the base64 encoding system. Then, after that, I explain the algorithm behind a base64 decoder, which is the part of the algorithm that is responsible for translating base64 messages back into their original meaning.\nIf you are unsure about the differences between an “encoder” and a “decoder”, take a look at Section 3.2.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#how-the-base64-algorithm-work",
    "href": "Chapters/01-base64.html#how-the-base64-algorithm-work",
    "title": "3  Building a base64 encoder/decoder",
    "section": "",
    "text": "3.1.1 The base64 scale\nIn essence, the base64 encoding system is based on a scale that goes from 0 to 64 (hence the name). Each index in this scale is represented by a character (it is a scale of 64 characters). So, in order to convert some binary data, to the base64 encoding, we need to convert each binary number to the corresponding character in this “scale of 64 characters”.\nThe base64 scale starts with all ASCII uppercase letters (A to Z) which represents the first 25 indexes in this scale (0 to 25). After that, we have all ASCII lowercase letters (a to z), which represents the range 26 to 51 in the scale. After that, we have the one digit numbers (0 to 9), which represents the indexes from 52 to 61 in the scale. Finally, the last two indexes in the scale (62 and 63) are represented by the characters + and /, respectively.\nThese are the 64 characters that compose the base64 scale. The equal sign character (=) is not part of the scale itself, but it is a special character in the base64 encoding system. This character is used solely as a suffix, to mark the end of the character sequence, or, to mark the end of meaningful characters in the sequence.\nThe bulletpoints below summarises the base64 scale:\n\nrange 0 to 25 is represented by: ASCII uppercase letters -&gt; [A-Z];\nrange 26 to 51 is represented by: ASCII lowercase letters -&gt; [a-z];\nrange 52 to 61 is represented by: one digit numbers -&gt; [0-9];\nindex 62 and 63 are represented by the characters + and /, respectively;\nthe character = represents the end of meaningful characters in the sequence;\n\nEverytime that the base64 algorithm needs to fill some gap (which always occur at the end of the input string) with a group of 6 bits filled with only zeros (000000), this group is automatically mapped to the character =. Because this group of 6 bits is meaningless, they represent nothing, they are just filling the gap. As a result, the base64 algorithm maps this meaningless group to the character =, which represents the end of meaningful characters in the sequence. This characteristic is explained in more details at Section 3.1.3.\n\n\n3.1.2 Creating the scale as a lookup table\nThe best way to represent this scale in code, is to represent it as a lookup table. Lookup tables are a classic strategy in computer science to speed calculations. The basic idea is to replace a runtime calculation (which can take a long time to be done) by a basic array indexing operation.\nInstead of calculating the results everytime you need them, you calculate all possible results at once, and then, you store them in an array (which behaves lake a “table”). Then, every time that you need to use one of the characters in the base64 scale, instead of using many resources to calculate the exact character to be used, you simply retrieve this character from the array where you stored all the possible characters in the base64 scale. So we retrieve the character that we need directly from memory.\nWe can start building a Zig struct to store our base64 decoder/encoder logic. We start with the Base64 struct below. You can see that, for now, we only have an init() function, to create a new instance of a Base64 object, and, a _char_at() function, which is a “get chat at index …” type of function.\n\nconst Base64 = struct {\n    _table: *const [64]u8,\n\n    pub fn init() Base64 {\n        const upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        const lower = \"abcdefghijklmnopqrstuvwxyz\";\n        const numbers_symb = \"0123456789+/\";\n        return Base64{\n            ._table = upper ++ lower ++ numbers_symb,\n        };\n    }\n\n    pub fn _char_at(self: Base64, index: u8) u8 {\n        return self._table[index];\n    }\n};\n\nIn other words, the _char_at() function is responsible for getting the character in the lookup table (i.e. the _table variable) that corresponds to a particular index in the “base64 scale”. So, in the example below, we know that the character that corresponds to the index 28 in the “base64 scale” is the character “c”.\n\nconst base64 = Base64.init();\ntry stdout.print(\n    \"Character at 28 index: {c}\\n\",\n    .{base64._char_at(28)}\n);\n\nCharacter at 28 index: c\n\n\n3.1.3 A base64 encoder\nThe algorithm behind a base64 encoder usually works on a window of 3 bytes. Because each byte have 8 bits, so, 3 bytes forms a set of \\(8 \\times 3 = 24\\) bits. This is desirable for the base64 algorithm, because 24 bits is divisble by 6, which form a set of 4 groups of 6 bits each.\nSo the base64 algorithm work by converting 3 bytes at a time into 4 characters in the base64 scale. It keeps iterating through the input string, 3 bytes at a time, and converting them into the base64 scale, producing 4 characters per iteration. It keeps iterating, and producing these “new characters” until it hits the end of the input string.\nNow you may think, what if you have a particular string that have a number of bytes that is not divisible by 3? What happens? For example, if you have a string that contains only two characters/bytes, such as “Hi”. How the algorithm behaves in such situation? You find the answer at Figure 3.1. You can see at Figure 3.1 that the string “Hi”, when converted to base64, becomes the string “SGk=”:\n\n\n\n\n\n\nFigure 3.1: The logic behind a base64 encoder\n\n\n\nIn the example of the string “Hi” we have 2 bytes, or, 16 bits in total. So, we lack a full byte (8 bits) to complete the window of 24 bits that the base64 algorithm likes to work on. In essence, everytime that the algorithm does not meet this requirement, it simply add extra zeros until it fills the space that it needs.\nThat is why at Figure 3.1, on the third group after the 6-bit transformation, 2 extra zeros were added to fill the gap in this group, and also, the fourth group (which is the last 6-bit group) is entirely made by zeros that were added by the algorithm.\nSo every time that the base64 algorithm can’t produce a full group of 6 bits, it simply fills the gap in this group with zeros, until it get’s the 6 bits that it needs.\nIs worth mentioning that, everytime that the algorithm produces a group of 6 bits that is entirely composed by these extra zeros added by the algorithm, then, this group of 6 bits is automatically mapped to the character = (equal sign). However, notice that a group of 6-bit entirely made by extra zeros, is different than a group of 6-bit entirely made by zeros.\nIn other words, if the algorithm produces a 6-bit group made by zeros, without needing to include extra-zeros to fill any gap, then, this “group of zeros” is interpreted as is. In binary, the 6-bit group 000000 simply means zero. So, if we give the index zero to the function _char_at(), this zero index is mapped to the first character in the base64 scale, which is “A”.\nSo be aware of this important distinction. A group of “extra-zeros” that are “filling the gap” is different than a group of actual zeros that were calculated by the 6-bit transformation. As an example, if you give the string “0” as input to a base64 encoder, this string is translated into the base64 sequence “MA==”.\nThe character “0” is, in binary, the sequence 001100001. So, with the 6-bit transformation exposed at Figure 3.1, this single character would produce these two 6-bit groups: 001100, 000000. The other two 6-bit groups are entirely made by extra-zeros, and that is why the last two characters in the output sequence (MA==) are ==.\n\n\n3.1.4 A base64 decoder\nThe algorithm behind a base64 decoder is essentially the inverse process of a base64 encoder. A base64 decoder needs to be able to translate base64 messages back into their original meaning, i.e. into the original sequence of binary data.\nA base64 decoder usually works on a window of 4 bytes. Because it wants to convert these 4 bytes back into the original sequence of 3 bytes, that was converted into 4 groups of 6 bits by the base64 encoder. Remember, in a base64 decoder we are essentially reverting the process made by the base64 encoder.\nEach byte in the input string (the base64 encoded string) normally contributes to re-create two different bytes in the output (the original binary data). In other words, each byte that comes out of a base64 decoder is created by transforming merging two different bytes in the input together. You can see this fact at Figure 3.2:\n\n\n\n\n\n\nFigure 3.2: The logic behind a base64 decoder\n\n\n\nThe exact transformations, or, the exact steps applied to each byte from the input to transform them into the bytes in the output, are a bit tricky to visualize in a figure like this. Because of that, I summarized these transformations as “Some bit shifting and additions …”. These transformations will be described in depth later.\nBesides that, if you look again at Figure 3.2, you will notice that the character = was completly ignored in the algorithm. Remember, this is just a special character that marks the end of meaninful characters in the base64 sequence. So, every = character in a base64 encoded sequence should be ignored.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-encode-vs-decode",
    "href": "Chapters/01-base64.html#sec-encode-vs-decode",
    "title": "3  Building a base64 encoder/decoder",
    "section": "3.2 Difference between encode and decode",
    "text": "3.2 Difference between encode and decode\nIf you don’t have any previous experience with base64, you might be confused about what is the differente between “encode” and “decode”. Essentially, the terms “encode” and “decode” here have the exact same meaning as they have in the field of encryption (i.e. they mean the same thing as “encode” and “decode” in hashing algorithms, like the MD5 algorithm).\nSo, “encode” means that we want to encode, or, in other words, we want to translate some message into the base64 encoding system. We want to produce the sequence of base64 characters that represent this original message in the base64 encoding system.\nIn contrast, “decode” represents the inverse process. We want to decode, or, in other words, translate a base64 message back to it’s original content. So, in this process we get a sequence of base64 characters as input, and produce as output, the binary data that is represented by this sequence of base64 characters.\nSo, any base64 library is normally composed by these two parts: 1) the encoder, which is a function that encodes (i.e. it converts) any sequence of binary data into a sequence of base64 characters; 2) the decoder, which is a function that converts a sequence of base64 characters back into the original sequence of binary data.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-base64-length-out",
    "href": "Chapters/01-base64.html#sec-base64-length-out",
    "title": "3  Building a base64 encoder/decoder",
    "section": "3.3 Calculating the size of the output",
    "text": "3.3 Calculating the size of the output\nOne task that we need to do is to calculate how much space we need to reserve for the output, both of the encoder and decoder. This is simple math, and can be done easily in Zig because every array have it’s length (it’s number of bytes) easily accesible by consulting the .len property of the array.\nFor the encoder, the logic is the following: for each 3 bytes that we find in the input, 4 new bytes are created in the output. So, we take the number of bytes in the input, divide it by 3, use a ceiling function, then, we multiply the result by 4. That way, we get the total number of bytes that will be produced by the encoder in it’s output.\nThe _calc_encode_length() function below encapsulates this logic. Notice that we convert the .len property of the array, which is always a integer (more precisely, an usize value), into a floating point number of 64 bits (f64). We do this, because the ceiling function (@ceil()) works only with floating point numbers. So, we convert it so that the division with the number 3.0 results in a floating point number. Then, after the ceiling process, we can convert the result back into an integer value (with the @intFromFloat() function).\n\nfn _calc_encode_length(input: []const u8) u64 {\n    if (input.len &lt; 3) {\n        const n_output: u64 = 4;\n        return n_output;\n    }\n    const len_as_float: f64 = @floatFromInt(input.len);\n    const n_output: u64 = @intFromFloat(@ceil(len_as_float / 3.0) * 4.0);\n    return n_output;\n}\n\nIs important to notice that, when I am using the built-in functions from Zig to convert data types (@floatFromInt() and intFromFloat()), I’m always annotating explicitly the type of the variable that stores the result of these functions. I do that, because these functions need this information. @floatFromInt() needs to know which type of floating point number I want to use in it’s output. Is it f16? f32? f64? etc. The same goes to @intFromFloat().\nAlso, you might have notice that, if the input length is less than 3 bytes, then, the output length of the encoder will be always 4 bytes. This is because the algorithm will always fill the gap in the input with zeroes, until it fits the window of 24 bits that the algorithm likes to work on, as I described at Section 3.1.3. So the output of the algorithm will always be 4 bytes in this specific case.\nNow, for the decoder, we just need to apply the inverse logic: for each 4 bytes in the input, 3 bytes will be produced in the output of the decoder. I mean, this is roughly true, because we also need to take the = character into account, which is always ignored by the decoder, as we described at Section 3.1.4, and, at Figure 3.2. But we can ignore this fact for now, to make things simpler.\nSo, the function _calc_decode_length() summarizes this logic that we described. It is very similar to the function _calc_encode_length(), only the division part is twisted, and also, in the special case where we have less than 4 bytes in the input to work on.\n\nfn _calc_decode_length(input: []const u8) u64 {\n    if (input.len &lt; 4) {\n        const n_output: u64 = 3;\n        return n_output;\n    }\n    const len_as_float: f64 = @floatFromInt(input.len);\n    const n_output: u64 = @intFromFloat(@floor(len_as_float / 4.0) * 3.0);\n    return n_output;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-encoder-logic",
    "href": "Chapters/01-base64.html#sec-encoder-logic",
    "title": "3  Building a base64 encoder/decoder",
    "section": "3.4 Building the encoder logic",
    "text": "3.4 Building the encoder logic\nIn this section, we can start building the logic behind the encode() function, which will be responsible for encoding messages into the base64 encoding system.\nIf you are an anxious person, and you want to see now the full source code of the implementation for this base64 encoder/decoder, you can find it at the Examples folder in the official repository of this book2.\n\n3.4.1 The 6-bit transformation\nThe 6-bit transformation presented at Figure 3.1 is the core part of the base64 encoder algorithm. By understanding how this transformation is made in code, the rest of the algorithm becomes much simpler to comprehend.\nIn essence, this 6-bit transformation is made with the help of bitwise operators. Bitwise operators are essential to any type of low-level operation that is done at the bit-level. For the specific case of the base64 algorithm, the operators bif shift to the left (&lt;&lt;), bit shift to the right (&gt;&gt;), and the bitwise and (&) are used. They are the core solution for the 6-bit transformation.\nWe have 3 different scenarios that we need to account for in this transformation. First, is the perfect scenario, where we have the perfect window of 3 bytes to work on. Second, we have the scenario where we have a window of only two bytes to work with. And last, we have the scenario where we have a window of one single byte.\nIn each of these 3 scenarios, the 6-bit transformation works a bit different. To make the explanation easier, I will use the variable output to refer to the bytes in the output of the base64 encoder, and the variable input to refer to the bytes in the input of the encoder.\nSo, if you have the perfect window of 3 bytes, these are steps for the 6-bit transformation:\n\noutput[0] is produced by moving the bits from input[0] two positions to the right.\noutput[1] is produced by summing two components. First, take the last two bits from input[0], then, move them four positions to the left. Second, move the bits from input[1] four positions to the right. Sum these two components.\noutput[2] is produced by summing two components. First, take the last four bits from input[1], then, move them two positions to the left. Second, move the bits from input[2] six positions to the right.\noutput[3] is produced by taking the last six bits from input[2].\n\nThis is the perfect scenario, when we have a full window of 3 bytes to work on. Just to make things as clear as possible, the Figure 3.3 demonstrates visually how the step 2 mentioned above works. So this is the step necessary to produce the 2nd byte in the output of the encoder, by taking the 1st byte (dark purple) and the 2nd byte (orange) in the input. You can see that, at the end of the process, we get a new byte that contains the last 2 bits from the 1st byte in the input, and the first 4 bits from the 2nd byte in the input.\n\n\n\n\n\n\nFigure 3.3: How the 2nd byte in the output of the encoder is produced from the 1st byte (dark purple) and the 2nd byte (orange) of the input\n\n\n\nOn the other hand, we must be prepared for the possibilities where we do not have the perfect window of 3 bytes. If you have a window of 2 bytes, then, the steps 3 and 4, which produces the bytes output[2] and output[3], change a little bit, and they become:\n\noutput[2] is produced by taking the last 4 bits from input[1], then, move them two positions to the left.\noutput[3] is the character '='.\n\nFinally, if you have a window of a single byte, then, the steps 2 to 4, which produces the bytes output[1], output[2] and output[3] change, becoming:\n\noutput[1] is produced by taking the last two bits from input[0], then, move them four positions to the left.\noutput[2] and output[3] are the character =.\n\nIf these bulletpoints were a bit confusing for you, you may find the Table 3.1 more intuitive. This table unifies all this logic into a simple table. Notice that this table also provides the exact expression in Zig that creates the corresponding byte in the output.\n\n\n\nTable 3.1: How the 6-bit transformation translates into code in different window settings.\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nNumber of bytes in the window\nByte index in the output\nIn code\n\n\n\n\n3\n0\ninput[0] &gt;&gt; 2\n\n\n3\n1\n((input[0] & 0x03) &lt;&lt; 4) +\n(input[1] &gt;&gt; 4)\n\n\n3\n2\n((input[1] & 0x0f) &lt;&lt; 2) +\n(input[2] &gt;&gt; 6)\n\n\n3\n3\ninput[2] & 0x3f\n\n\n2\n0\ninput[0] &gt;&gt; 2\n\n\n2\n1\n((input[0] & 0x03) &lt;&lt; 4) +\n(input[1] &gt;&gt; 4)\n\n\n2\n2\n((input[1] & 0x0f) &lt;&lt; 2)\n\n\n2\n3\n'='\n\n\n1\n0\ninput[0] &gt;&gt; 2\n\n\n1\n1\n((input[0] & 0x03) &lt;&lt; 4)\n\n\n1\n2\n'='\n\n\n1\n3\n'='\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.4.2 Bit-shifting in Zig\nBit-shifting in Zig works similarly to bit-shifting in C. All bitwise operators that exists in C are available in Zig. Here, in the base64 encoder algorithm, they are essential to produce the result we want.\nFor those who are not familiar with these operators, they are operators that operates at the bit-level of your values. This means that these operators takes the bits that form the value you have, and change them in some way. This ultimately also changes the value itself, because the binary representation of this value changes.\nWe already saw at Figure 3.3 visually what is the effect produced by a bit-shift. But let’s use the first byte in the output of the base64 encoder as another example of what bit-shifting means. This is the easiest byte of the 4 bytes in the output to build. Because we only need to move the bits from the first byte in the input two positions to the right, with the bit shift to the right (&gt;&gt;) operator.\nIf we take the string “Hi” that we used at Figure 3.1 as an example, the first byte in this string is “H”, which is the sequence 01001000 in binary. If we move the bits of this byte, two places to the right, we get the sequence 00010010 as result. This binary sequence is the value 18 in decimal, and also, the value 0x12 in hexadecimal. Notice that the first 6 bits of the first byte in the input were moved to the end of the byte. With this operation, we get the first byte of the ouput, which corresponds to the index in the base64 scale for the first character in the base64 scale.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const input = \"Hi\";\n    var output = [4]u8{0,0,0,0};\n    output[0] = input[0] &gt;&gt; 2;\n    try stdout.print(\"{d}\\n\", .{output[0]});\n}\n\n18\n\n\nIf you recall Figure 3.1, the first byte present in the output should be equivalent to the 6-bit group 010010. Although being visually different, the sequences 010010 and 00010010 are semantically equal. They mean the same thing. They both represent the number 18 in decimal, and the value 0x12 in hexadecimal.\nSo, don’t take the “6-bit group” factor so seriously. We do not need necessarily to get a 6-bit sequence as result. As long as the meaning of the 8-bit sequence we get is the same of the 6-bit sequence, we are in the clear.\n\n\n3.4.3 Selecting specific bits with the & operator\nIf you comeback to Section 3.4.1, you will see that to produce the second and third bytes in the output, we need to select specific bits from the first and second bytes in the input string. But how can we do that? The answer relies on the bitwise and (&) operator.\nThe Figure 3.3 already showed you what effect this & operator produces in the bits of it’s operands. But let’s make a clear description of it.\nIn summary, the & operator performs a logical conjunction operation between the bits of it’s operands. In more details, the operator & compares each bit of the first operand to the corresponding bit of the second operand. If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0 (Microsoft 2021).\nSo, if we apply this operator to the binary sequences 1000100 and 00001101 the result of this operation is the binary sequence 00000100. Because only at the sixth position in both binary sequences we had a 1 value. So any position where we do not have both binary sequences setted to 1, we get a 0 bit in the resulting binary sequence.\nWe loose information about the original bit values from both sequences in this case. Because we no longer know if this 0 bit in the resulting binary sequence was produced by combining 0 with 0, or 1 with 0, etc.\nAs an example, suppose you have the binary sequence 10010111, which is the number 151 in decimal. How can we get a new binary sequence which contains only the third and fourth bits?\nWe just need to combine this sequence with the sequence 00110000 (is 0x30 in hexadecimal) using the & operator. Notice that only the third and fourth positions in this binary sequence is setted to 1. As a consequence, only the third and fourth values of both binary sequences are potentially preserved in the output. All the remaining positions are setted to zero in the output sequence, which is 00010000 (is the number 16 in decimal).\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const bits = 0b10010111;\n    try stdout.print(\"{d}\\n\", .{bits & 0b00110000});\n}\n\n16\n\n\n\n\n3.4.4 Allocating space for the output\nAs I described at Section 2.1.4, to store a variable in the stack, this variable needs to have a known and fixed length at compile-time. This is a problem for our a base64 encoder/decoder case. Because the size of the output (from both the encoder and decoder) depends directly on the size of the input.\nHaving this in mind, we cannot know at compile time which is the size of the output for both the encoder and decoder. So, if we can’t know the size of the output at compile time, this means that we cannot store in the stack, the output for both the encoder and decoder.\nConsequently, we need to store this output on the heap, and, as I commented at Section 2.1.5, we can only store variables in the heap by using allocator objects. So, one the arguments to both the encode() and decode() functions, needs to be an allocator object, because we know for sure that, at some point inside the body of these functions, we need to allocate space on the heap to store the output of these functions.\nThat is why, both the encode() and decode() functions that I present in this book, have an argument called allocator, which receives a allocator object as input, identified by the type std.mem.Allocator from the Zig standard library.\n\n\n3.4.5 Writing the encode() function\nNow that we have a basic understanding on how the bitwise operators work, and how exactly they help us to achieve the result we want to achieve. We can now encapsulate all the logic that we described at Figure 3.1 and Table 3.1 into a nice function that we can add to our Base64 struct definition, that we started at Section 3.1.2.\nYou can find the encode() function below. Notice that the first argument of this function, is the Base64 struct itself. Therefore, tis argument clearly signals that this function is a method from the Base64 struct.\nBecause the encode() function itself is fairly long, I intentionally ommitted the Base64 struct definition in this source code, just for brevity reasons. So, just remember that this function is a public function (or a public method) from the Base64 struct.\nFurthermore, this encode() function have two other arguments:\n\ninput is the input sequence of characters that you want to encode in base64;\nallocator is an allocator object to use in the necessary memory allocations.\n\nI described everything you need to know about allocator objects at Section 2.2. So, if you are not familiar with them, I highly recommend you to comeback to that section, and read it. By looking at the encode() function, you will see that we use this allocator object to allocate enough memory to store the output of encoding process.\nRemember from Section 2.1.4, that the stack can be used only to store variables that have a compile-time known fixed size. Unfortunately, this is not the case here. The size of the encode() output is tidly related to the size of the input from the user. So, the size of the output is only known at runtime. That is why we use an allocator object, to allocate memory on the heap (which allows objects whose size are runtime-known), and store the output there.\nThe main for loop in the function is responsible for iterating the entire input string. In every iteration, we use a count variable to count how many iterations we had at the moment. When count reaches 3, then, we try to encode the 3 characters (or bytes) that we accumulated until this point in the temporary buffer object (buf).\nAfter encoding these 3 characters and storing the result in the output variable, we reset the count variable to zero, and start to count again on the next iteration of the loop. If the loop hits the end of the string, and, the count variable is less than 3, then, it means that the temporary buffer contains the last 1 or 2 bytes from the input. That is why we have two if statements after the for loop. To deal which each possible case.\n\npub fn encode(self: Base64,\n              allocator: std.mem.Allocator,\n              input: []const u8) ![]u8 {\n\n    if (input.len == 0) {\n        return \"\";\n    }\n\n    const n_out = _calc_encode_length(input);\n    var out = try allocator.alloc(u8, n_out);\n    var buf = [3]u8{ 0, 0, 0 };\n    var count: u8 = 0;\n    var iout: u64 = 0;\n\n    for (input, 0..) |_, i| {\n        buf[count] = input[i];\n        count += 1;\n        if (count == 3) {\n            out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n            out[iout + 1] = self._char_at(\n                ((buf[0] & 0x03) &lt;&lt; 4) + (buf[1] &gt;&gt; 4)\n            );\n            out[iout + 2] = self._char_at(\n                ((buf[1] & 0x0f) &lt;&lt; 2) + (buf[2] &gt;&gt; 6)\n            );\n            out[iout + 3] = self._char_at(buf[2] & 0x3f);\n            iout += 4;\n            count = 0;\n        }\n    }\n\n    if (count == 1) {\n        out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n        out[iout + 1] = self._char_at(\n            (buf[0] & 0x03) &lt;&lt; 4\n        );\n        out[iout + 2] = '=';\n        out[iout + 3] = '=';\n    }\n\n    if (count == 2) {\n        out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n        out[iout + 1] = self._char_at(\n            ((buf[0] & 0x03) &lt;&lt; 4) + (buf[1] &gt;&gt; 4)\n        );\n        out[iout + 2] = self._char_at(\n            (buf[1] & 0x0f) &lt;&lt; 2\n        );\n        out[iout + 3] = '=';\n        iout += 4;\n    }\n\n    return out;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-decoder-logic",
    "href": "Chapters/01-base64.html#sec-decoder-logic",
    "title": "3  Building a base64 encoder/decoder",
    "section": "3.5 Building the decoder logic",
    "text": "3.5 Building the decoder logic\nNow, we can focus on writting the base64 decoder logic. Remember from Figure 3.2 that, a base64 decoder do the inverse process of an encoder. So, all we need to do, is to write a decode() function that performs the inverse process that I exposed at Section 3.4.\n\n3.5.1 Mapping base64 characters to their indexes\nOne thing that we need to do, in order to decode a base64-encoded message, is to calculate the index in the base64 scale of every base64 character that we encounter in the decoder input.\nIn other words, the decoder receives as input, a sequence of base64 characters. We need to translate this sequence of characters into a sequence of indexes. These indexes are the index of each character in the base64 scale. This way, we get the value/byte that was calculated in the 6-bit transformation step of the encoder process.\nThere are probably better ways to calculate this, specially using a “divide and conquer” type of strategy. But for now, I am satisfied with a simple and “brute force” type of strategy. The _char_index() function below contains this strategy.\nWe are essentially looping through the lookup table with the base64 scale, and comparing the character we got with each character in the base64 scale. If these characters match, then, we return the index of this character in the base64 scale as the result.\nNotice that, if the input character is '=', the function returns the index 64, which is “out of range” in the scale. But, as I described at Section 3.1.1, the character '=' does not belong to the base64 scale itself. It is a special and meaningless character in base64.\nAlso notice that this _char_index() function is a method from our Base64 struct, because of the self argument. Again, I ommitted the Base64 struct definition in this example, because of brevity reasons.\n\nfn _char_index(self: Base64, char: u8) u8 {\n    if (char == '=')\n        return 64;\n    var index: u8 = 0;\n    for (0..63) |i| {\n        if (self._char_at(i) == char) {\n            index = i;\n            break;\n        }\n    }\n\n    return index;\n}\n\n\n\n3.5.2 The 6-bit transformation\nOnce again, the core part of the algorithm is the 6-bit transformation. If we understand the necessary steps to perform this transformation, the rest of the algorithm becomes much easier.\nFirst of all, before we actually go to the 6-bit transformation, we need to make sure that we use _char_index() to convert the sequence of base64 characters into a sequence of indexes. So the snippet below will be important for the job to be done. The result of _char_index() will be stored in a temporary buffer, and this temporary buffer is what we are going to use in the 6-bit transformation, instead of the actual input object.\n\nfor (0..input.len) |i| {\n    buf[i] = self._char_index(input[i]);\n}\n\nNow, instead of producing 4 bytes (or 4 characters) as output per each window of 3 characters in the input, a base64 decoder produces 3 bytes (or 3 characters) as output per each window of 4 characters in the input. Once again, is the inverse process.\nSo, the steps to produce the 3 bytes in the output are:\n\noutput[0] is produced by summing two components. First, move the bits from buf[0] two positions to the left. Second, move the bits from buf[1] 4 positions to the right. Then, sum these two components.\noutput[1] is produced by summing two components. First, move the bits from buf[1] four positions to the left. Second, move the bits from buf[2] 2 positions to the right. Then, sum these two components.\noutput[2] is produced by summing two components. First, move the bits from buf[2] six positions to the left. Then, you sum the result with buf[3].\n\nBefore we continue, let’s try to visualize how these transformations make the original bytes that we had before the encoding process. First, think back at the 6-bit transformation performed by the encoder exposed at #sec-encoder-logic. The first byte in the output of the encoder is produced by moving the bits in the first byte of the input two positions to the right.\nSo, if for example the first byte in the input of the encoder was the sequence ABCDEFGH, then, the first byte in the output of the encoder would be 00ABCDEF (this sequence would be the first byte in the input of the decoder). Now, if the second byte in the input of the encoder was the sequence IJKLMNOP, then, the second byte in the encoder output would be 00GHIJKL (as we demonstrated at Figure 3.3).\nSo, if the sequences 00ABCDEF and 00GHIJKL sequences are the first byte and the second bytes, respectively, in the input of the decoder, the Figure 3.4 demonstrates visually how these two bytes are transformed into the first byte of the output of the decoder. Notice that the output byte is the sequence ABCDEFGH, which is the original byte from the input of the encoder.\n\n\n\n\n\n\nFigure 3.4: How the 1st byte in the decoder output is produced from the 1st byte (dark purple) and the 2nd byte (orange) of the input\n\n\n\nThe Table 3.2 presents how the three steps described ealier translate into Zig code:\n\n\n\nTable 3.2: The necessary steps for the 6-transformation in the decode process.\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\nByte index in the output\nIn code\n\n\n\n\n0\n(buf[0] &lt;&lt; 2) + (buf[1] &gt;&gt; 4)\n\n\n1\n(buf[1] &lt;&lt; 4) + (buf[2] &gt;&gt; 2)\n\n\n2\n(buf[2] &lt;&lt; 6) + buf[3]\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.5.3 Writing the decode() function\nThe decode() function below contains the entire decoding process. Notice that, we first calculate the necessary size for the output, with _calc_decode_length(), then, we allocate memory for this output with the allocator object.\nThree temporary variables are created: 1) count, to hold the window count in each iteration of the for loop; 2) iout, to hold the current index in the output; 3) buf, which is the temporary buffer that holds the base64 indexes to be converted through the 6-bit transformation.\nThen, in each iteration of the for loop we fill the temporary buffer with the current window of bytes. When count hits the number 4, then, we have a full window of indexes in buf to be converted, and then, we apply the 6-bit transformation over the temporary buffer.\nNotice that we check if the indexes 2 and 3 in the temporary buffer are the number 64, which, if you recall from Section 3.5.1, is when the _calc_index() function receives a '=' character as input. So, if these indexes are equal to the number 64, the decode() function knows that it can simply ignore these indexes. They are not converted, because, as I described before, the character '=' have no meaning, despite being the end of meaningful characters in the sequence. So we can safely ignore them, when they appear in the sequence.\n\nfn decode(self: Base64,\n          allocator: std.mem.Allocator,\n          input: []const u8) ![]u8 {\n\n    if (input.len == 0) {\n        return \"\";\n    }\n    const n_output = _calc_decode_length(input);\n    var output = try allocator.alloc(u8, n_output);\n    for (output, 0..) |_, i| {\n        output[i] = 0;\n    }\n    var count: u8 = 0;\n    var iout: u64 = 0;\n    var buf = [4]u8{ 0, 0, 0, 0 };\n\n    for (0..input.len) |i| {\n        buf[count] = self._char_index(input[i]);\n        count += 1;\n        if (count == 4) {\n            output[iout] = (buf[0] &lt;&lt; 2) + (buf[1] &gt;&gt; 4);\n            if (buf[2] != 64) {\n                output[iout + 1] = (buf[1] &lt;&lt; 4) + (buf[2] &gt;&gt; 2);\n            }\n            if (buf[3] != 64) {\n                output[iout + 2] = (buf[2] &lt;&lt; 6) + buf[3];\n            }\n            iout += 3;\n            count = 0;\n        }\n    }\n\n    return output;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#the-end-result",
    "href": "Chapters/01-base64.html#the-end-result",
    "title": "3  Building a base64 encoder/decoder",
    "section": "3.6 The end result",
    "text": "3.6 The end result\nNow that we have both decode() and encode() implemented. We have a full functioning base64 encoder/decoder implemented in Zig. Here is an example of use of our Base64 struct with the encode() and decode() methods that we implemented.\n\nvar memory_buffer: [1000]u8 = undefined;\nvar fba = std.heap.FixedBufferAllocator.init(\n    &memory_buffer\n);\nconst allocator = fba.allocator();\n\nconst text = \"Testing some more shit\";\nconst etext = \"VGVzdGluZyBzb21lIG1vcmUgc2hpdA==\";\nconst base64 = Base64.init();\nconst encoded_text = try base64.encode(\n    allocator, text\n);\nconst decoded_text = try base64.decode(\n    allocator, etext\n);\ntry stdout.print(\n    \"Encoded text: {s}\\n\", .{encoded_text}\n);\ntry stdout.print(\n    \"Decoded text: {s}\\n\", .{decoded_text}\n);\n\nEncoded text: VGVzdGluZyBzb21lIG1vcmUgc2hpdA==\nDecoded text: Testing some more shit\nYou can also see the full source code at once, by visiting the official repository of this book3. More precisely inside the Examples folder4.\n\n\n\n\nMicrosoft. 2021. “Bitwise AND Operator: &.” Microsoft Learn. https://learn.microsoft.com/en-us/cpp/cpp/bitwise-and-operator-amp?view=msvc-170.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#footnotes",
    "href": "Chapters/01-base64.html#footnotes",
    "title": "3  Building a base64 encoder/decoder",
    "section": "",
    "text": "Notice that, the character “0” is different than the actual number 0, which is simply zero in binary.↩︎\nhttps://github.com/pedropark99/zig-book/blob/main/Examples/base64/base64_basic.zig.↩︎\nhttps://github.com/pedropark99/zig-book↩︎\nhttps://github.com/pedropark99/zig-book/blob/main/Examples/base64/base64_basic.zig.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html",
    "href": "Chapters/02-debugging.html",
    "title": "4  Debugging Zig applications",
    "section": "",
    "text": "4.1 Printing debugging\nWe begin with the classic and battle-tested print debugging strategy. The key advantage that debugging offers you is visibility. With print statements you can easily see what results and objects that are being generated within your functions.\nThat is the essence of print debugging. Is to use print expressions to see the values that are being generated by your program, and, as a result, get a much better understanding of how your program is behaving.\nMany programmers often resort to the print functions in Zig, such as the stdout.print(), or, the std.debug.print(), to get a better understanding of their programs. This is an known and old strategy that is very simple and effective, and it is better known within the programming community as print debugging. In Zig, you can either print information to the stdout or stderr streams of your system.\nLet’s begin with stdout. First, you need to get access to the stdout, by calling the getStdOut() method, from the Zig standard library. This method returns a file descriptor object, and, through this object you can read/write to the stdout. I recommend you to check out all methods available in this object, by checking the page in the Zig Standard Library Official Reference for the type File1.\nFor our purpose here, which is to write something to the stdout, specially to debug our program, I recommend you to use the writer() method, which gives your a writer object. This writer object offers some helper methods to write stuff into the file descriptor object that represents the stdout stream. In special, the print() method.\nThe print() method from this writer object is a “print formatter” type of a function. In other words, this method works exactly like the printf() function from C, or, like println!() from Rust. In the first argument of the function, you specify a template string, and, in the second argument, you provide a list of values (or objects) that you want to insert into your template message.\nIdeally, the template string in the first argument should contain some format specifier. Each format specifier is matched to a value (or object) that you listed in the second argument. So, if you provided 5 different objects in the second argument, then, the template string should contain 5 format specifiers, one for each object provided.\nEach format specifier is represented by a single letter, and you provide this format specifier inside a pair of curly braces. So, if you want to format your object using the string specifier (s), then, you can insert the text {s} in your template string. Here is a quick list of the most used format specifiers:\nThe code example below, gives you an example of use of this print() method with the d format specifier.\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nfn add(x: u8, y: u8) u8 {\n    return x + y;\n}\n\npub fn main() !void {\n    const result = add(34, 16);\n    _ = try stdout.print(\"Result: {d}\", .{result});\n}\n\nResult: 50\nIs important to emphasize that, the stdout.print() method, as you would expect, print your template string into the stdout stream of your system. However, you can also print your template string into the stderr stream if your prefer. All you need to do, is to replace the stdout.print() call with the function std.debug.print(). Like this:\nconst std = @import(\"std\");\nfn add(x: u8, y: u8) u8 {\n    return x + y;\n}\n\npub fn main() !void {\n    const result = add(34, 16);\n    std.debug.print(\"Result: {d}\\n\", .{result});\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#printing-debugging",
    "href": "Chapters/02-debugging.html#printing-debugging",
    "title": "4  Debugging Zig applications",
    "section": "",
    "text": "d: for printing integers.\nf: for printing floating-point numbers.\nc: for printing characters.\ns: for printing strings.\np: for printing memory addresses.\nx: for printing hexadecimal values.\nany: use any compatible format specifier (i.e. it automatically selects a format specifier for you).\n\n\n\n\n\nResult: 50",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#debugging-through-debuggers",
    "href": "Chapters/02-debugging.html#debugging-through-debuggers",
    "title": "4  Debugging Zig applications",
    "section": "4.2 Debugging through debuggers",
    "text": "4.2 Debugging through debuggers\nAlthough print debugging is a valid and very useful strategy, most programmers prefer to use a debugger to debug their programs. Since Zig is a low-level language, you can use either GDB (GNU Debugger), or LLDB (LLVM Project Debugger) as your debugger.\nBoth debuggers can work with Zig code, and it’s a matter of taste here. You choose the debugger of your preference, and you work with it. In this book, I will use LLDB as my debugger on the examples.\n\n4.2.1 Compile your source code in Debug mode\nIn order to debug your program through a debugger, you must compile your source code in Debug mode. Because when you compile your source code in other modes (such as Release), the compiler usually strips out some essential information that is used by the debugger to read and track your program, like PDB (Program Database) files.\nBy compiling your source code in Debug mode, you ensure that the debugger will find the necessary information in your program to debug it. By default, the compiler uses the Debug mode. Having this in mind, when you compile your program with the build-exe command (that we exposed at Section 1.2.4), if you don’t specify an explicit mode through the -O command-line 2 argument, then, the compiler will compile your code in Debug mode.\n\n\n4.2.2 Let’s debug a program\nAs an example, let’s debug some Zig code, and demonstrate how can we use LLDB to navigate and check the following piece of Zig code:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\n\nfn add_and_increment(a: u8, b: u8) u8 {\n    const sum = a + b;\n    const incremented = sum + 1;\n    return incremented;\n}\n\npub fn main() !void {\n    var n = add_and_increment(2, 3);\n    n = add_and_increment(n, n);\n    _ = try stdout.print(\"Result: {d}!\\n\", .{n});\n}\n\nResult: 13!\n\n\nThere is nothing wrong with this program. But it is a good start for us. First, we need to compile this program with the zig build-exe command. For this example, suppose that I compiled the above Zig code into a binary executable called add_program.\nzig build-exe add_program.zig\nNow, we can start LLDB with add_program, like this:\nlldb add_program\nFrom now on, LLDB is started, and you can know that I’m executing LLDB commands by looking at the prefix (lldb). If something is prefixed with (lldb), then you know that it is a LLDB command.\nThe first thing I will do, is to set a breakpoint at the main() function, by executing b main. After that, I just start the execution of the program with run. You can see in the output below, that the execution stopped at the first line in the function main(), as we expected.\n(lldb) b main\nBreakpoint 1: where = debugging`debug1.main + 22\n    at debug1.zig:11:30, address = 0x00000000010341a6\n(lldb) run\nProcess 8654 launched: 'add_program' (x86_64)\nProcess 8654 stopped\n* thread #1, name = 'add_program',\n    stop reason = breakpoint 1.1 frame #0: 0x10341a6\n    add_program`debug1.main at add_program.zig:11:30\n   8    }\n   9    \n   10   pub fn main() !void {\n-&gt; 11       var n = add_and_increment(2, 3);\n   12       n = add_and_increment(n, n);\n   13       try stdout.print(\"Result: {d}!\\n\", .{n});\n   14   }\nI can start to navigate through the code, and investigating the variables that are being generated. If you not familiar with the commands available in LLDB, I recommend you to read the official documentation of the project3. You can also look for cheat sheets. Which quickly describes all commands available for you, and, as a result, are also good resources for you4.\nCurrently, we are in the first line at the main() function. In this line, we create the n object, by executing the add_and_increment() function. To execute the current line of code, and go to the next line, we can run the n LLDB command. Let’s execute this command.\nAfter we executed this line, we can also look at the value stored inside this n object by using the p LLDB command. The syntax for this command is p &lt;name-of-object&gt;.\nIf we take a look at the value stored in the n object (p n), notice that it stores the hexadecimal value 0x06, which is the number 6 in decimal. We can also see that, this value have a type unsigned char, which is an unsigned 8-bit integer. We have talked already about this at Section 1.11, that u8 integers in Zig are equivalent to the C data type unsigned char.\n(lldb) n\nProcess 4798 stopped\n* thread #1, name = 'debugging',\n    stop reason = step over frame #0: 0x10341ae\n    debugging`debug1.main at debug1.zig:12:26\n   9    \n   10   pub fn main() !void {\n   11       var n = add_and_increment(2, 3);\n-&gt; 12       n = add_and_increment(n, n);\n   13       try stdout.print(\"Result: {d}!\\n\", .{n});\n   14   }\n(lldb) p n\n(unsigned char) $1 = '\\x06'\nNow, on the next line of code, we are executing the add_and_increment() function once again. Why not step inside this function? Shall we? We can do that, by executing the s LLDB command. Notice in the example below that, after executing this command, we entered inside the context of the add_and_increment() function.\nAlso notice in the example below that, I walked two more lines in the functions body, then, I executed the frame variable LLDB command, to see at once, the value stored in each of the variables that were created inside the current scope.\nYou can see in the output below that, the object sum stores the value \\f, which represents the form feed character. This character in the ASCII table, corresponds to the hexadecimal value 0x0C, or, in decimal, the number 12. So, this means that the result of the expression a + b executed at line 5, resulted in the number 12.\n(lldb) s\nProcess 4798 stopped\n* thread #1, name = 'debugging',\n    stop reason = step in frame #0: 0x10342de\n    debugging`debug1.add_and_increment(a='\\x02', b='\\x03')\n    at debug1.zig:4:39\n-&gt; 4    fn add_and_increment(a: u8, b: u8) u8 {\n   5        const sum = a + b;\n   6        const incremented = sum + 1;\n   7        return incremented;\n(lldb) n\n(lldb) n\n(lldb) frame variable\n(unsigned char) a = '\\x06'\n(unsigned char) b = '\\x06'\n(unsigned char) sum = '\\f'\n(unsigned char) incremented = '\\x06'",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#footnotes",
    "href": "Chapters/02-debugging.html#footnotes",
    "title": "4  Debugging Zig applications",
    "section": "",
    "text": "https://ziglang.org/documentation/master/std/#std.fs.File.↩︎\nSee https://ziglang.org/documentation/master/#Debug.↩︎\nhttps://lldb.llvm.org/↩︎\nhttps://gist.github.com/ryanchang/a2f738f0c3cc6fbd71fa.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html",
    "href": "Chapters/03-unittests.html",
    "title": "5  Unit tests in Zig",
    "section": "",
    "text": "5.1 Introducing the test block\nIn Zig, unit tests are written inside a test declaration, or, how I prefer to call it, inside a test block. Every test block is written by using the keyword test. You can optionally use a string literal to write a label, which is responsible for identifying the specific group of unit tests that you are writing inside this specific test block.\nIn the example below, we are testing if the sum of two objects (a and b) is equal to 4. The expect() function from the Zig Standard Library is a function that receives a logical test as input. If this logical test results in true, then, the test passes. But if it results in false, then, the test fails.\nYou can write any Zig code you want inside of each test block. Part of this code might be some necessary commands to setup your testing environment, or just initializing some necessary objects.\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\ntest \"testing simple sum\" {\n    const a: u8 = 2;\n    const b: u8 = 2;\n    try expect((a + b) == 4);\n}\nYou can have multiple test blocks written on the same Zig module. Also, you can mix test blocks with your source code, with no problems or consequences. If you mix test blocks with your normal source code, when you execute the build, build-exe, build-obj or build-lib commands from the zig compiler that we exposed at Section 1.2.4, these test blocks are automatically ignored by the compiler.\nIn other words, the zig compiler only builds and execute your tests when you ask it to. By default, the compiler always ignore test blocks written in your Zig modules. The compiler normally checks only if there are any syntax errors in these test blocks.\nIf you look at the source code for most of the files present in the Zig Standard Library1, you can see that the test blocks are written together with the normal source code of the library. You can see this for example, at the array_list module2. So, the standard that the Zig developers decided to adopt is to keep their unit tests together with the source code of the functionality that they are testing.\nEach programmer might have a different opinion on this. Some of them might prefer to keep unit tests separate from the actual source code of their application. If that is your case, you can simply create a separate tests folder in your project, and start writing Zig modules that contains only unit tests (as would normally do on a Python project with pytest, for example), and everything will work fine. It boils down to which is your preference here.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#how-to-run-your-tests",
    "href": "Chapters/03-unittests.html#how-to-run-your-tests",
    "title": "5  Unit tests in Zig",
    "section": "5.2 How to run your tests",
    "text": "5.2 How to run your tests\nIf the zig compiler ignores any test block by default, how can you compile and run your unit tests? The answer is the test command from the zig compiler. By running zig test command, the compiler will find every instance of test block in your Zig module, and, it will compile and run the unit tests you wrote.\nzig test simple_sum.zig\n1/1 simple_sum.test.testing simple sum... OK\nAll 1 tests passed.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-memory-allocations",
    "href": "Chapters/03-unittests.html#testing-memory-allocations",
    "title": "5  Unit tests in Zig",
    "section": "5.3 Testing memory allocations",
    "text": "5.3 Testing memory allocations\nOne of the advantages of Zig is that it offers great tools that hep us, programmers, to avoid (but also detect) memory problems, such as memory leaks and double-frees. The defer keyword is specially helpful in this regard.\nWhen developing your source code, you, the programmer, is responsible for making sure that your code do not produce such problems. However, you can also use a special type of allocator object in Zig, that is capable of automatically detect such problems for you. This is the std.testing.allocator object. This allocator object offers some basic memory safety detection features, which are capable of detecting memory leaks.\nAs we described at Section 2.1.5, to allocate memory on the heap, you need to use an allocator object, and your functions that use these objects to allocate memory on the heap, should receive an allocator object as one of it’s inputs. Every memory on the heap that you allocate using these allocator objects, must also be freed using this same allocator object.\nSo, if you want to test the memory allocations performed by your functions, and make sure that you don’t have problems in these allocations, you can simply write unit tests for these functions, where you provide the std.testing.allocator object as input to these functions.\nLook at the example below, where I’m defining a function that clearly causes a memory leak. Because we allocate memory with the allocator object, but we do not free this allocated memory in any point. So, when the function returns, we lose the reference to the buffer object, which contains the allocated memory, and, as a result, we can no longer free this memory.\nNotice that, inside a test block I execute this function with the std.testing.allocator. Since no visible errors were raised inside the test block, the zig compiler completes the process indicating that the unit tests performed inside the test block labeled as \"memory leak have all passed. But despite this result, the allocator object was capable of looking deeper in our program, and detecting the memory leak. As a result, this allocator object returns a message “tests leaked memory”, and also, a stack trace showing the exact point where the memory was leaked.\n\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nfn some_memory_leak(allocator: Allocator) !void {\n    const buffer = try allocator.alloc(u32, 10);\n    _ = buffer;\n    // Return without freeing the\n    // allocated memory\n}\n\ntest \"memory leak\" {\n    const allocator = std.testing.allocator;\n    try some_memory_leak(allocator);\n}\n\nTest [1/1] leak_memory.test.memory leak...\n    [gpa] (err): memory address 0x7c1fddf39000 leaked: \n./ZigExamples/debugging/leak_memory.zig:4:39: 0x10395f2\n    const buffer = try allocator.alloc(u32, 10);\n                                      ^\n./ZigExamples/debugging/leak_memory.zig:12:25: 0x10398ea\n    try some_memory_leak(allocator);\n\n... more stack trace",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-errors",
    "href": "Chapters/03-unittests.html#testing-errors",
    "title": "5  Unit tests in Zig",
    "section": "5.4 Testing errors",
    "text": "5.4 Testing errors\nOne commom style of unit tests are those that look for specific errors in your functions. In other words, you write a unit test that tries to assert if a specific function call returns any error, or a specific type of error.\nIn C++ you would normally write this stye of unit test using, for example, the functions REQUIRE_THROWS() or CHECK_THROWS() from the Catch2 test framework3. In the case of a Python project, you would use the raises() function from pytest4. While in Rust, you would probably use assert_eq!() in conjunction with Err().\nBut in Zig, we use the expectError() function, from the std.testing module. With this function, you can test if a specific function call returns the exact type of error that you expect it to return. To use this function, you first write try expectError(). Then, on the first argument, you provide the type of error that you are expecting from the function call. Then, on the second argument, you write the function call you expect to fail.\nThe code example below demonstrates such type of unit test in Zig. Notice that, inside the function alloc_error() we are allocating 100 bytes of memory, or, an array of 100 elements, for the object ibuffer. However, in the test block, we are using the FixedBufferAllocator() allocator object, which is limited to 10 bytes of space, because the object buffer, which we provided to the allocator object, have only 10 bytes of space.\nThat is why, the alloc_error() function raises an OutOfMemory error on this case. Because this function is trying to allocate more space than the allocator object allows. So, in essence, we are testing for a specific type of error, which is OutOfMemory. If the alloc_error() function returns any other type of error, then, the expectError() function would make the entire test fail.\n\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nconst expectError = std.testing.expectError;\nfn alloc_error(allocator: Allocator) !void {\n    var ibuffer = try allocator.alloc(u8, 100);\n    defer allocator.free(ibuffer);\n    ibuffer[0] = 2;\n}\n\ntest \"testing error\" {\n    var buffer: [10]u8 = undefined;\n    var fba = std.heap.FixedBufferAllocator.init(&buffer);\n    const allocator = fba.allocator();\n    try expectError(error.OutOfMemory, alloc_error(allocator));\n}\n\n1/1 oom.test.testing error... OK\nAll 1 tests passed.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-simple-equalities",
    "href": "Chapters/03-unittests.html#testing-simple-equalities",
    "title": "5  Unit tests in Zig",
    "section": "5.5 Testing simple equalities",
    "text": "5.5 Testing simple equalities\nIn Zig, there are some different ways you can test for an equality. You already saw that we can use expect() with the logical operator == to essentially reproduce an equality test. But we also have some helper functions that you should know about, specially expectEqual(), expectEqualSlices() and expectEqualStrings().\nThe expectEqual() function, as the name suggests, is a classic test equality function. It receives two objects as input. The first object is the value that you expect to be in the second object. While second object is the object you have, or, the object that your application produced as result. So, with expectEqual() you are essentially testing if the values stored inside the two provided objects are equal or not.\nYou can see in the example below that, the test performed by expectEqual() failed. Because the objects v1 and v2 contain different values in them.\n\nconst std = @import(\"std\");\ntest \"values are equal?\" {\n    const v1 = 15;\n    const v2 = 18;\n    try std.testing.expectEqual(v1, v2);\n}\n\n1/1 ve.test.values are equal?...\n    expected 15, found 18\n    FAIL (TestExpectedEqual)\nve.zig:5:5: test.values are equal? (test)\n    try std.testing.expectEqual(v1, v2);\n    ^\n0 passed; 0 skipped; 1 failed.\nAlthough useful, the expectEqual() function does not work with arrays. For testing if two arrays are equal, you should use the expectEqualSlices() function instead. This function have three arguments. First, you provide the data type contained in both arrays that you are trying to compare. While the second and third arguments corresponds to the array objects that you want to compare.\nIn the example below, we are using this function to test if two array objects (array1 and array2) are equal or not. Since they are in fact equal, the unit test passed with no errors.\n\nconst std = @import(\"std\");\ntest \"arrays are equal?\" {\n    const array1 = [3]u32{1, 2, 3};\n    const array2 = [3]u32{1, 2, 3};\n    try std.testing.expectEqualSlices(\n        u32, &array1, &array2\n    );\n}\n\n1/1 oom.test.arrays are equal?... OK\nAll 1 tests passed.\nAt last, you might also want to use the expectEqualStrings() function. As the name suggests, you can use this function to test if two strings are equal or not. Just provide the two string objects that you want to compare, as inputs to the functions.\nIf the function finds any existing difference between the two strings, then, the function will raise an error, and also, print an error message that shows the exact difference between the two string objects provided, as the example below demonstrates:\n\nconst std = @import(\"std\");\ntest \"strings are equal?\" {\n    const str1 = \"hello, world!\";\n    const str2 = \"Hello, world!\";\n    try std.testing.expectEqualStrings(\n        str1, str2\n    );\n}\n\n1/1 t.test.strings are equal?... \n====== expected this output: =========\nhello, world!␃\n======== instead found this: =========\nHello, world!␃\n======================================\nFirst difference occurs on line 1:\nexpected:\nhello, world!\n^ ('\\x68')\nfound:\nHello, world!\n^ ('\\x48')",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#footnotes",
    "href": "Chapters/03-unittests.html#footnotes",
    "title": "5  Unit tests in Zig",
    "section": "",
    "text": "https://github.com/ziglang/zig/tree/master/lib/std↩︎\nhttps://github.com/ziglang/zig/blob/master/lib/std/array_list.zig↩︎\nhttps://github.com/catchorg/Catch2/tree/devel↩︎\nhttps://docs.pytest.org/en/7.1.x/reference/reference.html#pytest-raises↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html",
    "href": "Chapters/04-http-server.html",
    "title": "6  Building a HTTP Server from scratch",
    "section": "",
    "text": "6.1 What is a HTTP Server?\nFirst of all, what is a HTTP Server? A HTTP server, as any other type of server, is essentially a program that runs indefinetly, on a infinite loop, waiting for incoming connections from clients. Once the server receives an incoming connection, it will accept this connection, and it will send messages back-and-forth to the client through this connection.\nBut the messages that are transmitted inside this connection are in a specific format. They are HTTP messages (i.e. messages that uses the HTTP Protocol specification). The HTTP Protocol is the backbone of the modern web. The world wide web as we know it today, would not exist without the HTTP Protocol.\nSo, Web servers (which is just a fancy name to HTTP Servers) are servers that exchange HTTP messages with clients. And these HTTP servers and the HTTP Protocol specification are simply essential to the operation of the internet of today.\nThat is the whole picture of the process. Again, we have two subjects involved here, a server (which is a program that is running indefinetly, waiting for connections), and a client (which is someone that wants to connect to and exchange HTTP messages with the server).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#how-a-http-server-works",
    "href": "Chapters/04-http-server.html#how-a-http-server-works",
    "title": "6  Building a HTTP Server from scratch",
    "section": "6.2 How a HTTP Server works?",
    "text": "6.2 How a HTTP Server works?\nImagine a HTTP Server as if it were the receptionist of a large hotel. In a hotel, you have a reception, and inside that reception there is a receptionist waiting for customers to arrive. A HTTP Server is essentially a receptionist that is indefinetly waiting for new customers (or, in the context of HTTP, new clients) to arrive in the hotel.\nWhen a customer arrives at the hotel, that customer starts a conversation with the receptionist. He tells the receptionist how many days he wants to stay at the hotel. Then, the receptionist search for an available apartment. If there is an available apartment at the moment, the customer pays the hotel fees, then, he gets the keys to the apartment, and then, he goes to the apartment to rest.\nAfter this entire process of dealing with the customer (searching for available rooms, receiving payment, handing over the keys), the receptionist goes back to what he was doing earlier, which is to wait. Wait for new customers to arrive.\nThat is, in a nutshell, what a HTTP Server do. It waits for clients to connect to the server. When a client attempts to connect to the server, the server accepts this connection, and it starts to exchange messages with the client through this connection. The first message that happens inside this connection is always a message from the client to the server. This message is called the HTTP Request.\nThis HTTP Request is a HTTP message that contains what the client wants from the server. Is literally a request. The client that connected to the server is asking this server to do something for him.\nThere are different “types of request” that any client can do to a HTTP Server. But the most basic type of request, is when a client ask to the HTTP Server to serve (i.e. to send) some specific web page (which is a HTML file) to him. When you type google.com in your web browser, you are essentially sending a HTTP Request to Google’s HTTP servers, which asks these servers to send the Google webpage to you.\nNonetheless, when the server reiceves this first message, the HTTP Request, it analyzes this request, to understand: who the client is? what he wants the server to do? this client provided all the necessary information to perform the action that he asked? Etc.\nOnce the server understands what the client wants, he simply perform the action that was requested, and, to finish the whole process, the server sends back a HTTP message to the client, informing if the action performed was succesful or not, and, at last, the server ends (or closes) the connection with the client.\nThis last HTTP message sent from the server to the client, is called the HTTP Response. Because the server is responding to the action that was requested by the client. The main objective of this response message is let the client knows if the action requested was succesful or not, before the server closes the connection.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#sec-http-how-impl",
    "href": "Chapters/04-http-server.html#sec-http-how-impl",
    "title": "6  Building a HTTP Server from scratch",
    "section": "6.3 How a HTTP server is normally implemented?",
    "text": "6.3 How a HTTP server is normally implemented?\nLet’s use the C language as an example. There are many materials teaching how to write a simple HTTP server in C code, like Yu (2023), or Weerasiri (2023), or Meehan (2021). Having this in mind, I will not show C code examples here, because you can find them on the internet. But I will describe the theory behind the necessary steps to perform in the C code.\nIn essence, we normally implement a HTTP server in C using WebSocket technology, which involves the following steps:\n\nCreate a socket object.\nBind a name (or more specifically, an address) to this socket object.\nMake this socket object to start listening and waiting for incoming connections.\nWhen a connection arrive, we accept this connection, and we exchange the HTTP messages (HTTP Request and HTTP Response).\nThen, we simply close this connection.\n\nA socket object (which uses the WebSocket technology) is essentially a channel of communication. You are creating a channel where people can send messages to. When you create a socket object, this object is not binded to any particular address. This means that with this object you have a representation of a channel of communication in your hands. But this channel is not currently available, or, it is not currently accessible, because it do not have a known address where you can find it.\nThat is what the “bind” operation do. It binds a name (or more specifically, an address) to this socket object, or, this channel of communication, so that it becomes available, or, accessible through this address. While the “listen” operation makes the socket object to listen for incoming connections in this address. In other words, the “listen” operation makes the socket to wait for incoming connections.\nNow, when a client actually attempts to connect to the server through the address we specify, then, the socket object needs to accept this incoming connection. When we accept it, then, the connection is established, client and server are now connected to each other, and they can read or write messages in this established connection.\nAfter we received the HTTP Request from the client, and sent the HTTP Response to the client, we can now close the connection, and end this communication.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#implementing-the-server",
    "href": "Chapters/04-http-server.html#implementing-the-server",
    "title": "6  Building a HTTP Server from scratch",
    "section": "6.4 Implementing the server",
    "text": "6.4 Implementing the server\nLet’s begin with creating the socket for our server. In Zig, we can create a web socket using the std.posix.socket() function, from the Zig Standard Library.\n\n6.4.1 Creating the socket object\nAs I meantioned earlier at Section 6.3, every socket object we create represents a communication channel, and we need to bind this channel to a specific address. An “address” is defined as an IP address, or, more specifically, an IPv4 address1. Every IPv4 address is composed by two components. The first component is the host, which is a sequence of 4 numbers separated by dot characters (.) that identifies the machine used. While the second component is a port number, which identifies the specific door, or, the specific port to use in the host.\nThe sequence of 4 numbers (i.e. the host) identifies the machine (i.e. the computer itselft) where this socket will live in. Every computer normally have multiple “doors” available inside him, because this allows the computer to receive multiple connections at the same time. He simply use a single door for each connection. So the port number, is essentially a number that identifies the specific door in the computer that will be resposible for receiving the connection. That is, it identifies the “door” in the computer that the socket will use to receive incoming connections.\nTo make things simpler, I will use an IP address that identifies our current machine in this example. This means that, our socket object will reside on the same computer that we are currently using (this is also known as the “localhost”) to write this Zig source code.\nBy convention, the IP address that identifies the “locahost”, which is the current machine we are using, is the IP 127.0.0.1. So, that is the IP address we are going to use in our server. I can declare it in Zig by using an array of 4 integers, like this: [4]u8{ 127, 0, 0, 1 }.\nNow, we need to decide which port number to use. By convention, there are some port numbers that are reserved, meaning that, we cannot use them for our own purposes, like the port 22 (which is normally used for SSH connections). For TCP connections, which is our case here, a port number is a 16-bit unsigned integer (type u16 in Zig), thus ranging from 0 to 65535 (Wikipedia 2024). So, we can choose a number from 0 to 65535 for our port number. In the example of this book, I will use the port number 3490 (just a random number).\nNow that we have these two informations at hand, I can finally create our socket object, using the std.posix.socket() function. First, we use the host and the port number to create an Address object, with the std.net.Address.initIp4() function, like in the example below. After that, I use this address object inside the socket() function to create our socket object.\nThe Socket struct defined below summarizes all the logic behind this this process. In this struct, we have two data members, which are: 1) the address object; 2) and a stream object, which is the object we will use to read and write the messages into any connection we establish.\nNotice that, inside the constructor method of this struct, when we create the socket object, we are using the IPROTO.TCP property as an input to tell the function to create a socket for TCP connections.\n\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst net = @import(\"std\").net;\n\npub const Socket = struct {\n    _address: std.net.Address,\n    _stream: std.net.Stream,\n\n    pub fn init() !Socket {\n        const host = [4]u8{ 127, 0, 0, 1 };\n        const port = 3490;\n        const addr = net.Address.initIp4(host, port);\n        const socket = try std.posix.socket(addr.any.family, std.posix.SOCK.STREAM, std.posix.IPPROTO.TCP);\n        const stream = net.Stream{ .handle = socket };\n        return Socket{ ._address = addr, ._stream = stream };\n    }\n};\n\n\n\n6.4.2 Listening and receiving connections\nOnce we created our socket object, we can focus now on making this socket object listen and receiving new incoming connections. Notice in the example below that, we stored the Socket struct declaration that we built at Section 6.4.1 inside a Zig module named config.zig. Then, I imported this module into our main module as the SocketConf object, to access the Socket struct.\nWe do that, by calling the listen() and accept() methods from the Address object that is contained in the socket object.\n\nconst std = @import(\"std\");\nconst SocketConf = @import(\"config.zig\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const socket = try SocketConf.Socket.init();\n    try stdout.print(\"Server Addr: {any}\\n\", .{socket._address});\n    var server = try socket._address.listen(.{});\n    const connection = try server.accept();\n    _ = connection;\n}\n\n\n\n\n\nMeehan, Eric. 2021. “Creating a Web Server from Scratch in c.” Youtube. https://www.youtube.com/watch?v=gk6NL1pZi1M&ab_channel=EricOMeehan.\n\n\nWeerasiri, Nipun Chamikara. 2023. “A Simple Web Server Written in c.” Medium. https://medium.com/@nipunweerasiri/a-simple-web-server-written-in-c-cf7445002e6.\n\n\nWikipedia. 2024. “Port (Computer Networking).” Wikipedia. https://en.wikipedia.org/wiki/Port_(computer_networking).\n\n\nYu, Jeffrey. 2023. “How i Built a Simple HTTP Server from Scratch Using c.” DEV Community. https://dev.to/jeffreythecoder/how-i-built-a-simple-http-server-from-scratch-using-c-739.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#footnotes",
    "href": "Chapters/04-http-server.html#footnotes",
    "title": "6  Building a HTTP Server from scratch",
    "section": "",
    "text": "It can be also an IPv6 address. But normally, we use a IPv4 address for that.↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Chen, Jenny, and Ruohao Guo. 2022. “Stack and Heap Memory.”\nIntroduction to Data Structures and Algorithms with C++. https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/.\n\n\nMeehan, Eric. 2021. “Creating a Web Server from Scratch in\nc.” Youtube. https://www.youtube.com/watch?v=gk6NL1pZi1M&ab_channel=EricOMeehan.\n\n\nMicrosoft. 2021. “Bitwise AND Operator: &.” Microsoft\nLearn. https://learn.microsoft.com/en-us/cpp/cpp/bitwise-and-operator-amp?view=msvc-170.\n\n\nSobeston. 2024. “Zig Guide.” https://zig.guide/.\n\n\nWeerasiri, Nipun Chamikara. 2023. “A Simple Web Server Written in\nc.” Medium. https://medium.com/@nipunweerasiri/a-simple-web-server-written-in-c-cf7445002e6.\n\n\nWikipedia. 2024. “Port (Computer Networking).” Wikipedia.\nhttps://en.wikipedia.org/wiki/Port_(computer_networking).\n\n\nYu, Jeffrey. 2023. “How i Built a Simple HTTP Server from Scratch\nUsing c.” DEV Community. https://dev.to/jeffreythecoder/how-i-built-a-simple-http-server-from-scratch-using-c-739.\n\n\nZig Software Foundation. 2024. “Language Reference.” Zig\nSoftware Foundation. https://ziglang.org/documentation/master/.",
    "crumbs": [
      "References"
    ]
  }
]