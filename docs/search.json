[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An Introduction to Zig",
    "section": "",
    "text": "Welcome\nWelcome! This is the initial page for the “Open Access” HTML version of the book “Introduction to Zig”, written by Pedro Duarte Faria. This book provides an introduction to the Zig programming language, which is a new general-purpose low-level language for building robust and optimal software.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#book-metadata",
    "href": "index.html#book-metadata",
    "title": "An Introduction to Zig",
    "section": "Book metadata",
    "text": "Book metadata\nThis book was compiled using the following versions of Zig and Quarto:\n\nSystem version: Linux, 6.5.0-41-generic, 22.04.2-Ubuntu, x86_64.\nZig version: 0.13.0-dev.266+0b0625ccf.\nQuarto version: 1.4.549.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html",
    "href": "Chapters/01-zig-weird.html",
    "title": "1  Introducing Zig",
    "section": "",
    "text": "1.1 What is Zig?\nZig is a modern low-level programming language. Some programmers interpret Zig as the “modern C language”. It is a simple language like C, but with some modern features.\nIn the author’s personal interpretation, Zig is tightly connected with “less is more”. Instead of trying to become a modern language by adding more and more features, many of the core improvements that Zig brings to the table are actually about removing annoying and evil behaviours/features from C and C++. In other words, Zig tries to be better by simplifying the language, and by having more consistent and robust behaviour. As a result, analyzing, writing and debugging applications become much easier and simpler in Zig, than it is in C or C++.\nThis philosophy becomes clear with the following phrase from the official website of Zig:\nThis phrase is specially true for C++ programmers. Because C++ is a gigantic language, with tons of features, and also, there are lots of different “flavors of C++”. These elements are what makes C++ so much complex and hard to learn. Zig tries to go in the opposite direction. Zig is a very simple language, more closely related to other simple languages such as C and Go.\nThe phrase above is still important for C programmers too. Because, even C being a simple language, it is still hard sometimes to read and understand C code. For example, pre-processor macros in C are an evil source of confusion. They really makes it hard sometimes to debug C programs. Because macros are essentially a second language embedded in C that obscures your C code. With macros, you are no longer 100% sure about which pieces of code are being sent to the compiler. It obscures the actual source code that you wrote.\nYou don’t have macros in Zig. In Zig, the code you write, is the actual code that get’s compiled by the compiler. You don’t have evil features that obscures you code. You also don’t have hidden control flow happening behind the scenes. And, you also don’t have functions or operators from the standard library that make hidden memory allocations behind your back.\nBy being a simpler language, Zig becomes much more clear and easier to read/write, but at the same time, it also achieves a much more robust state, with more consistent behaviour in edge situations. Once again, less is more.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#what-is-zig",
    "href": "Chapters/01-zig-weird.html#what-is-zig",
    "title": "1  Introducing Zig",
    "section": "",
    "text": "“Focus on debugging your application rather than debugging your programming language knowledge”.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#hello-world-in-zig",
    "href": "Chapters/01-zig-weird.html#hello-world-in-zig",
    "title": "1  Introducing Zig",
    "section": "1.2 Hello world in Zig",
    "text": "1.2 Hello world in Zig\nWe begin our journey in Zig by creating a small “Hello World” program. To start a new Zig project in your computer, you simply call the init command from the zig compiler. Just create a new directory in your computer, then, init a new Zig project inside this directory, like this:\nmkdir hello_world\ncd hello_world\nzig init\ninfo: created build.zig\ninfo: created build.zig.zon\ninfo: created src/main.zig\ninfo: created src/root.zig\ninfo: see `zig build --help` for a menu of options\n\n1.2.1 Understanding the project files\nAfter you run the init command from the zig compiler, some new files are created inside of your current directory. First, a “source” (src) directory is created, containing two files, main.zig and root.zig. Each .zig file is a separate Zig module, which is simply a text file that contains some Zig code.\nThe main.zig file for example, contains a main() function, which represents the entrypoint of your program. It is where the execution of your program begins. As you would expect from a C, C++, Rust or Go, to build an executabe program in Zig, you also need to declare a main() function in your module. So, the main.zig module represents an executable program written in Zig.\nOn the other side, the root.zig module does not contain a main() function. Because it represents a library written in Zig. Libraries are different than executables. They don’t need to have an entrypoint to work. So, you can choose which file (main.zig or root.zig) you want to follow depending on which type of project (executable or library) you want to develop.\ntree .\n.\n├── build.zig\n├── build.zig.zon\n└── src\n    ├── main.zig\n    └── root.zig\n\n1 directory, 4 files\nNow, in addition to the source directory, two other files were created in our working directory: build.zig and build.zig.zon. The first file (build.zig) represents a build script written in Zig. In other words, this file contain Zig code that executes the necessary steps to build the entire project.\nIn general, low-level languages normally use a compiler to build your source code into binary executables or binary libraries. Nevertheless, this process of compiling your source code and building binary executables or binary libraries from it, became a real challenge in the programming world, once the projects became bigger and bigger. As a result, programmers created “build systems”, which are a second set of tools designed to make this process of compiling and building complex projects, easier.\nExamples of build systems are CMake, GNU Make, GNU Autoconf and Ninja, which are used to build complex C and C++ projects. With these systems, you can write scripts, which are called “build scripts”. They simply are scripts that describes the necessary steps to compile/build your project.\nHowever, these are separate tools, that do not belong to C/C++ compilers, like gcc or clang. As a result, in C/C++ projects, you have not only to install and manage your C/C++ compilers, but you also have to install and manage these build systems separately.\nBut instead of using a separate build system, in Zig, we use the Zig language itself to write build scripts. In other words, Zig contains a native build system in it. And we can use this build system to write small scripts in Zig, which describes the necessary steps to build/compile our Zig project1. So, everything you need to build a complex Zig project is the zig compiler, and nothing more.\nNow that we described this topic in more depth, let’s focus on the second generated file (build.zig.zon), which is the Zig package manager configuration file, where you can list and manage the dependencies of your project. Yes, Zig have a package manager (like pip in Python, cargo in Rust, or npm in Javascript) called Zon, and this build.zig.zon file is similar to the package.json file in Javascript projects, or, the Pipfile in Python projects.\n\n\n1.2.2 Looking at the root.zig file\nLet’s take a look at the root.zig file, and start to analyze some of the syntax of Zig. The first thing that you might notice, is that every line of code that have an expression in it, ends with a semicolon character (;). This is similar syntax to other languages such as C, C++ and Rust, which have the same rule.\nAlso, notice the @import() call at the first line. We use this built-in function to import functionality from other Zig modules into our current module. In other words, the @import() function works similarly to the #include pre-processor in C or C++, or, to the import statement in Python or Javascript code. In this example, we are importing the std module, which gives you access to the Zig standard library.\nIn this root.zig file, we can also see how assignments (i.e. creating new objects) are made in Zig. You can create a new object in Zig by using the following syntax (const|var) name = value;. In the example below, we are creating two constant objects (std and testing). At Section 1.3 we talk more about objects in general.\n\nconst std = @import(\"std\");\nconst testing = std.testing;\n\nexport fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\nFunctions in Zig are declared similarly to functions in Rust, using the fn keyword. In the example above, we are declaring a function called add(), which have two arguments named a and b, and returns a integer number (i32) as result.\nMaybe Zig is not exactly a strongly-typed language, because you do not need necessarily to specify the type of every single object you create across your source code. But you do have to explicitly specify the type of every function argument, and also, the return type of every function you create in Zig. So, at least in function declarations, Zig is a strongly-typed language.\nWe specify the type of an object or a function argument in Zig, by using a colon character (:) followed by the type after the name of this object/function argument. With the expressions a: i32 and b: i32, we know that, both a and b arguments have type i32, which is a signed 32 bit integer. In this part, the syntax in Zig is identical to the syntax in Rust, which also specifies types by using the colon character.\nLastly, we have the return type of the function at the end of the line, before we open the curly braces to start writing the function’s body, which, in the example above is again a signed 32 bit integer (i32) value. This specific part is different than it is in Rust. Because in Rust, the return type of a function is specified after an arrow (-&gt;). While in Zig, we simply declare the return type directly after the parentheses with the function arguments.\nWe also have an export keyword before the function declaration. This keyword is similar to the extern keyword in C. It exposes the function to make it available in the library API.\nIn other words, if you have a project where you are currently building a library for other people to use, you need to expose your functions so that they are available in the library’s API, so that users can use it. If we removed the export keyword from the add() function declaration, then, this function would be no longer exposed in the library object built by the zig compiler.\nHaving that in mind, the keyword export is a keyword used in libraries written in Zig. So, if you are not currently writing a library in your project, then, you do not need to care about this keyword.\n\n\n1.2.3 Looking at the main.zig file\nNow that we have learned a lot about Zig’s syntax from the root.zig file, let’s take a look at the main.zig file. A lot of the elements we saw in root.zig are also present in main.zig. But we have some other elements that we did not have seen yet, so let’s dive in.\nFirst, look at the return type of the main() function in this file. We can see a small change. Now, the return type of the function (void) is accompanied by an exclamation mark (!). What this exclamation mark is telling us, is that this main() function might also return an error.\nSo, in this example, the main() function can either return void, or, return an error. This is an interesting feature of Zig. If you write a function, and, something inside of the body of this function might return an error, then, you are forced to:\n\neither add the exclamation mark to the return type of the function, to make it clear that this function might return an error.\nor explicitly handle this error that might occur inside the function, to make sure that, if this error does happen, you are prepared, and your function will no longer return an error because you handled the error inside your function.\n\nIn most programming languages, we normally handle (or deals with) an error through a try catch pattern, and Zig, this is no different. But, if we look at the main() function below, you can see that we do have a try keyword in the 5th line. But we do not have a catch keyword in this code.\nThis means that, we are using the keyword try to execute a code that might return an error, which is the stdout.print() expression. But because we do not have a catch keyword in this line, we are not treating (or dealing with) this error. So, if this expression do return an error, we are not catching and solving this error in any way. That is why the exclamation mark was added to the return type of the function.\nSo, in essence, the try keyword executes the expression stdout.print(). If this expression returns a valid value, then, the try keyword do nothing essentially. It simply passes this value forward. But, if the expression do return an error, then, the try keyword will unwrap and return this error from the function, and also print it’s stack trace to stderr.\nThis might sound weird to you, if you come from a high-level language. Because in high-level languages, such as Python, if an error occurs somewhere, this error is automatically returned and the execution of your program will automatically stops, even if you don’t want to stop the execution. You are obligated to face the error.\nBut if you come from a low-level language, then, maybe, this idea do not sound so weird or distant to you. Because in C for example, normally functions doesn’t raise errors, or, they normally don’t stop the execution. In C, error handling is done by constantly checking the return value of the function. So, you run the function, and then, you use an if statement to check if the function returned a value that is valid, or, if it returned an error. If an error was returned from the function, then, the if statement will execute some code that fixes this error.\nSo, at least for C programmers, they do need to write a lot of if statements to constantly check for errors around their code. And because of that, this simple feature from Zig, might be extraordinary for them. Because this try keyword can automatically unwrap the error, and warn you about this error, and let you deal with it, without any extra work from the programmer.\n\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n\nNow, another thing that you might have noticed in this code example, is that the main() function is marked with the pub keyword. This keyword means “public”. It marks the main() function as a public function from this module.\nIn other words, every function that you declare in your Zig module is, by default, a private (or “static”) function that belongs to this Zig module, and can only be used (or called) from within this same module. Unless, you explicitly mark this function as a public function with the pub keyword. This means that the pub keyword in Zig do essentially the opposite of what the static keyword do in C/C++.\nBy making a function “public”, you allow other Zig modules to access and call this function, and use it for they own purposes. all these other Zig modules need to do is, to import your module with the @import() built-in function. Then, they get access to all public functions that are present in your Zig module.\n\n\n1.2.4 Compiling your source code\nYou can compile your Zig modules into a binary executable by running the build-exe command from the zig compiler. You simply list all the Zig modules that you want to build after the build-exe command, separated by spaces. In the example below, we are compiling the module main.zig.\nzig build-exe src/main.zig\nSince we are building an executable, the zig compiler will look for a main() function declared in any of the files that you list after the build-exe command. If the compiler does not find a main() function declared somewhere, a compilation error will be raised, warning about this mistake.\nThe zig compiler also offers a build-lib and build-obj commands, which work the exact same way as the build-exe command. The only difference is that, they compile your Zig modules into a portale C ABI library, or, into object files, respectively.\nIn the case of the build-exe command, a binary executable file is created by the zig compiler in the root directory of your project. If we take a look now at the contents of our current directory, with a simple ls command, we can see the binary file called main that was created by the compiler.\nls\nbuild.zig  build.zig.zon  main  src\nIf I execute this binary executable, I get the “Hello World” message in the terminal , as we expected.\n./main\nHello, world!\n\n\n1.2.5 Compile and execute at the same time\nOn the previous section, I presented the zig build-exe command, which compiles Zig modules into an executable file. However, this means that, in order to execute the executable file, we have to run two different commands. First, the zig build-exe command, and then, we call the executable file created by the compiler.\nBut what if we wanted to perform these two steps, all at once, in a single command? We can do that by using the zig run command.\nzig run src/main.zig\nHello, world!\n\n\n1.2.6 Compiling the entire project\nJust as I described at Section 1.2.1, as our project grows in size and complexity, we usually prefer to organize the compilation and build process of the project into a build script, using some sort of “build system”.\nIn other words, as our project grows in size and complexity, the build-exe, build-lib and build-obj commands become harder and header to use directly. Because then we start to list multiple and multiple modules at the same time. We also start to adding built-in compilation flags to customize the build process for our needs, etc. It becomes a lot of work to write the necessary commands by hand.\nIn C/C++ projects, programmers usually opt to use CMake, Makefile or configure scripts to organize this process. However, in Zig, we have a native build system in the language itself. So, we can write build scripts in Zig to compile and build Zig projects. Then, all we need to do, is to call the zig build command to build our project.\nSo, when you execute the zig build command, the zig compiler will search for a Zig module named build.zig inside your current directory, which should be your build script, containing the necessary code to compile and build your project. If the compiler do find this build.zig file in your directory, then, the compiler will essentially execute a zig run command over this build.zig file, to compile and execute this build script, which in turn, will compile and build your entire project.\nzig build\nAfter you execute this “build project” command, a zig-out directory is created in the root of your project directory, where you can find the binary executables and libraries created from your Zig modules accordingly to the build commands that you specified at build.zig. We will talk more about the build system in Zig latter in this book.\nIn the example below, I’m executing the binary executable named hello_world that was generated by the compiler after the zig build command.\n./zig-out/bin/hello_world\nHello, world!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-assignments",
    "href": "Chapters/01-zig-weird.html#sec-assignments",
    "title": "1  Introducing Zig",
    "section": "1.3 Creating new objects in Zig (i.e. identifiers)",
    "text": "1.3 Creating new objects in Zig (i.e. identifiers)\nLet’s talk more about objects in Zig. Readers that have past experience with other programming languages might know the concept of “object” through a different name, such as: “variable” or “identifier”. In this book, I choose to use the name “object”.\nTo create a new object (or a new “identifier”) in Zig, we use the keywords const or var. These keywords specificy if the object that you are creating is mutable or not.\nIf you use const, then, the object you are creating is a constant (or immutable) object, meaning that, once you declare this object, you can no longer change the value stored inside this object.\nOn the other side, if you use var, then, you are creating a variable (or mutable) object. So, you can change the value of this object as many times you want. Using the keyword var in Zig is similar to using the keywords let mut in Rust.\n\n1.3.1 Constant objects vs variable objects\nIn the code example below, we are creating a new constant object called age. This object stores a number representing the age of someone. However, this code example does not compiles succesfully. Because on the next line of code, we are trying to change the value of the object age to 25.\nThe zig compiler detects that we are trying to change the value of an object/identifier that is constant, and because of that, the compiler will raise a compilation error, warning us about the mistake.\n\nconst age = 24;\n// The line below is not valid!\nage = 25;\n\nt.zig:10:5: error: cannot assign to constant\n    age = 25;\n      ~~^~~\nIn contrast, if you use var, then, the object created is a variable object. With var you can declare this object in your source code, and then, change the value of this object how many times you want over future points in your source code.\nSo, using the same code example exposed above, if I change the declaration of the age object to use the var keyword, then, the program gets compiled succesfully. Because now, the zig compiler detects that we are changing the value of an object that allows this behaviour, because it is an “variable object”.\n\nvar age: u8 = 24;\nage = 25;\n\n\n\n1.3.2 There is no such thing as unused objects\nEvery object (being constant or variable) that you declare in Zig must be used in some way. You can give this object to a function call, as a function argument, or, you can use it in another expression to calculate the value of another object, or, you can call a method that belongs to this particular object.\nIt doesn’t matter in which way you use it. As long as you use it. If you try to break this rule, i.e. if your try to declare a object, but not use it, the zig compiler will not compile your Zig source code, and it will issue a error message warning that you have unused objects in your code.\nLet’s demonstrate this with an example. In the source code below, we declare a constant object called age. If you try to compile a simple Zig program with this line of code below, the compiler will return an error as demonstrated below:\n\nconst age = 15;\n\nt.zig:4:11: error: unused local constant\n    const age = 15;\n          ^~~\nEverytime you declare a new object in Zig, you have two choices:\n\nyou either use the value of this object;\nor you explicitly discard the value of the object;\n\nTo explicitly discard the value of any object (constant or variable), all you need to do is to assign this object to an special character in Zig, which is the underscore (_). When you assign an object to a underscore, like in the example below, the zig compiler will automatically discard the value of this particular object.\nYou can see in the example below that, this time, the compiler did not complain about any “unused constant”, and succesfully compiled our source code.\n\n// It compiles!\nconst age = 15;\n_ = age;\n\nNow, remember, everytime you assign a particular object to the underscore, this object is essentially destroyed. It is discarded by the compiler. This means that you can no longer use this object further in your code. It doesn’t exist anymore.\nSo if you try to use the constant age in the example below, after we discarded it, you will get a loud error message from the compiler (talking about a “pointless discard”) warning you about this mistake.\n\n// It does not compile.\nconst age = 15;\n_ = age;\n// Using a discarded value!\nstd.debug.print(\"{d}\\n\", .{age + 2});\n\nt.zig:7:5: error: pointless discard\n    of local constant\nThis same rule applies to variable objects. Every variable object must also be used in some way. And if you assign a variable object to the underscore, this object also get’s discarded, and you can no longer use this object.\n\n\n1.3.3 You must mutate every variable objects\nEvery variable object you create in your source code must be mutated at some point in your source code. In other words, if you declare an object as a variable object, with the keyword var, if you do not change the value of this object at some point in the future, the zig compiler will detect this, and it will raise an error warning you about this mistake.\nThe concept behind this is that, every object you create in Zig should be explicitly constant, unless you really need an object whose value will change during the execution of your program.\nSo, if I try to declare a variable object such as where_i_live below, and I do not change the value of this object in some way, the zig compiler raises an error about ““.\n\nvar where_i_live = \"Belo Horizonte\";\n_ = where_i_live;\n\nt.zig:7:5: error: local variable is never mutated\nt.zig:7:5: note: consider using 'const'",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#primitive-data-types",
    "href": "Chapters/01-zig-weird.html#primitive-data-types",
    "title": "1  Introducing Zig",
    "section": "1.4 Primitive Data Types",
    "text": "1.4 Primitive Data Types\nZig have many different primitive data types available for you to use. You can see the full list of available data types at the Language Reference page2.\nBut here is a quick list:\n\nUnsigned integers: u8, 8-bit integer; u16, 16-bit integer; u32, 32-bit integer; u64, 64-bit integer; u128, 128-bit integer.\nSigned integers: i8, 8-bit integer; i16, 16-bit integer; i32, 32-bit integer; i64, 64-bit integer; i128, 128-bit integer.\nFloat number: f16, 16-bit floating point; f32, 32-bit floating point; f64, 64-bit floating point; f128, 128-bit floating point;\nBoolean: bool, represents true or false values.\nC ABI compatible types: c_long, c_char, c_short, c_ushort, c_int, c_uint, and many others.\nPointer sized integers: isize and usize.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-arrays",
    "href": "Chapters/01-zig-weird.html#sec-arrays",
    "title": "1  Introducing Zig",
    "section": "1.5 Arrays",
    "text": "1.5 Arrays\nYou create arrays in Zig by using a syntax that resembles the C syntax. First, you specify the size of the array (i.e. the number of elements that will be stored in the array) you want to create inside a pair of brackets.\nThen, you specify the data type of the elements that will be stored inside this array. All elements present in an array in Zig must have the same data type. For example, you cannot mix elements of type f32 with elements of type i32 in the same array.\nAfter that, you simply list the values that you want to store in this array inside a pair of curly braces. In the example below, I am creating two constant objets that contain different arrays. The first object contains an array of 4 integer values, while the second object, an array of 3 floating point values.\nNow, you should notice that in the object ls, I am not explicitly specifying the size of the array inside of the brackets. Instead of using a literal value (like the value 4 that I used in the ns object), I am using the special character underscore (_). This syntax tells the zig compiler to fill this field with the number of elements listed inside of the curly braces. So, this syntax [_] is for lazy (or smart) programmers who leave the job of counting how many elements there are in the curly braces for the compiler.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst ls = [_]f64{432.1, 87.2, 900.05};\n_ = ns; _ = ls;\n\n\n1.5.1 Selecting elements of the array\nOne very commom activity is to select specific portions of an array you have in your source code. In Zig, you can select a specific element from your array, by simply providing the index of this particular element inside brackets after the object name. In the example below, I am selecting the third element from the ns array. Notice that Zig is a “zero-index” based language, like C, C++, Rust, Python, and many other languages.\n\nconst ns = [4]u8{48, 24, 12, 6};\ntry stdout.print(\"{d}\\n\", .{ ns[2] });\n\n12\n\n\nIn contrast, you can also select specific slices (or sections) of your array, by using a range selector. Some programmers also call these selectors of “slice selectors”, and they also exist in Rust, and have the exact same syntax as in Zig. Anyway, a range selector is a special expression in Zig that defines a range of indexes, and it have the syntax start..end.\nIn the example below, at the second line of code, the sl object stores a slice (or a portion) of the ns array. More precisely, the elements at index 1 and 2 in the ns array.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..3];\n_ = sl;\n\nWhen you use the start..end syntax, the “end tail” of the range selector is non-inclusive, meaning that, the index at the end is not included in the range that is selected from the array. Therefore, the syntax start..end actually means start..end - 1 in practice.\nYou can also use the syntax start.. in your range selector. Which tells the zig compiler to select the portion of the array that begins at the start index until the last element of the array. In the example below, we are selecting the range from index 1 until the end of the array.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..];\n_ = sl;\n\n\n\n1.5.2 More on slices\nAs we discussed before, in Zig, you can select specific portions of an existing array. This is called slicing in Zig (Sobeston 2024), because when you select a portion of an array, you are creating a slice object from that array.\nA slice object is essentially a pointer object accompained by a length number. The pointer object points to the first element in the slice, and the length number tells the zig compiler how many elements there are in this slice.\n\nSlices can be thought of as a pair of [*]T (the pointer to the data) and a usize (the element count) (Sobeston 2024).\n\nThrough the pointer contained inside the slice you can access the elements (or values) that are inside this range (or portion) that you selected from the original array. But the length number (which you can access through the len property of your slice object) is the really big improvement (over C arrays for example) that Zig brings to the table here.\nBecause with this length number the zig compiler can easily check if you are trying to access an index that is out of the bounds of this particular slice, or, if you are causing any buffer overflow problems. In the example below, we access the len property of the slice sl, which tells us that this slice have 2 elements in it.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..3];\ntry stdout.print(\"{d}\\n\", .{sl.len});\n\n2",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#control-flow",
    "href": "Chapters/01-zig-weird.html#control-flow",
    "title": "1  Introducing Zig",
    "section": "1.6 Control flow",
    "text": "1.6 Control flow\nSometimes, you need to make decisions in your program. Maybe you need to decide wether to execute or not a specific piece of code. Or maybe, you need to apply the same operation over a sequence of values. These kinds of tasks, involve using structures that are capable of changing the “control flow” of our program.\nIn computer science, the term “control flow” usually refers to the order in which expressions (or commands) are evaluated in a given language or program. But this term is also used to refer to structures that are capable of changing this “evaluation order” of the commands executed by a given language/program.\nThese structures are better known by a set of terms, such as: loops, if/else statements, switch statements, among others. So, loops and if/else statements are examples of structures that can change the “control flow” of our program. The keywords continue and break are also examples of symbols that can change the order of evaluation, since they can move our program to the next iteration of a loop, or make the loop stop completely.\n\n1.6.1 If/else statements\nAn if/else statement performs an “conditional flow operation”. A conditional flow control (or choice control) allows you to execute or ignore a certain block of commands based on a logical condition. Many programmers and computer science professionals also use the term “branching” in this case. In essence, we use if/else statements to use the result of a logical test to decide whether or not to execute a given block of commands.\nIn Zig, we write if/else statements by using the keywords if and else. We start with the if keyword followed by a logical test inside a pair of parentheses, and then, a pair of curly braces with contains the lines of code to be executed in case the logical test returns the value true.\nAfter that, you can optionally add an else statement. Just add the else keyword followed by a pair of curly braces, with the lines of code to executed in case the logical test defined in the if returns false.\nIn the example below, we are testing if the object x contains a number that is greater than 10. Judging by the output printed to the console, we know that this logical test returned false. Because the output in the console is compatible with the line of code present in the else branch of the if/else statement.\n\nconst x = 5;\nif (x &gt; 10) {\n    try stdout.print(\n        \"x &gt; 10!\\n\", .{}\n    );\n} else {\n    try stdout.print(\n        \"x &lt;= 10!\\n\", .{}\n    );\n}\n\nx &lt;= 10!\n\n\n\n\n1.6.2 For loops\nA loop allows you to execute the same lines of code multiple times, thus, creating a “repetition space” in the execution flow of your program. Loops are particularly useful when we want to replicate the same function (or the same set of commands) over several different inputs.\nThere are different types of loops available in Zig. But the most essential of them all is probably the for loop. A for loop is used to apply the same piece of code over the elements of a slice or an array.\nFor loops in Zig have a slightly different syntax that you are probably used to see in other languages. You start with the for keyword, then, you list the items that you want to iterate over inside a pair of parentheses. Then, inside of a pair of pipes (|) you should declare an identifier that will serve as your iterator, or, the “repetition index of the loop”.\n\nfor (items) |value| {\n    // code to execute\n}\n\nThat is, instead of using a (value in items) syntax, in Zig, for loops use the syntax (items) |value|. In the example below, you can see that we are looping through the items of the array stored in the object name, and printing to the console the decimal representation of each character in this array.\nIf we wanted, we could also iterate through a slice (or a portion) of the array, instead of iterating through the entire array stored in the name object. Just use a range selector to select the section you want. For example, I could provide the expression name[0..2] to the for loop, to iterate just through the first 3 elements in the array.\n\nconst name = [_]u8{'P','e','d','r','o'};\nfor (name) |char| {\n    try stdout.print(\n        \"{d} | \", .{char}\n    );\n}\n\n80 | 101 | 100 | 114 | 111 | \n\n\nIn the above example we are using the value itself of each element in the array as our iterator. But there are many situations where we need to use an index instead of the actual values of the items.\nYou can do that by providing a second set of items to iterate over. More precisely, you provide the range selector 0.. to the for loop. So, yes, you can use two different iterators at the same time in a for loop in Zig.\nBut remember from Section 1.3 that, every object you create in Zig must be used in some way. So if you declare two iterators in your for loop, you must use both iterators inside the for loop body. But if you want to use just the index iterator, and not use the “value iterator”, then, you can discard the value iterator by maching the value items to the underscore character, like in the example below:\n\nfor (name, 0..) |_, i| {\n    try stdout.print(\"{d} | \", .{i});\n}\n\n0 | 1 | 2 | 3 | 4 |\n\n\n1.6.3 While loops\nA while loop is created from the while keyword. While a for loop iterates through the items of an array, a while loop will loop continuously, and infinitely, until a logical test (specified by you) becomes false.\nYou start with the while keyword, then, you define a logical expression inside a pair of parentheses, and the body of the loop is provided inside a pair of curly braces, like in the example below:\n\nvar i: u8 = 1;\nwhile (i &lt; 5) {\n    try stdout.print(\"{d} | \", .{i});\n    i += 1;\n}\n\n1 | 2 | 3 | 4 | \n\n\n\n\n1.6.4 Using break and continue\nIn Zig, you can explicitly stop the execution of a loop, or, jump to the next iteration of the loop, using the keywords break and continue, respectively. The while loop present in the example below, is at first sight, an infinite loop. Because the logical value inside the parenthese will always be equal to true. What makes this while loop stop when the i object reaches the count 10? Is the break keyword!\nInside the while loop, we have an if statement that is constantly checking if the i variable is equal to 10. Since we are increasing the value of this i variable at each iteration of the while loop. At some point, this i variable will be equal to 10, and when it does, the if statement will execute the break expression, and, as a result, the execution of the while loop is stopped.\nNotice the expect() function from the Zig standard library after the while loop. This expect() function is an “assert” type of function. This function checks if the logical test provided is equal to true. If this logical test is false, the function raises an assertion error. But it is equal to true, then, the function will do nothing.\n\nvar i: usize = 0;\nwhile (true) {\n    if (i == 10) {\n        break;\n    }\n    i += 1;\n}\ntry std.testing.expect(i == 10);\ntry stdout.print(\"Everything worked!\", .{});\n\nEverything worked!\n\n\nSince this code example was executed succesfully by the zig compiler, without raising any errors, then, we known that, after the execution of while loop, the i variable is equal to 10. Because if it wasn’t equal to 10, then, an error would be raised by expect().\nNow, in the next example, we have an use case for the continue keyword. The if statement is constantly checking if the current index is a multiple of 2. If it is, then we jump to the next iteration of the loop directly. But it the current index is not a multiple of 2, then, the loop will simply print this index to the console.\n\nconst ns = [_]u8{1,2,3,4,5,6};\nfor (ns) |i| {\n    if ((i % 2) == 0) {\n        continue;\n    }\n    try stdout.print(\"{d} | \", .{i});\n}\n\n1 | 3 | 5 |",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#structs-and-oop",
    "href": "Chapters/01-zig-weird.html#structs-and-oop",
    "title": "1  Introducing Zig",
    "section": "1.7 Structs and OOP",
    "text": "1.7 Structs and OOP\nZig is a language more closely related to C (which is a procedural language), than it is to C++ or Java (which are object-oriented languages). Because of that, you do not have advanced OOP (Object-Oriented Programming) patterns available in Zig, such as classes, interfaces or class inheritance. Nonetheless, OOP in Zig is still possible by using struct definitions.\nWith struct definitions, you can create (or define) a new data type in Zig. These struct definitions work the same way as they work in C. You give a name to this new struct (or, to this new data type you are creating), then, you list the data members of this new struct. You can also register functions inside this struct, and they become the methods of this particular struct (or data type), so that, every object that you create with this new type, will always have these methods available and associated with them.\nIn C++, when we create a new class, we normally have a constructor method (or, a constructor function) to construct or to instantiate every object of this particular class, and you also have a destructor method (or a destructor function) that is the function responsible for destroying every object of this class.\nIn Zig, we normally declare the constructor and the destructor methods of our structs, by declaring an init() and a deinit() methods inside the struct. This is just a naming convention that you will find across the entire Zig standard library. So, in Zig, the init() method of a struct is normally the constructor method of the class represented by this struct. While the deinit() method is the method used for destroying an existing instance of that struct.\nWe already saw both the init() and deinit() methods being used at Section 2.3.7. In this section, I presented the ArenaAllocator(), which is a special type of allocator object that receives a second (child) of allocator object at instantiation. We used the init() to create a new ArenaAllocator() object, then, on the next line, we also used the deinit() method in conjunction with the defer keyword, to destroy this arena allocator object at the end of the current scope.\nAs an example, let’s build a simple User struct to represent an user of some sort of system. If you look at the User struct below, you can see the struct keyword, and inside of a pair of curly braces, we write the struct’s body.\nNotice the data members of this struct, id, name and email. Every data member have it’s type explicitly annotated, with the colon character (:) syntax that we described earlier at Section 1.2.2. But also notice that every line in the struct body that describes a data member, ends with a comma character (,). So every time you declare a data member in your Zig code, always end the line with a comma character, instead of ending it with the traditional semicolon character (;).\nAlso, notice in this example, that we registrated an init() function as a method of this User struct. This init() method is the constructor method that you use to instantiate every new User object. That is why this init() function return an User object as result.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst User = struct {\n    id: u64,\n    name: []const u8,\n    email: []const u8,\n\n    pub fn init(id: u64,\n                name: []const u8,\n                email: []const u8) User {\n\n        return User {\n            .id = id,\n            .name = name,\n            .email = email\n        };\n    }\n\n    pub fn print_name(self: User) !void {\n        try stdout.print(\"{s}\\n\", .{self.name});\n    }\n};\n\npub fn main() !void {\n    const u = User.init(1, \"pedro\", \"sssemail@gmail.com\");\n    try u.print_name();\n}\n\npedro\n\n\nThe pub keyword plays an important role in struct declarations, and OOP in Zig. Every method that you declare in your struct that is marked with the keyword pub, becomes a public method of this particular struct.\nSo every method that you create in your struct, is, at first, a private method of that struct. Meaning that, this method can only be called from within this struct. But, if you mark this method as public, with the keyword pub, then, you can call the method directly from the User object you have in your code.\nFor example, if I did not marked the print_name() method as public, then, I could not execute the line u.print_name(). Because I would not be authorized to call this method directly in my code.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#anonymous-struct-literals",
    "href": "Chapters/01-zig-weird.html#anonymous-struct-literals",
    "title": "1  Introducing Zig",
    "section": "1.8 Anonymous struct literals",
    "text": "1.8 Anonymous struct literals\nIn traditional struct literals, you can specify the type of the struct literal you are writing just before the opening curly braces. So, I could write a struct literal of type User that we defined in the previous section like this:\n\nconst eu = User {\n    .id = 1,\n    .name = \"Pedro\",\n    .email = \"someemail@gmail.com\"\n};\n_ = eu;\n\nHowever, in Zig, we can also write an anonymous struct literal. That is, you can write a struct literal, but not especify explicitly the type of this particular struct. An anonymous struct is written by using the syntax .{}. So, we essentially replace the explicit type of the struct literal with a dot character (.).\nWhen you do that, the type of this struct literal is automatically inferred by the zig compiler. In essente, the zig compiler will look for some hint of what is the type of that struct. It can be the type annotation of an function argument, or the return type annotation of the function you are using, or the type annotation of a variable. If the compiler do find such type annotation, then, it will use this type in your literal struct.\nAnonymous structs are very commom to use on function arguments. One example that you have seen already constantly, is the print() function from the stdout.\nThis function takes two arguments. The first argument, is a template string, which should contain string format specifiers in it, which tells how the values provided in the second argument should be printed into the message.\nWhile the second argument is a struct literal that contains the values to be printed into the template message specified in the first argument. You normally want to use an anonymous struct literal here, so that, the zig compiler do the job of specifying the type of this particular anonymous struct.\n\nconst std = @import(\"std\");\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n\nHello, world!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-zig-strings",
    "href": "Chapters/01-zig-weird.html#sec-zig-strings",
    "title": "1  Introducing Zig",
    "section": "1.9 How strings work in Zig?",
    "text": "1.9 How strings work in Zig?\nThe first project that we are going to build and discuss in this book is a base64 encoder/decoder (Chapter 3). But in order for us to build such a thing, we need to get a better understanding on how strings work in Zig. So let’s discuss this specific aspect of Zig.\nIn Zig, a string literal (or a string object if you prefer) is a pointer to a null-terminated array of bytes. Each byte in this array is represented by an u8 value, which is an unsigned 8 bit integer, so, it is equivalent to the C data type unsigned char.\nZig always assumes that this sequence of bytes is UTF-8 encoded. This might not be true for every sequence of bytes you have it, but is not really Zig’s job to fix the encoding of your strings (you can use iconv3 for that). Today, most of the text in our modern world, specially on the web, should be UTF-8 encoded. So if your string literal is not UTF-8 encoded, then, you will likely have problems in Zig.\nLet’s take for example the word “Hello”. In UTF-8, this sequence of characters (H, e, l, l, o) is represented by the sequence of decimal numbers 72, 101, 108, 108, 111. In xecadecimal, this sequence is 0x48, 0x65, 0x6C, 0x6C, 0x6F. So if I take this sequence of hexadecimal values, and ask Zig to print this sequence of bytes as a sequence of characters (i.e. a string), then, the text “Hello” will be printed into the terminal:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const bytes = [_]u8{0x48, 0x65, 0x6C, 0x6C, 0x6F};\n    try stdout.print(\"{s}\\n\", .{bytes});\n}\n\nHello\n\n\nIf you want to see the actual bytes that represents a string in Zig, you can use a for loop to iterate trough each byte in the string, and ask Zig to print each byte as an hexadecimal value to the terminal. You do that by using a print() statement with the X formatting specifier, like you would normally do with the printf() function4 in C.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"This is an example of string literal in Zig\";\n    try stdout.print(\"Bytes that represents the string object: \", .{});\n    for (string_literal) |byte| {\n        try stdout.print(\"{X} \", .{byte});\n    }\n    try stdout.print(\"\\n\", .{});\n}\n\nBytes that represents the string object: 54 68 69 \n   73 20 69 73 20 61 6E 20 65 78 61 6D 70 6C 65 20 6F\n  F 66 20 73 74 72 69 6E 67 20 6C 69 74 65 72 61 6C 2\n  20 69 6E 20 5A 69 67 \n\n\n\n1.9.1 Strings in C\nAt first glance, this looks very similar to how C treats strings as well. That is, string values in C are also treated internally as an array of bytes, and this array is also null-terminated.\nBut one key difference between a Zig string and a C string, is that Zig also stores the length of the array inside the string object. This small detail makes your code safer, because is much easier for the Zig compiler to check if you are trying to access an element that is “out of bounds”, i.e. if your trying to access memory that does not belong to you.\nTo achieve this same kind of safety in C, you have to do a lot of work that kind of seems pointless. So getting this kind of safety is not automatic and much harder to do in C. For example, if you want to track the length of your string troughout your program in C, then, you first need to loop through the array of bytes that represents this string, and find the null element ('\\0') position to discover where exactly the array ends, or, in other words, to find how much elements the array of bytes contain.\nTo do that, you would need something like this in C. In this example, the C string stored in the object array is 25 bytes long:\n#include &lt;stdio.h&gt;\nint main() {\n    char* array = \"An example of string in C\";\n    int index = 0;\n    while (1) {\n        if (array[index] == '\\0') {\n            break;\n        }\n        index++;\n    }\n    printf(\"Number of elements in the array: %d\\n\", index);\n}\nNumber of elements in the array: 25\nBut in Zig, you do not have to do this, because the object already contains a len field which stores the length information of the array. As an example, the string_literal object below is 43 bytes long:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"This is an example of string literal in Zig\";\n    try stdout.print(\"{d}\\n\", .{string_literal.len});\n}\n\n43\n\n\n\n\n1.9.2 A better look at the object type\nNow, we can inspect better the type of objects that Zig create. To check the type of any object in Zig, you can use the @TypeOf() function. If we look at the type of the simple_array object below, you will find that this object is a array of 4 elements. Each element is a signed integer of 32 bits which corresponds to the data type i32 in Zig. That is what an object of type [4]i32 is.\nBut if we look closely at the type of the string_literal object below, you will find that this object is a constant pointer (hence the *const annotation) to an array of 43 elements (or 43 bytes). Each element is a single byte (more precisely, an unsigned 8 bit integer - u8), that is why we have the [43:0]u8 portion of the type below. In other words, the string stored inside the string_literal object is 43 bytes long. That is why you have the type *const [43:0]u8 below.\nIn the case of string_literal, it is a constant pointer (*const) because the object string_literal is declared as constant in the source code (in the line const string_literal = ...). So, if we changed that for some reason, if we declare string_literal as a variable object (i.e. var string_literal = ...), then, string_literal would be just a normal pointer to an array of unsigned 8-bit integers (i.e. * [43:0]u8).\nNow, if we create an pointer to the simple_array object, then, we get a constant pointer to an array of 4 elements (*const [4]i32), which is very similar to the type of the string_literal object. This demonstrates that a string object (or a string literal) in Zig is already a pointer to an array.\nJust remember that a “pointer to an array” is different than an “array”. So a string object in Zig is a pointer to an array of bytes, and not simply an array of bytes.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"This is an example of string literal in Zig\";\n    const simple_array = [_]i32{1, 2, 3, 4};\n    try stdout.print(\"Type of array object: {}\", .{@TypeOf(simple_array)});\n    try stdout.print(\n        \"Type of string object: {}\",\n        .{@TypeOf(string_literal)}\n    );\n    try stdout.print(\n        \"Type of a pointer that points to the array object: {}\",\n        .{@TypeOf(&simple_array)}\n    );\n}\n\nType of array object: [4]i32Type of string object:\n  : *const [43:0]u8Type of a pointer that points to t\n  the array object: *const [4]i32\n\n\n\n\n1.9.3 Byte vs unicode points\nIs important to point out that each byte in the array is not necessarily a single character. This fact arises from the difference between a single byte and a single unicode point.\nThe encoding UTF-8 works by assigning a number (which is called a unicode point) to each character in the string. For example, the character “H” is stored in UTF-8 as the decimal number 72. This means that the number 72 is the unicode point for the character “H”. Each possible character that can appear in a UTF-8 encoded string have its own unicode point.\nFor example, the Latin Capital Letter A With Stroke (Ⱥ) is represented by the number (or the unicode point) 570. However, this decimal number (570) is higher than the maximum number stored inside a single byte, which is 255. In other words, the maximum decimal number that can be represented with a single byte is 255. That is why, the unicode point 570 is actually stored inside the computer’s memory as the bytes C8 BA.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"Ⱥ\";\n    try stdout.print(\"Bytes that represents the string object: \", .{});\n    for (string_literal) |char| {\n        try stdout.print(\"{X} \", .{char});\n    }\n}\n\nBytes that represents the string object: C8 BA \n\n\nThis means that to store the character Ⱥ in an UTF-8 encoded string, we need to use two bytes together to represent the number 570. That is why the relationship between bytes and unicode points is not always 1 to 1. Each unicode point is a single character in the string, but not always a single byte corresponds to a single unicode point.\nAll of this means that if you loop trough the elements of a string in Zig, you will be looping through the bytes that represents that string, and not through the characters of that string. In the Ⱥ example above, the for loop needed two iterations (instead of a single iteration) to print the two bytes that represents this Ⱥ letter.\nNow, all english letters (or ASCII letters if you prefer) can be represented by a single byte in UTF-8. As a consequence, if your UTF-8 string contains only english letters (or ASCII letters), then, you are lucky. Because the number of bytes will be equal to the number of characters in that string. In other words, in this specific situation, the relationship between bytes and unicode points is 1 to 1.\nBut on the other side, if your string contains other types of letters… for example, you might be working with text data that contains, chinese, japanese or latin letters, then, the number of bytes necessary to represent your UTF-8 string will likely be much higher than the number of characters in that string.\nIf you need to iterate through the characters of a string, instead of its bytes, then, you can use the std.unicode.Utf8View struct to create an iterator that iterates through the unicode points of your string.\nIn the example below, we loop through the japanese characters “アメリカ”. Each of the four characters in this string is represented by three bytes. But the for loop iterates four times, one iteration for each character/unicode point in this string:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    var utf8 = (\n        (try std.unicode.Utf8View.init(\"アメリカ\"))\n            .iterator()\n    );\n    while (utf8.nextCodepointSlice()) |codepoint| {\n        try stdout.print(\n            \"got codepoint {}\\n\",\n            .{std.fmt.fmtSliceHexUpper(codepoint)}\n        );\n    }\n}\n\ngot codepoint E382A2got codepoint E383A1got codepo\n  oint E383AAgot codepoint E382AB\n\n\n\n\n\n\nSobeston. 2024. “Zig Guide.” https://zig.guide/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#footnotes",
    "href": "Chapters/01-zig-weird.html#footnotes",
    "title": "1  Introducing Zig",
    "section": "",
    "text": "https://ziglang.org/learn/overview/#zig-build-system.↩︎\nhttps://ziglang.org/documentation/master/#Primitive-Types.↩︎\nhttps://www.gnu.org/software/libiconv/↩︎\nhttps://cplusplus.com/reference/cstdio/printf/↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html",
    "href": "Chapters/01-memory.html",
    "title": "2  Memory and Allocators in Zig",
    "section": "",
    "text": "2.1 Introduction\nIn this chapter, we will talk about memory. How does Zig controls memory? What commom tools are used? Are there any important aspect that makes memory different/special in Zig? You will find the answers here.\nEvery computer needs memory. Is by having memory that computers can temporarily store the values/results of your calculations. Without memory, programming languages would never have concepts such as “variables”, or “objects”, to store the values that you generate.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#memory-spaces",
    "href": "Chapters/01-memory.html#memory-spaces",
    "title": "2  Memory and Allocators in Zig",
    "section": "2.2 Memory spaces",
    "text": "2.2 Memory spaces\nEvery object that you create in your Zig source code needs to be stored somewhere, in your computer’s memory. Depending on where and how you define your object, Zig will use a different “memory space”, or a different type of memory to store this object.\nEach type of memory normally serves for different purposes. In Zig, there are 3 types of memory (or 3 different memory spaces) that we care about. They are:\n\nGlobal data register (or the “global data section”);\nStack;\nHeap;\n\n\n2.2.1 Compile-time known versus runtime known\nOne strategy that Zig uses to decide where it will store each object that you declare, is by looking at the value of this particular object. More specifically, by investigating if this value is known at “compile-time” or at “runtime”.\nWhen you write a program in Zig, some values that you write in your program are known at compile time. Meaning that, when you compile your Zig source code, during the compilation process, the zig compiler can figure it out what is the exact value of a particular object (or object) that exists in your source code.\nFor example, in the source code below, we have two constant objects (name and array) declared. Because the values of these particular objects are written down, in the source code itself (\"Pedro\" and the number sequence from 1 to 4), the zig compiler can easily discover the values of these constant objects (name and array) during the compilation process.\nThis is what “known at compile time” means. It refers to any object that you have in your Zig source code whose value can be identified at compile time.\n\nconst name = \"Pedro\";\nconst array = [_]u8{1, 2, 3, 4};\n_ = name; _ = array;\n\nfn input_length(input: []const u8) usize {\n    return input.len;\n}\n\nThe other side of the spectrum are objects whose values are not known at compile time. Function arguments are a classic example of this. Because the value of each function argument depends on the value that you assign to this particular argument, when you call the function.\nFor example, the function input_length() contains an argument named input, which is an array of u8 integers ([]const u8). Is impossible to know at compile time the value of this particular argument. We know that it will be an array of u8 integers. But we can’t know which exact array of u8 integers this argument will store, before we execute this function. The value of input is only known at runtime, which is the period of time when you program is executed. As a consequence, the value of the expression input.len is also known only at runtime.\nSo depending on which input your apply this input_length() function over, the input argument will probably have a different value in each case. Because of this intrinsic characteristic of any function, the value of the argument input is not “compile-time known”. It is known only at runtime.\n\n\n2.2.2 Global data register\nThe global data register is a specific section of the executable of your Zig program, that is responsible for storing any value that is known at compile time.\nEvery constant object whose value is known at compile time that you declare in your source code, is stored in the global data register. Also, every literal value that you write in your source code, such as the string \"this is a string\", or the integer 10, or a boolean value such as true, is also stored in the global data register.\nHonestly, you don’t need to care much about this memory space. Because you can’t control it, you can’t deliberately access it or use it for your own purposes. Also, this memory space does not affect the logic of your program. It simply exists in your program.\n\n\n2.2.3 Stack vs Heap\nIf you are familiar with system’s programming, or just low-level programming in general, you probably have heard of the “duel” between Stack vs Heap. These are two different types of memory, or different memory spaces, which are both available in Zig.\nThese two types of memory don’t actually duel with each other. This is a commom mistake that beginners have, when seeing “x vs y” styles of tabloid headlines. These two types of memory are actually complementary to each other. So, in almost every Zig program that you ever write, you will likely use a combination of both. I will describe each memory space in detail over the next sections. But for now, I just want to stablish the main difference between these two types of memory.\nIn essence, the stack memory is normally used to store values whose length is fixed and known at compile time. In contrast, the heap memory is a dynamic type of memory space, meaning that, it is used to store values whose length might grow during the execution (runtime) of your program (Chen and Guo 2022).\nLengths that grow during runtime are intrinsically associated with “runtime known” type of values. In other words, if you have an object whose length might grow during runtime, then, the length of this object becomes not known at compile time. If the length is not known at compile-time, the value of this object also becomes not known at compile-time. These types of objects should be stored in the heap memory space, which is a dynamic memory space, which can grow or shrink to fit the size of your objects.\n\n\n2.2.4 Stack\nThe stack is a type of memory that uses the power of the stack data structure, hence the name. A “stack” is a type of data structure that uses a “last in, first out” (LIFO) mechanism to store the values you give it to. I imagine you are familiar with this data structure. But, if you are not, the Wikipedia page1 , or, the Geeks For Geeks page2 are both excellent and easy resources to fully understand how this data structure works.\nSo, the stack memory space is a type of memory that stores values using a stack data structure. It adds and removes values from the memory by following a “last in, first out” (LIFO) principle.\nEvery time you make a function call in Zig, an amount of space in the stack is reserved for this particular function call (Chen and Guo 2022; Zig Foundation 2024). The value of each function argument given to the function in this function call is stored in this stack space. Also, every local object that you declare inside the function scope are usually stored in this same stack space.\nLooking at the example below, the object result is a local object declared inside the scope of the add() function. Because of that, this object is stored inside the stack space reserved for the add() function. The r object (which is declared outside of the add() function scope) is also stored in the stack. But since it is declared in the “outer” scope, this object is stored in the stack space that belongs to this outer scope.\n\nconst r = add(5, 27);\n_ = r;\n\nfn add(x: u8, y: u8) u8 {\n    const result = x + y;\n    return result;\n}\n\nSo, any object that you declare inside the scope of a function is always stored inside the space that was reserved for that particular function in the stack memory. This also counts for any object declared inside the scope of your main() function for example. As you would expect, in this case, they are stored inside the stack space reserved for the main() function.\nOne very important detail about the stack memory is that it frees itself automatically. This is very important, remember that. When objects are stored in the stack memory, you don’t have the work (or the responsibility) of freeing/destroying these objects. Because they will be automatically destroyed once the stack space is freed at the end of the function scope.\nSo, once the function call returns (or ends, if you prefer to call it this way) the space that was reserved in the stack is destroyed, and all of the objects that were in that space goes away with it. This mechanism exists because this space, and the objects within it, are not necessary anymore, since the function “finished it’s business”. Using the add() function that we exposed above as an example, it means that the object result is automatically destroyed once the function returns.\n\n\n\n\n\n\nImportant\n\n\n\nLocal objects that are stored in the stack space of a function are automatically freed/destroyed at the end of the function scope.\n\n\nThis same logic applies to any other special structure in Zig that have it’s own scope by surrounding it with curly braces ({}). For loops, while loops, if else statements, etc. For example, if you declare any local object in the scope of a for loop, this local object is accessible only within the scope of this particular for loop. Because once the scope of this for loop ends, the space in the stack reserved for this for loop is freed. The example below demonstrates this idea.\n\n// This does not compile!\nconst a = [_]u8{0, 1, 2, 3, 4};\nfor (0..a.len) |i| {\n    const index = i;\n    _ = index;\n}\n// Trying to use an object that was\n// declared in the for loop scope,\n// and that does not exist anymore.\nstd.debug.print(\"{d}\\n\", index);\n\nOne important consequence of this mechanism is that, once the function returns, you can no longer access any memory address that was inside the space in the stack reserved for this particular function. Because this space was destroyed. This means that, if this local object is stored in the stack, you cannot make a function that returns a pointer to this object.\nThink about that for a second. If all local objects in the stack are destroyed at the end of the function scope, why would you even consider returning a pointer to one of these objects? This pointer is at best, invalid, or, more likely, “undefined”.\nConclusion, is totally fine to write a function that returns the local object itself as result, because then, you return the value of that object as the result. But, if this local object is stored in the stack, you should never write a function that returns a pointer to this local object. Because the memory address pointed by the pointer no longer exists.\nSo, using again the add() function as an example, if you rewrite this function so that it returns a pointer to the local object result, the zig compiler will actually compile you program, with no warnings or erros. At first glance, it looks that this is good code that works as expected. But this is a lie!\nIf you try to take a look at the value inside of the r object, or, if you try to use this r object in another expression or function call, then, you would have undefined behaviour, and major bugs in your program (Zig Foundation 2024, see “Lifetime and Ownership”3 and “Undefined Behaviour”4 sections).\n\n// This code compiles succesfully. But it has\n// undefined behaviour. Never do this!!!\n\n// The `r` object is undefined!\nconst r = add(5, 27);\n_ = r;\n\nfn add(x: u8, y: u8) *const u8 {\n    const result = x + y;\n    return &result;\n}\n\nThis “invalid pointer to stack variable” problem is very known across many programming language communities. If you try to do the same thing, for example, in a C or C++ program (i.e. returning an address to a local object stored in the stack), you would also get undefined behaviour in the program.\n\n\n\n\n\n\nImportant\n\n\n\nIf a local object in your function is stored in the stack, you should never return a pointer to this local object from the function. Because this pointer will always become undefined after the function returns, since the stack space of the function is destroyed at the end of it’s scope.\n\n\nBut what if you really need to use this local object in some way after your function returns? How can you do this? The answer is: “in the same you would do if this was a C or C++ program. By returning an address to an object stored in the heap”. The heap memory have a much more flexible lifecycle, and allows you to get a valid pointer to a local object of a function that already returned from it’s scope.\n\n\n2.2.5 Heap\nWhile the stack accepts only objects whose length is known at compile-time, the heap is a much more dynamic (and flexible) type of memory. It is the perfect type of memory to use on objects whose size/length might grow during the execution of your program.\nVirtually any application that behaves as a server is a classic use case of the heap. A HTTP server, a SSH server, a DNS server, a LSP server, … any type of server. In summary, a server is a type of application that runs for long periods of time, and that serves (or “deals with”) any incoming request that reaches this particular server.\nThe heap is a good choice for this type of system, mainly because the server does not know upfront how many requests it will receive from users, while it is active. It could be one single request, or, 5 thousand requests, or, it could also be zero requests. The server needs to have the ability to allocate and manage it’s memory according to how many requests it receives.\nAnother key difference between the stack and the heap, is that the heap is a type of memory that you, the programmer, have complete control over. This makes the heap a more flexible type of memory, but it also makes it harder to work with it. Because you, the programmer, is responsible for managing everything related to it. Including where the memory is allocated, how much memory is allocated, and where this memory is freed.\n\nUnlike stack memory, heap memory is allocated explicitly by programmers and it won’t be deallocated until it is explicitly freed (Chen and Guo 2022).\n\nTo store an object in the heap, you, the programmer, needs to explicitly tells Zig to do so, by using an allocator to allocate some space in the heap. At Section 2.3, I will present how you can use allocators to allocate memory in Zig.\n\n\n\n\n\n\nImportant\n\n\n\nEvery memory you allocate in the heap needs to be explicitly freed by you, the programmer.\n\n\nThe majority of allocators in Zig do allocate memory on the heap. But some exceptions to this rule are ArenaAllocator() and FixedBufferAllocator(). The ArenaAllocator() is a special type of allocator that works in conjunction with a second type of allocator. On the other side, the FixedBufferAllocator() is an allocator that works based on buffer objects created on the stack. This means that the FixedBufferAllocator() makes allocations only on the stack.\n\n\n2.2.6 Summary\nAfter discussing all of these boring details, we can quickly recap what we learned. In summary, the Zig compiler will use the following rules to decide where each object you declare is stored:\n\nevery literal value (such as \"this is string\", 10, or true) is stored in the global data section.\nevery constant object (const) whose value is known at compile-time is also stored in the global data section.\nevery object (constant or not) whose value is not known at compile time is, at first glance, stored in the stack space for the current scope.\nif an object is created with the method alloc() or create() of an allocator object, this object is stored in the memory space used by this particular allocator object. Most of allocators available in Zig use the heap memory, so, this object is likely stored in the heap (FixedBufferAllocator() is an exception to that).\nthe heap can only accessed through allocators. If your object were not created through the alloc() or create() methods of an allocator object, then, it he is most certainly not an object stored in the heap.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#sec-allocators",
    "href": "Chapters/01-memory.html#sec-allocators",
    "title": "2  Memory and Allocators in Zig",
    "section": "2.3 Allocators",
    "text": "2.3 Allocators\nOne key aspect about Zig, is that there are “no hidden-memory allocations” in Zig. What that really means, is that “no allocations happen behind your back in the standard library” (Sobeston 2024).\nThis is a known problem, specially in C++. Because in C++, there are some operators that do allocate memory behind the scene, and there is no way for you to known that, until you actually read the source code of these operators, and find the memory allocation calls. Many programmers find this behaviour annoying and hard to keep track of.\nBut, in Zig, if a function, an operator, or anything from the standard library needs to allocate some memory during it’s execution, then, this function/operator needs to receive (as input) an allocator provided by the user, to actually be able to allocate the memory it needs.\nThis creates a clear distinction between functions that “do not” from those that “actually do” allocate memory. Just look at the arguments of this function. If a function, or operator, have an allocator object as one of it’s inputs/arguments, then, you know for sure that this function/operator will allocate some memory during it’s execution.\nAn example is the allocPrint() function from the Zig standard library. With this function, you can write a new string using format specifiers. So, this function is, for example, very similar to the function sprintf() in C. In order to write such new string, the allocPrint() function needs to allocate some memory to store the output string.\nThat is why, the first argument of this function is an allocator object that you, the user/programmer, gives as input to the function. In the example below, I am using the GeneralPurposeAllocator() as my allocator object. But I could easily use any other type of allocator object from the Zig standard library.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nconst name = \"Pedro\";\nconst output = try std.fmt.allocPrint(\n    allocator,\n    \"Hello {s}!!!\",\n    .{name}\n);\ntry stdout.print(\"{s}\\n\", .{output});\n\nHello Pedro!!!\n\n\nYou get a lot of control over where and how much memory this function can allocate. Because it is you, the user/programmer, that provides the allocator for the function to use. This makes “total control” over memory management easier to achieve in Zig.\n\n2.3.1 What are allocators?\nAllocators in Zig are objects that you can use to allocate memory for your program. They are similar to the memory allocating functions in C, like malloc() and calloc(). So, if you need to use more memory than you initially have, during the execution of your program, you can simply ask for more memory using an allocator.\nZig offers different types of allocators, and they are usually available through the std.heap module of the standard library. So, just import the Zig standard library into your Zig module (with @import(\"std\")), and you can start using these allocators in your code.\nFurthermore, every allocator object is built on top of the Allocator interface in Zig. This means that, every allocator object you find in Zig must have the methods alloc(), create(), free() and destroy(). So, you can change the type of allocator you are using, but you don’t need to change the function calls to the methods that do the memory allocation (and the free memory operations) for your program.\n\n\n2.3.2 Why you need an allocator?\nAs we described at Section 2.2.4, everytime you make a function call in Zig, a space in the stack is reserved for this function call. But the stack have a key limitation which is: every object stored in the stack have a known fixed length.\nBut in reality, there are two very commom instances where this “fixed length limitation” of the stack is a deal braker:\n\nthe objects that you create inside your function might grow in size during the execution of the function.\nsometimes, it is impossible to know upfront how many inputs you will receive, or how big this input will be.\n\nAlso, there is another instance where you might want to use an allocator, which is when you want to write a function that returns a pointer to a local object. As I described at Section 2.2.4, you cannot do that if this local object is stored in the stack. However, if this object is stored in the heap, then, you can return a pointer to this object at the end of the function. Because you (the programmer) control the lyfetime of any heap memory that you allocate. You decide when this memory get’s destroyed/freed.\nThese are commom situations where the stack is not good for. That is why you need a different memory management strategy to store these objects inside your function. You need to use a memory type that can grow together with your objects, or that you can control the lyfetime of this memory. The heap fit this description.\nAllocating memory on the heap is commonly known as dynamic memory management. As the objects you create grow in size during the execution of your program, you grow the amount of memory you have by allocating more memory in the heap to store these objects. And you that in Zig, by using an allocator object.\n\n\n2.3.3 The different types of allocators\nAt the moment of the writing of this book, in Zig, we have 6 different allocators available in the standard library:\n\nGeneralPurposeAllocator().\npage_allocator().\nFixedBufferAllocator() and ThreadSafeFixedBufferAllocator().\nArenaAllocator().\nc_allocator() (requires you to link to libc).\n\nEach allocator have it’s own perks and limitations. All allocators, except FixedBufferAllocator() and ArenaAllocator(), are allocators that use the heap memory. So any memory that you allocate with these allocators, will be placed in the heap.\n\n\n2.3.4 General-purpose allocators\nThe GeneralPurposeAllocator(), as the name suggests, is a “general purpose” allocator. You can use it for every type of task. In the example below, I’m allocating enough space to store a single integer in the object some_number.\n\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const some_number = try allocator.create(u32);\n    defer allocator.destroy(some_number);\n\n    some_number.* = @as(u32, 45);\n}\n\nWhile useful, you might want to use the c_allocator(), which is a alias to the C standard allocator malloc(). So, yes, you can use malloc() in Zig if you want to. Just use the c_allocator() from the Zig standard library. However, if you do use c_allocator(), you must link to Libc when compiling your source code with the zig compiler, by including the flag -lc in your compilation process. If you do not link your source code to Libc, Zig will not be able to find the malloc() implementation in your system.\n\n\n2.3.5 Page allocator\nThe page_allocator() is an allocator that allocates full pages of memory in the heap. In other words, every time you allocate memory with page_allocator(), a full page of memory in the heap is allocated, instead of just a small piece of it.\nThe size of this page depends on the system you are using. Most systems use a page size of 4KB in the heap, so, that is the amount of memory that is normally allocated in each call by page_allocator(). That is why, page_allocator() is considered a fast, but also “wasteful” allocator in Zig. Because it allocates a big amount of memory in each call, and you most likely will not need that much memory in your program.\n\n\n2.3.6 Buffer allocators\nThe FixedBufferAllocator() and ThreadSafeFixedBufferAllocator() are allocator objects that work with a fixed sized buffer that is stored in the stack. So these two allocators only allocates memory in the stack. This also means that, in order to use these allocators, you must first create a buffer object, and then, give this buffer as an input to these allocators.\nIn the example below, I am creating a buffer object that is 10 elements long. Notice that I give this buffer object to the FixedBufferAllocator() constructor. Now, because this buffer object is 10 elements long, this means that I am limited to this space. I cannot allocate more than 10 elements with this allocator object. If I try to allocate more than that, the alloc() method will return an OutOfMemory error value.\n\nvar buffer: [10]u8 = undefined;\nfor (0..buffer.len) |i| {\n    buffer[i] = 0; // Initialize to zero\n}\n\nvar fba = std.heap.FixedBufferAllocator.init(&buffer);\nconst allocator = fba.allocator();\nconst input = try allocator.alloc(u8, 5);\ndefer allocator.free(input);\n\n\n\n2.3.7 Arena allocator\nThe ArenaAllocator() is an allocator object that takes a child allocator as input. The idea behind the ArenaAllocator() in Zig is similar to the concept of “arenas” in the programming language Go5. It is an allocator object that allows you to allocate memory as many times you want, but free all memory only once. In other words, if you have, for example, called 5 times the method alloc() of an ArenaAllocator() object, you can free all the memory you allocated over these 5 calls at once, by simply calling the deinit() method of the same ArenaAllocator() object.\nIf you give, for example, a GeneralPurposeAllocator() object as input to the ArenaAllocator() constructor, like in the example below, then, the allocations you perform with alloc() will actually be made with the underlying object GeneralPurposeAllocator() that was passed. So, with an arena allocator, any new memory you ask for is allocated by the child allocator. The only thing that an arena allocator really do is helping you to free all the memory you allocated multiple times with just a single command. In the example below, I called alloc() 3 times. So, if I did not used an arena allocator, then, I would need to call free() 3 times to free all the allocated memory.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nvar aa = std.heap.ArenaAllocator.init(gpa.allocator());\ndefer aa.deinit();\nconst allocator = aa.allocator();\n\nconst in1 = allocator.alloc(u8, 5);\nconst in2 = allocator.alloc(u8, 10);\nconst in3 = allocator.alloc(u8, 15);\n_ = in1; _ = in2; _ = in3;\n\n\n\n2.3.8 The alloc() and free() methods\nIn the code example below, we are accessing the stdin, which is the standard input channel, to receive an input from the user. We read the input given by the user with the readUntilDelimiterOrEof() method.\nNow, after reading the input of the user, we need to store this input somewhere in our program. That is why I use an allocator in this example. I use it to allocate some amount of memory to store this input given by the user. More specifically, the method alloc() of the allocator object is used to allocate an array capable of storing 50 u8 values.\nNotice that this alloc() method receives two inputs. The first one, is a type. This defines what type of values the allocated array will store. In the example below, we are allocating an array of unsigned 8-bit integers (u8). But you can create an array to store any type of value you want. Next, on the second argument, we define the size of the allocated array, by specifying how much elements this array will contain. In the case below, we are allocating an array of 50 elements.\nAt Section 1.9 we described that strings in Zig are simply arrays of characters. Each character is represented by an u8 value. So, this means that the array that was allocated in the object input is capable of storing a string that is 50-characters long.\nSo, in essence, the expression var input: [50]u8 = undefined would create an array for 50 u8 values in the stack of the current scope. But, you can allocate the same array in the heap by using the expression var input = try allocator.alloc(u8, 50).\n\nconst std = @import(\"std\");\nconst stdin = std.io.getStdIn();\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var input = try allocator.alloc(u8, 50);\n    defer allocator.free(input);\n    for (0..input.len) |i| {\n        input[i] = 0; // initialize all fields to zero.\n    }\n    // read user input\n    const input_reader = stdin.reader();\n    _ = try input_reader.readUntilDelimiterOrEof(\n        input,\n        '\\n'\n    );\n    std.debug.print(\"{s}\\n\", .{input});\n}\n\nAlso, notice that in this example, we use the keyword defer to run a small piece of code at the end of the current scope, which is the expression allocator.free(input). When you execute this expression, the allocator will free the memory that it allocated for the input object.\nWe have talked about this at Section 2.2.5. You should always explicitly free any memory that you allocate using an allocator! You do that by using the free() method of the same allocator object you used to allocate this memory. The defer keyword is used in this example only to help us execute this free operation at the end of the current scope.\n\n\n2.3.9 The create() and destroy() methods\nWith the alloc() and free() methods, you can allocate memory to store multiple elements at once. In other words, with these methods, we always allocate an array to store multiple elements at once. But what if you need enough space to store just a single item? Should you allocate an array of a single element through alloc()?\nThe answer is no! In this case, you should use the create() method of the allocator object. Every allocator object offers the create() and destroy() methods, which are used to allocate and free memory for a single item, respectively.\nSo, in essence, if you want to allocate memory to store an array of elements, you should use alloc() and free(). But if you need to store just a single item, then, the create() and destroy() methods are ideal for you.\nIn the example below, I’m defining a struct to represent an user of some sort. It could be an user for a game, or a software to manage resources, it doesn’t mater. Notice that I use the create() method this time, to store a single User object in the program. Also notice that I use the destroy() method to free the memory used by this object at the end of the scope.\n\nconst std = @import(\"std\");\nconst User = struct {\n    id: usize,\n    name: []const u8,\n\n    pub fn init(id: usize, name: []const u8) User {\n        return .{ .id = id, .name = name };\n    }\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const user = try allocator.create(User);\n    defer allocator.destroy(user);\n\n    user.* = User.init(0, \"Pedro\");\n}\n\n\n\n\n\nChen, Jenny, and Ruohao Guo. 2022. “Stack and Heap Memory.” Introduction to Data Structures and Algorithms with C++. https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/.\n\n\nSobeston. 2024. “Zig Guide.” https://zig.guide/.\n\n\nZig Foundation. 2024. “Language Reference.” https://ziglang.org/documentation/master/.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#footnotes",
    "href": "Chapters/01-memory.html#footnotes",
    "title": "2  Memory and Allocators in Zig",
    "section": "",
    "text": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)↩︎\nhttps://www.geeksforgeeks.org/stack-data-structure/↩︎\nhttps://ziglang.org/documentation/master/#Lifetime-and-Ownership↩︎\nhttps://ziglang.org/documentation/master/#Undefined-Behavior↩︎\nhttps://go.dev/src/arena/arena.go↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html",
    "href": "Chapters/01-base64.html",
    "title": "3  Building a base64 encoder/decoder",
    "section": "",
    "text": "3.1 How the base64 algorithm work?\nNow, how exactly the algorithm behind the base64 encoding works? Let’s discuss that. First, I will explain the base64 scale, which is the scale of 64 characters that represents the base64 encoding system.\nAfter that, I explain the algorithm behind a base64 encoder, which is the part of the algorithm that is responsible for encoding messages into the base64 encoding system. Then, after that, I explain the algorithm behind a base64 decoder, which is the part of the algorithm that is responsible for translating base64 messages back into their original meaning.\nIf you are unsure about the differences between an “encoder” and a “decoder”, take a look at Section 3.2.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#how-the-base64-algorithm-work",
    "href": "Chapters/01-base64.html#how-the-base64-algorithm-work",
    "title": "3  Building a base64 encoder/decoder",
    "section": "",
    "text": "3.1.1 The base64 scale\nIn essence, the base64 encoding system is based on a scale that goes from 0 to 64 (hence the name). Each index in this scale is represented by a character (it is a scale of 64 characters). So, in order to convert some binary data, to the base64 encoding, we need to convert each binary number to the corresponding character in this “scale of 64 characters”.\nThe base64 scale starts with all ASCII uppercase letters (A to Z) which represents the first 25 indexes in this scale (0 to 25). After that, we have all ASCII lowercase letters (a to z), which represents the range 26 to 51 in the scale. After that, we have the one digit numbers (0 to 9), which represents the indexes from 52 to 61 in the scale. Finally, the last two indexes in the scale (62 and 63) are represented by the characters + and /, respectively.\nThese are the 64 characters that compose the base64 scale. The equal sign character (=) is not part of the scale itself, but it is a special character in the base64 encoding system. This character is used solely as a suffix, to mark the end of the character sequence, or, to mark the end of meaningful characters in the sequence.\nThe bulletpoints below summarises the base64 scale:\n\nrange 0 to 25 is represented by: ASCII uppercase letters -&gt; [A-Z];\nrange 26 to 51 is represented by: ASCII lowercase letters -&gt; [a-z];\nrange 52 to 61 is represented by: one digit numbers -&gt; [0-9];\nindex 62 and 63 are represented by the characters + and /, respectively;\nthe character = represents the end of meaningful characters in the sequence;\n\nEverytime that the base64 algorithm needs to fill some gap (which always occur at the end of the input string) with a group of 6 bits filled with only zeros (000000), this group is automatically mapped to the character =. Because this group of 6 bits is meaningless, they represent nothing, they are just filling the gap. As a result, the base64 algorithm maps this meaningless group to the character =, which represents the end of meaningful characters in the sequence. This characteristic is explained in more details at Section 3.1.3.\n\n\n3.1.2 Creating the scale as a lookup table\nThe best way to represent this scale in code, is to represent it as a lookup table. Lookup tables are a classic strategy in computer science to speed calculations. The basic idea is to replace a runtime calculation (which can take a long time to be done) by a basic array indexing operation.\nInstead of calculating the results everytime you need them, you calculate all possible results at once, and then, you store them in an array (which behaves lake a “table”). Then, every time that you need to use one of the characters in the base64 scale, instead of using many resources to calculate the exact character to be used, you simply retrieve this character from the array where you stored all the possible characters in the base64 scale. So we retrieve the character that we need directly from memory.\nWe can start building a Zig struct to store our base64 decoder/encoder logic. We start with the Base64 struct below. You can see that, for now, we only have an init() function, to create a new instance of a Base64 object, and, a _char_at() function, which is a “get chat at index …” type of function.\n\nconst Base64 = struct {\n    _table: *const [64]u8,\n\n    pub fn init() Base64 {\n        const upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        const lower = \"abcdefghijklmnopqrstuvwxyz\";\n        const numbers_symb = \"0123456789+/\";\n        return Base64{\n            ._table = upper ++ lower ++ numbers_symb,\n        };\n    }\n\n    pub fn _char_at(self: Base64, index: u8) u8 {\n        return self._table[index];\n    }\n};\n\nIn other words, the _char_at() function is responsible for getting the character in the lookup table (i.e. the _table variable) that corresponds to a particular index in the “base64 scale”. So, in the example below, we know that the character that corresponds to the index 28 in the “base64 scale” is the character “c”.\n\nconst base64 = Base64.init();\ntry stdout.print(\n    \"Character at 28 index: {c}\\n\",\n    .{base64._char_at(28)}\n);\n\nCharacter at 28 index: c\n\n\n3.1.3 A base64 encoder\nThe algorithm behind a base64 encoder usually works on a window of 3 bytes. Because each byte have 8 bits, so, 3 bytes forms a set of \\(8 \\times 3 = 24\\) bits. This is desirable for the base64 algorithm, because 24 bits is divisble by 6, which form a set of 4 groups of 6 bits each.\nSo the base64 algorithm work by converting 3 bytes at a time into 4 characters in the base64 scale. It keeps iterating through the input string, 3 bytes at a time, and converting them into the base64 scale, producing 4 characters per iteration. It keeps iterating, and producing these “new characters” until it hits the end of the input string.\nNow you may think, what if you have a particular string that have a number of bytes that is not divisible by 3? What happens? For example, if you have a string that contains only two characters/bytes, such as “Hi”. How the algorithm behaves in such situation? You find the answer at Figure 3.1. You can see at Figure 3.1 that the string “Hi”, when converted to base64, becomes the string “SGk=”:\n\n\n\n\n\n\nFigure 3.1: The logic behind a base64 encoder\n\n\n\nIn the example of the string “Hi” we have 2 bytes, or, 16 bits in total. So, we lack a full byte (8 bits) to complete the window of 24 bits that the base64 algorithm likes to work on. In essence, everytime that the algorithm does not meet this requirement, it simply add extra zeros until it fills the space that it needs.\nThat is why at Figure 3.1, on the third group after the 6-bit transformation, 2 extra zeros were added to fill the gap in this group, and also, the fourth group (which is the last 6-bit group) is entirely made by zeros that were added by the algorithm.\nSo every time that the base64 algorithm can’t produce a full group of 6 bits, it simply fills the gap in this group with zeros, until it get’s the 6 bits that it needs.\nIs worth mentioning that, everytime that the algorithm produces a group of 6 bits that is entirely composed by these extra zeros added by the algorithm, then, this group of 6 bits is automatically mapped to the character = (equal sign). However, notice that a group of 6-bit entirely made by extra zeros, is different than a group of 6-bit entirely made by zeros.\nIn other words, if the algorithm produces a 6-bit group made by zeros, without needing to include extra-zeros to fill any gap, then, this “group of zeros” is interpreted as is. In binary, the 6-bit group 000000 simply means zero. So, if we give the index zero to the function _char_at(), this zero index is mapped to the first character in the base64 scale, which is “A”.\nSo be aware of this important distinction. A group of “extra-zeros” that are “filling the gap” is different than a group of actual zeros that were calculated by the 6-bit transformation. As an example, if you give the string “0” as input to a base64 encoder, this string is translated into the base64 sequence “MA==”.\nThe character “0” is, in binary, the sequence 001100001. So, with the 6-bit transformation exposed at Figure 3.1, this single character would produce these two 6-bit groups: 001100, 000000. The other two 6-bit groups are entirely made by extra-zeros, and that is why the last two characters in the output sequence (MA==) are ==.\n\n\n3.1.4 A base64 decoder\nThe algorithm behind a base64 decoder is essentially the inverse process of a base64 encoder. A base64 decoder needs to be able to translate base64 messages back into their original meaning, i.e. into the original sequence of binary data.\nA base64 decoder usually works on a window of 4 bytes. Because it wants to convert these 4 bytes back into the original sequence of 3 bytes, that was converted into 4 groups of 6 bits by the base64 encoder. Remember, in a base64 decoder we are essentially reverting the process made by the base64 encoder.\nEach byte in the input string (the base64 encoded string) normally contributes to re-create two different bytes in the output (the original binary data). In other words, each byte that comes out of a base64 decoder is created by transforming merging two different bytes in the input together. You can see this fact at Figure 3.2:\n\n\n\n\n\n\nFigure 3.2: The logic behind a base64 decoder\n\n\n\nThe exact transformations, or, the exact steps applied to each byte from the input to transform them into the bytes in the output, are a bit tricky to visualize in a figure like this. Because of that, I summarized these transformations as “Some bit shifting and additions …”. These transformations will be described in depth later.\nBesides that, if you look again at Figure 3.2, you will notice that the character = was completly ignored in the algorithm. Remember, this is just a special character that marks the end of meaninful characters in the base64 sequence. So, every = character in a base64 encoded sequence should be ignored.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-encode-vs-decode",
    "href": "Chapters/01-base64.html#sec-encode-vs-decode",
    "title": "3  Building a base64 encoder/decoder",
    "section": "3.2 Difference between encode and decode",
    "text": "3.2 Difference between encode and decode\nIf you don’t have any previous experience with base64, you might be confused about what is the differente between “encode” and “decode”. Essentially, the terms “encode” and “decode” here have the exact same meaning as they have in the field of encryption (i.e. they mean the same thing as “encode” and “decode” in hashing algorithms, like the MD5 algorithm).\nSo, “encode” means that we want to encode, or, in other words, we want to translate some message into the base64 encoding system. We want to produce the sequence of base64 characters that represent this original message in the base64 encoding system.\nIn contrast, “decode” represents the inverse process. We want to decode, or, in other words, translate a base64 message back to it’s original content. So, in this process we get a sequence of base64 characters as input, and produce as output, the binary data that is represented by this sequence of base64 characters.\nSo, any base64 library is normally composed by these two parts: 1) the encoder, which is a function that encodes (i.e. it converts) any sequence of binary data into a sequence of base64 characters; 2) the decoder, which is a function that converts a sequence of base64 characters back into the original sequence of binary data.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-base64-length-out",
    "href": "Chapters/01-base64.html#sec-base64-length-out",
    "title": "3  Building a base64 encoder/decoder",
    "section": "3.3 Calculating the size of the output",
    "text": "3.3 Calculating the size of the output\nOne task that we need to do is to calculate how much space we need to reserve for the output, both of the encoder and decoder. This is simple math, and can be done easily in Zig because every array have it’s length (it’s number of bytes) easily accesible by consulting the .len property of the array.\nFor the encoder, the logic is the following: for each 3 bytes that we find in the input, 4 new bytes are created in the output. So, we take the number of bytes in the input, divide it by 3, use a ceiling function, then, we multiply the result by 4. That way, we get the total number of bytes that will be produced by the encoder in it’s output.\nThe _calc_encode_length() function below encapsulates this logic. Notice that we convert the .len property of the array, which is always a integer (more precisely, an usize value), into a floating point number of 64 bits (f64). We do this, because the ceiling function (@ceil()) works only with floating point numbers. So, we convert it so that the division with the number 3.0 results in a floating point number. Then, after the ceiling process, we can convert the result back into an integer value (with the @intFromFloat() function).\n\nfn _calc_encode_length(input: []const u8) u64 {\n    if (input.len &lt; 3) {\n        const n_output: u64 = 4;\n        return n_output;\n    }\n    const len_as_float: f64 = @floatFromInt(input.len);\n    const n_output: u64 = @intFromFloat(@ceil(len_as_float / 3.0) * 4.0);\n    return n_output;\n}\n\nIs important to notice that, when I am using the built-in functions from Zig to convert data types (@floatFromInt() and intFromFloat()), I’m always annotating explicitly the type of the variable that stores the result of these functions. I do that, because these functions need this information. @floatFromInt() needs to know which type of floating point number I want to use in it’s output. Is it f16? f32? f64? etc. The same goes to @intFromFloat().\nAlso, you might have notice that, if the input length is less than 3 bytes, then, the output length of the encoder will be always 4 bytes. This is because the algorithm will always fill the gap in the input with zeroes, until it fits the window of 24 bits that the algorithm likes to work on, as I described at Section 3.1.3. So the output of the algorithm will always be 4 bytes in this specific case.\nNow, for the decoder, we just need to apply the inverse logic: for each 4 bytes in the input, 3 bytes will be produced in the output of the decoder. I mean, this is roughly true, because we also need to take the = character into account, which is always ignored by the decoder, as we described at Section 3.1.4, and, at Figure 3.2. But we can ignore this fact for now, to make things simpler.\nSo, the function _calc_decode_length() summarizes this logic that we described. It is very similar to the function _calc_encode_length(), only the division part is twisted, and also, in the special case where we have less than 4 bytes in the input to work on.\n\nfn _calc_decode_length(input: []const u8) u64 {\n    if (input.len &lt; 4) {\n        const n_output: u64 = 3;\n        return n_output;\n    }\n    const len_as_float: f64 = @floatFromInt(input.len);\n    const n_output: u64 = @intFromFloat(@floor(len_as_float / 4.0) * 3.0);\n    return n_output;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-encoder-logic",
    "href": "Chapters/01-base64.html#sec-encoder-logic",
    "title": "3  Building a base64 encoder/decoder",
    "section": "3.4 Building the encoder logic",
    "text": "3.4 Building the encoder logic\nIn this section, we can start building the logic behind the encode() function, which will be responsible for encoding messages into the base64 encoding system.\nIf you are an anxious person, and you want to see now the full source code of the implementation for this base64 encoder/decoder, you can find it at the Examples folder in the official repository of this book2.\n\n3.4.1 The 6-bit transformation\nThe 6-bit transformation presented at Figure 3.1 is the core part of the base64 encoder algorithm. By understanding how this transformation is made in code, the rest of the algorithm becomes much simpler to comprehend.\nIn essence, this 6-bit transformation is made with the help of bitwise operators. Bitwise operators are essential to any type of low-level operation that is done at the bit-level. For the specific case of the base64 algorithm, the operators bif shift to the left (&lt;&lt;), bit shift to the right (&gt;&gt;), and the bitwise and (&) are used. They are the core solution for the 6-bit transformation.\nWe have 3 different scenarios that we need to account for in this transformation. First, is the perfect scenario, where we have the perfect window of 3 bytes to work on. Second, we have the scenario where we have a window of only two bytes to work with. And last, we have the scenario where we have a window of one single byte.\nIn each of these 3 scenarios, the 6-bit transformation works a bit different. To make the explanation easier, I will use the variable output to refer to the bytes in the output of the base64 encoder, and the variable input to refer to the bytes in the input of the encoder.\nIf you have the perfect window of 3 bytes, these are steps for the 6-bit transformation:\n\noutput[0] is produced by moving the bits from input[0] two positions to the right.\noutput[1] is produced by summing two components. First, take the last two bits from input[0], then, move them four positions to the left. Second, move the bits from input[1] four positions to the right. Sum these two components.\noutput[2] is produced by summing two components. First, take the last four bits from input[1], then, move them two positions to the left. Second, move the bits from input[2] six positions to the right.\noutput[3] is produced by taking the last six bits from input[2].\n\nIf you have a window of 2 bytes, then, the steps 3 and 4, which produces the bytes output[2] and output[3], change a little bit, and they become:\n\noutput[2] is produced by taking the last 4 bits from input[1], then, move them two positions to the left.\noutput[3] is the character '='.\n\nAt last, if you have a window of a single byte, then, the steps 2 to 4, which produces the bytes output[1], output[2] and output[3] change, becoming:\n\noutput[1] is produced by taking the last two bits from input[0], then, move them four positions to the left.\noutput[2] and output[3] are the character =.\n\nIf these bulletpoints were a bit confusing for you, you may find the Table 3.1 more intuitive. This table unifies all this logic into a simple table. Notice that this table also provides the exact expression in Zig that creates the corresponding byte in the output.\n\n\n\nTable 3.1: How the 6-bit transformation translates into code in different window settings.\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nNumber of bytes in the window\nByte index in the output\nIn code\n\n\n\n\n3\n0\ninput[0] &gt;&gt; 2\n\n\n3\n1\n((input[0] & 0x03) &lt;&lt; 4) +\n(input[1] &gt;&gt; 4)\n\n\n3\n2\n((input[1] & 0x0f) &lt;&lt; 2) +\n(input[2] &gt;&gt; 6)\n\n\n3\n3\ninput[2] & 0x3f\n\n\n2\n0\ninput[0] &gt;&gt; 2\n\n\n2\n1\n((input[0] & 0x03) &lt;&lt; 4) +\n(input[1] &gt;&gt; 4)\n\n\n2\n2\n((input[1] & 0x0f) &lt;&lt; 2)\n\n\n2\n3\n'='\n\n\n1\n0\ninput[0] &gt;&gt; 2\n\n\n1\n1\n((input[0] & 0x03) &lt;&lt; 4)\n\n\n1\n2\n'='\n\n\n1\n3\n'='\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.4.2 Bit-shifting in Zig\nBit-shifting in Zig works similarly to bit-shifting in C. All bitwise operators that exists in C are available in Zig. Here, in the base64 encoder algorithm, they are essential to produce the result we want.\nFor those who are not familiar with these operators, they are operators that operates at the bit-level of your values. This means that these operators takes the bits that form the value you have, and change them in some way. This ultimately also changes the value itself, because the binary representation of this value changes.\nLet’s use the first byte in the output of the base64 encoder as an example of what bit-shifting means. This is the easiest byte of the 4 bytes in the output to build. Because we only need to move the bits from the first byte in the input two positions to the right, with the bit shift to the right (&gt;&gt;) operator.\nIf we take the string “Hi” that we used at Figure 3.1 as an example, the first byte in this string is “H”, which is the sequence 01001000 in binary. If we move the bits of this byte, two places to the right, we get the sequence 00010010 as result. This binary sequence is the value 18 in decimal, and also, the value 0x12 in hexadecimal. Notice that the first 6 bits of the first byte in the input were moved to the end of the byte. With this operation, we get the first byte of the ouput, which corresponds to the index in the base64 scale for the first character in the base64 scale.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const input = \"Hi\";\n    var output = [4]u8{0,0,0,0};\n    output[0] = input[0] &gt;&gt; 2;\n    try stdout.print(\"{d}\\n\", .{output[0]});\n}\n\n18\n\n\nIf you recall Figure 3.1, the first byte present in the output should be equivalent to the 6-bit group 010010. Although being visually different, the sequences 010010 and 00010010 are semantically equal. They mean the same thing. They both represent the number 18 in decimal, and the value 0x12 in hexadecimal.\nSo, don’t take the “6-bit group” factor so seriously. We do not need necessarilly to get a 6-bit sequence as result. As long as the meaning of the 8-bit sequence we get is the same of the 6-bit sequence, we are in the clear.\n\n\n3.4.3 Selecting specific bits with the & operator\nIf you comeback to Section 3.4.1, you will see that to produce the second and third bytes in the output, we need to select specific bits from the first and second bytes in the input string. But how can we do that? The answer relies on the bitwise and (&) operator.\nIn summary, the & operator performs a logical conjunction operation between the bits of it’s operands. In more details, the operator & compares each bit of the first operand to the corresponding bit of the second operand. If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0 (Microsoft 2021).\nSo, if we apply this operator to the binary sequences 1000100 and 00001101 the result of this operation is the binary sequence 00000100. Because only at the sixth position in both binary sequences we had a 1 value. So any position where we do not have both binary sequences setted to 1, we get a 0 bit in the resulting binary sequence.\nWe loose information about the original bit values from both sequences in this case. Because we no longer know if this 0 bit in the resulting binary sequence was produced by combining 0 with 0, or 1 with 0, etc.\nAs an example, suppose you have the binary sequence 10010111, which is the number 151 in decimal. How can we get a new binary sequence which contains only the third and fourth bits?\nWe just need to combine this sequence with the sequence 00110000 (is 0x30 in hexadecimal) using the & operator. Notice that only the third and fourth positions in this binary sequence is setted to 1. As a consequence, only the third and fourth values of both binary sequences are potentially preserved in the output. All the remaining positions are setted to zero in the output sequence, which is 00010000 (is the number 16 in decimal).\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const bits = 0b10010111;\n    try stdout.print(\"{d}\\n\", .{bits & 0b00110000});\n}\n\n16\n\n\n\n\n3.4.4 Allocating space for the output\nAs I described at Section 2.2.4, to store a variable in the stack, this variable needs to have a known and fixed length at compile-time. This is a problem for our a base64 encoder/decoder case. Because the size of the output (from both the encoder and decoder) depends directly on the size of the input.\nHaving this in mind, we cannot know at compile time which is the size of the output for both the encoder and decoder. So, if we can’t know the size of the output at compile time, this means that we cannot store in the stack, the output for both the encoder and decoder.\nConsequently, we need to store this output on the heap, and, as I commented at Section 2.2.5, we can only store variables in the heap by using allocator objects. So, one the arguments to both the encode() and decode() functions, needs to be an allocator object, because we know for sure that, at some point inside the body of these functions, we need to allocate space on the heap to store the output of these functions.\nThat is why, both the encode() and decode() functions that I present in this book, have an argument called allocator, which receives a allocator object as input, identified by the type std.mem.Allocator from the Zig standard library.\n\n\n3.4.5 Writing the encode() function\nNow that we have a basic understanding on how the bitwise operators work, and how exactly they help us to achieve the result we want to achieve. We can now encapsulate all the logic that we described at Figure 3.1 and Table 3.1 into a nice function that we can add to our Base64 struct definition, that we started at Section 3.1.2.\nYou can find the encode() function below. Notice that the first argument of this function, is the Base64 struct itself. Therefore, tis argument clearly signals that this function is a method from the Base64 struct.\nBecause the encode() function itself is fairly long, I intentionally ommitted the Base64 struct definition in this source code, just for brevity reasons. So, just remember that this function is a public function (or a public method) from the Base64 struct.\nFurthermore, this encode() function have two other arguments:\n\ninput is the input sequence of characters that you want to encode in base64;\nallocator is an allocator object to use in the necessary memory allocations.\n\nI described everything you need to know about allocator objects at Section 2.3. So, if you are not familiar with them, I highly recommend you to comeback to that section, and read it. By looking at the encode() function, you will see that we use this allocator object to allocate enough memory to store the output of encoding process.\nRemember from Section 2.2.4, that the stack can be used only to store variables that have a compile-time known fixed size. Unfortunately, this is not the case here. The size of the encode() output is tidly related to the size of the input from the user. So, the size of the output is only known at runtime. That is why we use an allocator object, to allocate memory on the heap (which allows objects whose size are runtime-known), and store the output there.\nThe main for loop in the function is responsible for iterating the entire input string. In every iteration, we use a count variable to count how many iterations we had at the moment. When count reaches 3, then, we try to encode the 3 characters (or bytes) that we accumulated until this point in the temporary buffer object (buf).\nAfter encoding these 3 characters and storing the result in the output variable, we reset the count variable to zero, and start to count again on the next iteration of the loop. If the loop hits the end of the string, and, the count variable is less than 3, then, it means that the temporary buffer contains the last 1 or 2 bytes from the input. That is why we have two if statements after the for loop. To deal which each possible case.\n\npub fn encode(self: Base64,\n              allocator: std.mem.Allocator,\n              input: []const u8) ![]u8 {\n\n    if (input.len == 0) {\n        return \"\";\n    }\n\n    const n_out = _calc_encode_length(input);\n    var out = try allocator.alloc(u8, n_out);\n    var buf = [3]u8{ 0, 0, 0 };\n    var count: u8 = 0;\n    var iout: u64 = 0;\n\n    for (input, 0..) |_, i| {\n        buf[count] = input[i];\n        count += 1;\n        if (count == 3) {\n            out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n            out[iout + 1] = self._char_at(\n                ((buf[0] & 0x03) &lt;&lt; 4) + (buf[1] &gt;&gt; 4)\n            );\n            out[iout + 2] = self._char_at(\n                ((buf[1] & 0x0f) &lt;&lt; 2) + (buf[2] &gt;&gt; 6)\n            );\n            out[iout + 3] = self._char_at(buf[2] & 0x3f);\n            iout += 4;\n            count = 0;\n        }\n    }\n\n    if (count == 1) {\n        out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n        out[iout + 1] = self._char_at(\n            (buf[0] & 0x03) &lt;&lt; 4\n        );\n        out[iout + 2] = '=';\n        out[iout + 3] = '=';\n    }\n\n    if (count == 2) {\n        out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n        out[iout + 1] = self._char_at(\n            ((buf[0] & 0x03) &lt;&lt; 4) + (buf[1] &gt;&gt; 4)\n        );\n        out[iout + 2] = self._char_at(\n            (buf[1] & 0x0f) &lt;&lt; 2\n        );\n        out[iout + 3] = '=';\n        iout += 4;\n    }\n\n    return out;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-decoder-logic",
    "href": "Chapters/01-base64.html#sec-decoder-logic",
    "title": "3  Building a base64 encoder/decoder",
    "section": "3.5 Building the decoder logic",
    "text": "3.5 Building the decoder logic\nNow, we can focus on writting the base64 decoder logic. Remember from Figure 3.2 that, a base64 decoder do the inverse process of an encoder. So, all we need to do, is to write a decode() function that performs the inverse process that I exposed at Section 3.4.\n\n3.5.1 Mapping base64 characters to their indexes\nOne thing that we need to do, in order to decode a base64-encoded message, is to calculate the index in the base64 scale of every base64 character that we encounter in the decoder input.\nIn other words, the decoder receives as input, a sequence of base64 characters. We need to translate this sequence of characters into a sequence of indexes. These indexes are the index of each character in the base64 scale. This way, we get the value/byte that was calculated in the 6-bit transformation step of the encoder process.\nThere are probably better ways to calculate this, specially using a “divide and conquer” type of strategy. But for now, I am satisfied with a simple and “brute force” type of strategy. The _char_index() function below contains this strategy.\nWe are essentially looping through the lookup table with the base64 scale, and comparing the character we got with each character in the base64 scale. If these characters match, then, we return the index of this character in the base64 scale as the result.\nNotice that, if the input character is '=', the function returns the index 64, which is “out of range” in the scale. But, as I described at Section 3.1.1, the character '=' does not belong to the base64 scale itself. It is a special and meaningless character in base64.\nAlso notice that this _char_index() function is a method from our Base64 struct, because of the self argument. Again, I ommitted the Base64 struct definition in this example, because of brevity reasons.\n\nfn _char_index(self: Base64, char: u8) u8 {\n    if (char == '=')\n        return 64;\n    var index: u8 = 0;\n    for (0..63) |i| {\n        if (self._char_at(i) == char) {\n            index = i;\n            break;\n        }\n    }\n\n    return index;\n}\n\n\n\n3.5.2 The 6-bit transformation\nOnce again, the core part of the algorithm is the 6-bit transformation. If we understand the necessary steps to perform this transformation, the rest of the algorithm becomes much easier.\nFirst of all, before we actually go to the 6-bit transformation, we need to make sure that we use _char_index() to convert the sequence of base64 characters into a sequence of indexes. So the snippet below will be important for the job to be done. The result of _char_index() will be stored in a temporary buffer, and this temporary buffer is what we are going to use in the 6-bit transformation, instead of the actual input object.\n\nfor (0..input.len) |i| {\n    buf[i] = self._char_index(input[i]);\n}\n\nNow, instead of producing 4 bytes (or 4 characters) as output per each window of 3 characters in the input, a base64 decoder produces 3 bytes (or 3 characters) as output per each window of 4 characters in the input. Once again, is the inverse process.\nSo, the steps to produce the 3 bytes in the output are:\n\noutput[0] is produced by summing two components. First, move the bits from buf[0] two positions to the left. Second, move the bits from buf[1] 4 positions to the right. Then, sum these two components.\noutput[1] is produced by summing two components. First, move the bits from buf[1] four positions to the left. Second, move the bits from buf[2] 2 positions to the right. Then, sum these two components.\noutput[2] is produced by summing two components. First, move the bits from buf[2] six positions to the left. Then, you sum the result with buf[3].\n\nThe Table 3.2 presents how the above steps translate into Zig code:\n\n\n\nTable 3.2: The necessary steps for the 6-transformation in the decode process.\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\nByte index in the output\nIn code\n\n\n\n\n0\n(buf[0] &lt;&lt; 2) + (buf[1] &gt;&gt; 4)\n\n\n1\n(buf[1] &lt;&lt; 4) + (buf[2] &gt;&gt; 2)\n\n\n2\n(buf[2] &lt;&lt; 6) + buf[3]\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.5.3 Writing the decode() function\nThe decode() function below contains the entire decoding process. Notice that, we first calculate the necessary size for the output, with _calc_decode_length(), then, we allocate memory for this output with the allocator object.\nThree temporary variables are created: 1) count, to hold the window count in each iteration of the for loop; 2) iout, to hold the current index in the output; 3) buf, which is the temporary buffer that holds the base64 indexes to be converted through the 6-bit transformation.\nThen, in each iteration of the for loop we fill the temporary buffer with the current window of bytes. When count hits the number 4, then, we have a full window of indexes in buf to be converted, and then, we apply the 6-bit transformation over the temporary buffer.\nNotice that we check if the indexes 2 and 3 in the temporary buffer are the number 64, which, if you recall from Section 3.5.1, is when the _calc_index() function receives a '=' character as input. So, if these indexes are equal to the number 64, the decode() function knows that it can simply ignore these indexes. They are not converted, because, as I described before, the character '=' have no meaning, despite being the end of meaningful characters in the sequence. So we can safely ignore them, when they appear in the sequence.\n\nfn decode(self: Base64,\n          allocator: std.mem.Allocator,\n          input: []const u8) ![]u8 {\n\n    if (input.len == 0) {\n        return \"\";\n    }\n    const n_output = _calc_decode_length(input);\n    var output = try allocator.alloc(u8, n_output);\n    for (output, 0..) |_, i| {\n        output[i] = 0;\n    }\n    var count: u8 = 0;\n    var iout: u64 = 0;\n    var buf = [4]u8{ 0, 0, 0, 0 };\n\n    for (0..input.len) |i| {\n        buf[count] = self._char_index(input[i]);\n        count += 1;\n        if (count == 4) {\n            output[iout] = (buf[0] &lt;&lt; 2) + (buf[1] &gt;&gt; 4);\n            if (buf[2] != 64) {\n                output[iout + 1] = (buf[1] &lt;&lt; 4) + (buf[2] &gt;&gt; 2);\n            }\n            if (buf[3] != 64) {\n                output[iout + 2] = (buf[2] &lt;&lt; 6) + buf[3];\n            }\n            iout += 3;\n            count = 0;\n        }\n    }\n\n    return output;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#the-end-result",
    "href": "Chapters/01-base64.html#the-end-result",
    "title": "3  Building a base64 encoder/decoder",
    "section": "3.6 The end result",
    "text": "3.6 The end result\nNow that we have both decode() and encode() implemented. We have a full functioning base64 encoder/decoder implemented in Zig. Here is an example of use of our Base64 struct with the encode() and decode() methods that we implemented.\n\nvar memory_buffer: [1000]u8 = undefined;\nvar fba = std.heap.FixedBufferAllocator.init(\n    &memory_buffer\n);\nconst allocator = fba.allocator();\n\nconst text = \"Testing some more shit\";\nconst etext = \"VGVzdGluZyBzb21lIG1vcmUgc2hpdA==\";\nconst base64 = Base64.init();\nconst encoded_text = try base64.encode(\n    allocator, text\n);\nconst decoded_text = try base64.decode(\n    allocator, etext\n);\ntry stdout.print(\n    \"Encoded text: {s}\\n\", .{encoded_text}\n);\ntry stdout.print(\n    \"Decoded text: {s}\\n\", .{decoded_text}\n);\n\nEncoded text: VGVzdGluZyBzb21lIG1vcmUgc2hpdA==\nDecoded text: Testing some more shit\nYou can also see the full source code at once, by visiting the official repository of this book3. More precisely inside the Examples folder4.\n\n\n\n\nMicrosoft. 2021. “Bitwise AND Operator: &.” https://learn.microsoft.com/en-us/cpp/cpp/bitwise-and-operator-amp?view=msvc-170.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#footnotes",
    "href": "Chapters/01-base64.html#footnotes",
    "title": "3  Building a base64 encoder/decoder",
    "section": "",
    "text": "Notice that, the character “0” is different than the actual number 0, which is simply zero in binary.↩︎\nhttps://github.com/pedropark99/zig-book/blob/main/Examples/base64/base64_basic.zig.↩︎\nhttps://github.com/pedropark99/zig-book↩︎\nhttps://github.com/pedropark99/zig-book/blob/main/Examples/base64/base64_basic.zig.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Chen, Jenny, and Ruohao Guo. 2022. “Stack and Heap Memory.”\nIntroduction to Data Structures and Algorithms with C++. https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/.\n\n\nMicrosoft. 2021. “Bitwise AND Operator: &.” https://learn.microsoft.com/en-us/cpp/cpp/bitwise-and-operator-amp?view=msvc-170.\n\n\nSobeston. 2024. “Zig Guide.” https://zig.guide/.\n\n\nZig Foundation. 2024. “Language Reference.” https://ziglang.org/documentation/master/.",
    "crumbs": [
      "References"
    ]
  }
]