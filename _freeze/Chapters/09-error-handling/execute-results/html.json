{
  "hash": "99f1999c3a10dad3514e2e400b37bd2e",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n\n# Error handling and unions in Zig {#sec-error-handling}\n\nIn this chapter, I want to discuss how error handling is done in Zig.\nNot every low-level language have an explicit system to handle errors.\nIn C for example, we normally check for errors by looking at the return value of\nthe function calls, and see if there is an \"error status code\" or\na valid value returned from the function.\n\nBut, in Zig, we use a *try catch* pattern to handle errors,\nusing the keywords `try` and `catch`.\nIf you remember of the previous section,\nwe already learned about the `try` keyword at @sec-main-file.\nWe use the `try` keyword whenever the expression that we are executing\nmight return an error.\nBut we still haven't learned about the `catch` keyword yet.\n\n\n## Learning more about errors in Zig\n\nBefore we get into `try` and `catch`, we need to learn more about errors in Zig.\nAn error is an actual value in Zig [@zigoverview]. In other words, they are like any integer (or a string) value that you create in your code.\nYou can pass error values as inputs to functions, and you can cast them into a different type of error, or, a different type of value.\n\nThis have some similarities with exceptions in Python. Because in Python, when an exception happens\nin your program, you can use an `except` block to access this exception value,\nand pass it to functions as an input, like you would do in Zig by passing error values to functions.\n\n\nAlthough they are normal values as any other, you cannot ignore error values in your Zig code. Meaning that, if an error\nvalue appears somewhere in your source code, this error value must be explicitly handled in some way.\nThis also means that you cannot discard error values, by assigning them to a underscore,\nas you would do with normal values and objects.\n\nTake the source code below as an example. Here we are trying to open a file that does not exist\nin my computer, and as a result, an obvious error of `FileNotFound` is returned from the `openFile()`\nfunction. But because I'm assigning the result of this function to an underscore, I end up\ntrying to discard an error value.\n\nThe `zig` compiler detects this mistake, and raises an\nerror telling me that I'm trying to discard an error value.\nIt also adds a note message that suggests the use of `try`,\n`catch` or an if statement to explicitly handle this error value.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst dir = std.fs.cwd();\n_ = dir.openFile(\"doesnt_exist.txt\", .{});\n```\n:::\n\n\n```\nt.zig:8:17: error: error set is discarded\nt.zig:8:17: note: consider using 'try', 'catch', or 'if'\n```\n\n### Returning errors from functions\n\nAs we described at @sec-main-file, when we have a function that might return an error\nvalue, this function normally includes an exclamation mark (`!`) in it's return type\nannotation. The presence of this exclamation mark indicates that this function might\nreturn an error value as result, and, the `zig` compiler forces you to always handle explicitly\nthe case of this function returning an error value.\n\nTake a look at the `print_name()` function below. This function might return an error in the `stdout.print()` function call,\nand, as a consequence, it's return type (`!void`) includes an exclamation mark in it, warning us \nthat this function might fail.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nfn print_name() !void {\n    const stdout = std.getStdOut().writer();\n    try stdout.print(\"My name is Pedro!\", .{});\n}\n```\n:::\n\n\nIn the example above, we are using the exclamation mark, to tell the `zig` compiler\nthat this function might return some error. But which error exactly is returned from\nthis function? For now, we are not specifying a specific error value. We only\nknown for now that some error value (whatever it is) might be returned.\n\nBut in fact, you can (if you want to) specify clearly which exact error values\nmight be returned from your function. There are lot of examples of\nthis in the Zig Standard Library. Take this `fill()` function from\nthe `http.Client` module as an example. This function returns\neither a error value of type `ReadError`, or `void`.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\npub fn fill(conn: *Connection) ReadError!void {\n    // The body of this function ...\n}\n```\n:::\n\n\nThis idea of specifying the exact error values that you expect to be returned\nfrom the function is interesting. Because they automatically become some sort of documentation\nof your function, and also, it allows the `zig` compiler to perform extra checks over\nyour code. Because it can check if there is any other type of error value\nthat is being generated inside your function, and, that it is not being accounted\nfor in this return type annotation.\n\nAnyway, so, you can list the types of errors that can be returned from the function\nby listing them on the left side of the exclamation mark. So the syntax format\nbecome:\n\n```\n<error-value>!<valid-value>\n```\n\n### Error sets\n\nBut what about when we have a single function that might return different types of errors?\nWhen you have such a function, you can list\nall of these different types of errors that can be returned from this function,\nthrough a structure in Zig that we call of *error set*.\n\nAn error set is a special type of an union object.\nIt essentially is an union that contains error values in it.\nNot all programming languages have a notion of an \"union object\".\nBut in summary, an union is just a list of the options that\nan object can be. For example, a union of `x`, `y` and `z`, means that,\nan object of this union can either be a `x`, `y` or a `z` object.\n\nWe are going to talk in more depth about unions later at @sec-unions.\nBut you can write an error set by writing the keyword `error` before\na pair of curly braces, then you list the error values that can be\nreturned from the function inside this pair of curly braces.\n\nTake the `resolvePath()` function below as an example, which comes from the\n`introspect.zig` module of the Zig Standard Library. We can see in the return type annotation, that this\nfunction might return three different types of error values. This is an example\nof an error set.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\npub fn resolvePath(\n    ally: mem.Allocator,\n    p: []const u8,\n) error{\n    OutOfMemory,\n    CurrentWorkingDirectoryUnlinked,\n    Unexpected,\n}![]u8 {\n    // The body of the function ...\n}\n```\n:::\n\n\n\nThis is a valid way of annotating the return value of a Zig function. But, if you navigate through\nthe modules that composes the Zig Standard Library, you will notice that, for the majority of cases,\nthe programmers prefer to give a descriptive name to this error set, and then, use this name (or this \"label\")\nof the error set in the return type annotation, instead of using the error set directly.\n\nWe can see that in the `ReadError` error set that we showed earlier in the `fill()` function,\nwhich is defined in the `http.Client` module.\nSo yes, I presented the `ReadError` as if it was just a standard and single error value, but in fact,\nit is an error set defined in the `http.Client` module, and therefore, it actually represents\na set of different error values that might happen in the `fill()` and other functions.\n\n\nTake a look at the `ReadError` definition reproduced below. Notice that we are grouping all of these\ndifferent error values into a single object, and then, we use this object into the return type annotation of the functions.\nLike the `fill()` function that we showed earlier, or, the `readvDirect()` function from the same module,\nwhich is reproduced below.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\npub const ReadError = error{\n    TlsFailure,\n    TlsAlert,\n    ConnectionTimedOut,\n    ConnectionResetByPeer,\n    UnexpectedReadFailure,\n    EndOfStream,\n};\n// Some lines of code\npub fn readvDirect(\n        conn: *Connection,\n        buffers: []std.posix.iovec\n    ) ReadError!usize {\n    // The body of the function ...\n}\n```\n:::\n\n\nSo, an error set is just a convenient way of grouping a set of\npossible error values into a single object, or a single type of an error value.\n\n\n### Casting error values\n\n\n\n## The *try catch* pattern\n\n\nAs we described on the previous sections, when we say that an expression might\nreturn an error, we are basically referring to an expression that have\na return type in the format `!T`.\nThe `!` indicates that this expression returns either an error value, or a value of type `T`.\n\nAt @sec-main-file, I presented the `try` keyword, and I did tell you which situations we use\nthis keyword. But I actually did not talked yet about what exactly this keyword does to your code,\nor, in other words, I have not explained yet what `try` means in your code.\n\nIn essence, when you use the `try` keyword in an expression, you are telling\nthe `zig` compiler the following: \"Hey! Execute this expression for me,\nand, if this expression return an error, please, return this error for me\nand stop the execution of my program. But if this expression return a valid\nvalue, then, return this value, and move on\".\n\nIf you think about this statement, you can reach to the conclusion that the\n`try` keyword is essentially, a strategy to enter in panic mode, and stop\nthe execution of your program in case an error occurs. That is exactly it.\nWith the `try` keyword, you are telling the `zig` compiler, that stopping the execution\nof your program is the most reasonable strategy to take if an error occurs\nin that particular expression.\n\nOk, now that we understand properly what `try` means, let's discuss `catch` now.\nOne important detail here, is that you can use `try` or `catch` to handle your errors,\nbut you **cannot use `try` and `catch` together**. In other words, `try` and `catch`\nare different and completely separate strategies in the Zig language.\n\nThis is uncommon, and different than what happens in other languages. Most\nprogramming languages that adopts the *try catch* pattern (such as C++, R, Python, Javascript, etc.), normally use\nthese two keywords in conjunction to form the complete logic to\nproperly handle the errors.\nAnyway, Zig tries a different approach in the *try catch* pattern.\n\nSo, we learned already about what `try` do, and we also known that both\n`try` and `catch` should be used alone, separate from each other. But\nwhat exactly `catch` do in Zig? With `catch`, we can construct a\nlogic to handle the error value, in case it happens in the current expression.\n\nTake as example, the code example below. Once again, we go back to the previous\nexample where we were trying to open a file that doesn't exist in my computer,\nbut this time, I use `catch` to actually implement a logic to handle the error, instead of\njust stopping the execution right away.\n\nMore specifically, in this example, I'm using a logger object to record some logs into\nthe system, before I return the error, and stops the execution of the program. For example,\nthis could be some part of the code of a complex system that I do not full control over,\nand I want to record these logs before the program crashes, so that I can debug it latter\n(e.g. maybe I cannot compile the full program, and properly debug it with a debugger. So, these logs might\nbe a valid strategy to surpass this barrier).\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst dir = std.fs.cwd();\nconst file = dir.openFile(\n    \"doesnt_exist.txt\", .{}\n) catch |err| {\n    logger.record_context();\n    logger.log_error(err);\n    return err;\n};\n```\n:::\n\n\n\nTherefore, we use `catch` to create a block of expressions that will handle the error.\nInstead of writing the keyword before the expression that might return the error,\nlike we do with `try`,\nwe write `catch` after the expression. We can open the pair of pipes (`|`),\nwhich captures the error value returned by the expression, and makes\nthis error value in the scope of the `catch` block as the object named `err`.\nIn other words, because I wrote `|err|` in the code, I can access the error value\nreturned by the expression, by using the `err` object.\n\nAlthough this being the most common use of `catch`, you can also use this keyword\nto handle the error in a \"default value\" style. That is, if the expression returns\nan error, we use the default value instead. Otherwise, we use the valid value returned\nby the expression.\n\n\n## Union objects in Zig {#sec-unions}\n\nUnions in Zig are equivalent to [`typing.Union` in Python](https://docs.python.org/3/library/typing.html#typing.Union)[^pyunion]\nfor example. An union object is just a list of possible data types that an object can have.\n\n[^pyunion]: <https://docs.python.org/3/library/typing.html#typing.Union>\n\n\n",
    "supporting": [
      "09-error-handling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}