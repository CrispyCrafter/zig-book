{
  "hash": "3d30aba12057c623891474ada8cc538c",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n\n# Error handling and unions in Zig {#sec-error-handling}\n\nIn this chapter, I want to discuss how error handling is done in Zig.\nNot every low-level language have an explicit system to handle errors.\nIn C for example, we normally check for errors by looking at the return value of\nthe function calls, and see if there is an \"error status code\" or\na valid value returned from the function.\n\nBut, in Zig, we use a *try catch* pattern to handle errors,\nusing the keywords `try` and `catch`.\nIf you remember of the previous section,\nwe already learned about the `try` keyword at @sec-main-file.\nWe use the `try` keyword whenever the expression that we are executing\nmight return an error.\nBut we still haven't learned about the `catch` keyword yet. So let's \nget into business, shall we?\n\n\n## Learning more about errors in Zig\n\nBefore we get into `try` and `catch`, we need to learn more about errors in Zig.\nErrors are values in Zig [@zigoverview]. In other words, they are like any integer (or a string) value that you create in your code.\nYou can pass error values as inputs to functions, and you can cast them into a different error value.\n\n\nAlthough they are normal values as any other, you cannot ignore error values in your code. Meaning that, if an error\nvalue appears somewhere in your source code, this error value must be explicitly handled in some way.\nThis also means that you cannot discard error values, by assigning them to a underscore,\nas you would do with normal values and objects.\n\nTake the source code below as an example. Here we are trying to open a file that does not exist\nin my computer, and as a result, an obvious error of `FileNotFound` is returned from the `openFile()`\nfunction. But because I'm assigning the result of this function to an underscore, I end up\ntrying to discard an error value.\n\nThe `zig` compiler detects this mistake, and raises an\nerror telling me that I'm trying to discard an error value.\nIt also adds a note message that suggests the use of `try`,\n`catch` or an if statement to explicitly handle this error value.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst dir = std.fs.cwd();\n_ = dir.openFile(\"doesnt_exist.txt\", .{});\n```\n:::\n\n\n```\nt.zig:8:17: error: error union is discarded\nt.zig:8:17: note: consider using 'try', 'catch', or 'if'\n```\n\n### Returning errors from functions\n\nAs we described at @sec-main-file, when we have a function that might return an error\nvalue, this function normally includes an exclamation mark (`!`) in it's return type\nannotation. The presence of this exclamation mark indicates that this function might\nreturn an erro value as result, and, as consequence, you should always handle explicitly\nthe case of this function returning an error value.\n\n\nThe `print_name()` function below might return an error in the `stdout.print()` function call,\nand, as a consequence, it's return type `!void` includes an exclamation mark in it, warning us \nthat this function might fail.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nfn print_name() !void {\n    const stdout = std.getStdOut().writer();\n    try stdout.print(\"My name is Pedro!\", .{});\n}\n```\n:::\n\n\nIn the example above, we are using the exclamation mark, to tell the `zig` compiler\nthat this function might return some error. But which error exactly is returned from\nthis function? For now, we are not especifying a specific error value. We only\nknown for now that some error value (whatever it is) might be returned.\n\nBut in fact, you can (if you want to) specify clearly which exact error values\nmight be returned from your function. There are lot of examples of\nthis in the Zig Standard Library. Take this `fill()` function from\nthe `http.Client` module as an example. This function returns\neither a error value of type `ReadError`, or `void`.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\npub fn fill(conn: *Connection) ReadError!void {\n    // The body of this function ...\n}\n```\n:::\n\n\nThis idea of specifying the exact error values that you expect to be returned\nfrom the function is interesting. Because they automatically become a type of documentation\nof your function, and also, it allows the `zig` compiler to perform extra checks over\nyour code. Because it can check if there is any other type of error value\nthat is being generated inside your function, and, that it is not being accounted\nfor in this return type annotation.\n\nAnyway, so, you can list the types of errors that can be returned from the function\nby listing them on the left side of the exclamation mark. So the syntax format\nbecome:\n\n```zig\n<error-value>!<valid-value>\n```\n\n### Error unions\n\nBut what about when we have a single function that might return different types of errors?\nWhen you have such a function, you can list\nall of these different types of errors that can be returned from this function,\nthrough a structure in Zig that we call of *error union*.\n\nAn error union is a literally an union that contains error values in it.\nNot all programming languages have a notion of an union object.\nBut in summary, an union is just a list of the options that\nan object can be. For example, a union of `x`, `y` and `z`, means that,\nan object of this union can either be a `x`, `y` or a `z` object.\n\nWe are going to talk in more depth about unions later.\nBut you can write an error union by writing the keyword `error` before\na pair of curly braces, and you list the error values that can be\nreturned from the function inside this pair of curly braces.\n\nTake the `resolvePath()` function below as an example, which comes from the\n`introspect.zig` module of the Zig Standard Library. We can see in the return type annotation, that this\nfunction might return three different types of error values. This is an example\nof an error union.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\npub fn resolvePath(\n    ally: mem.Allocator,\n    p: []const u8,\n) error{\n    OutOfMemory,\n    CurrentWorkingDirectoryUnlinked,\n    Unexpected,\n    }![]u8 {\n    // The body of the function ...\n}\n```\n:::\n\n\n\nThis is a valid way of annotating the return value of a Zig function. But, if you navigate through\nthe modules that composes the Zig Standard Library, you will notice that, for the majority of cases,\nthe programmers prefer to give a descriptive name to this error union, and then, use this name (or this \"label\")\nof the error union in the return type annotation, instead of using the error union directly.\n\nWe can see that in the `ReadError` error union defined in the `http.Client` module.\nYou can see that, we are grouping all of these errors into a single object, called `ReadError`,\nand then, we use this object into the return type of the function. Like the `fill()` function\nthat we showed ealier, or, the `readvDirect()` function from the same module.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\npub const ReadError = error{\n    TlsFailure,\n    TlsAlert,\n    ConnectionTimedOut,\n    ConnectionResetByPeer,\n    UnexpectedReadFailure,\n    EndOfStream,\n};\n// Some lines of code\npub fn readvDirect(\n        conn: *Connection,\n        buffers: []std.posix.iovec\n    ) ReadError!usize {\n    // The body of the function ...\n}\n```\n:::\n\n\n\n\n## The *try catch* pattern\n\n\nIf you remember of what we learned in this section, when we say that an expression might\nreturn an error, we are basically referring to an expression that have\na return type in the format `!T`.\nThe `!` indicates that this expression returns either an error or a value of type `T`.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst x = 5;\n_ = x;\n```\n:::\n",
    "supporting": [
      "09-error-handling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}