{
  "hash": "479c408d7851be86600377d089ed7d8b",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n\n# Error handling and unions in Zig {#sec-error-handling}\n\nIn this chapter, I want to discuss how error handling is done in Zig.\nNot every low-level language have an explicit system to handle errors.\nIn C for example, we don't have either *try catch* patterns or *exceptions*.\n\nIn C we normally check for errors by looking at the return value of\nthe function calls, and see if there is an \"error status code\" or\na valid value returned from the function.\n\n\n## The *try catch* pattern\n\nIn Zig, we use a *try catch* pattern to handle errors,\nusing the keywords `try` and `catch`.\nWe already learned about the `try` keyword at @sec-main-file.\nWe use the `try` keyword whenever the expression that we are executing\nmight return error.\n\nIf you remember of what we learned in this section, when we say that an expression might\nreturn an error, we are basically referring to an expression that have\na return type in the format `!T`.\nThe `!` indicates that this expression returns either an error or a value of type `T`.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst x = 5;\n_ = x;\n```\n:::\n",
    "supporting": [
      "09-error-handling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}