{
  "hash": "01ba4ec8dc9b3e18c2782d70c9c4562e",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n# Debugging Zig applications\n\nBeing able to debug your programs is essential to any programmer who wants to\ndo serious programming in any language. That is why, in this chapter, we are going to talk about the\navailable strategies and tools to debug applications written in Zig.\n\n\n## Printing debugging\n\nWe begin with the classic and battle-tested *print debugging* strategy.\nThe key advantage that debugging offers you is *visibility*.\nWith debugging, you can easily see what results and objects\nthat are being generated within your functions.\n\nThat is the key essence of *print debugging*. Is to use\nprint expressions to see the values that are being generated by your program,\nand, as a result, get a much better understanding of how your program\nis behaving.\n\nSo, many programmers often resort to the print functions in Zig, such as the `stdout.print()`,\nor, the `std.debug.print()`, to get a better understanding of their programs.\nThis is an known and old strategy that is very simple and effective, and it is better known within\nthe programming community as *print debugging*.\n\nIn Zig, you can print information to the `stdout` channel of your system. First, you\nneed to get access to the `stdout`, by calling the `getStdOut()` method, from\nthe Zig standard library. This method returns a *file descriptor* object,\nand, through this object you can read/write to the `stdout`.\nI recommend you to check out all methods available in this object, by [checking the page in\nthe Zig Standard Library Official Reference for the type `File`](https://ziglang.org/documentation/master/std/#std.fs.File)[^zig-fiile-reference].\n\n[^zig-fiile-reference]: <https://ziglang.org/documentation/master/std/#std.fs.File>.\n\nFor our purpose here, which is to write something to the `stdout`, specially to debug our\nprogram, I recommend you to use the `writer()` method, which gives your a *writer* object.\nThis *writer* object offers some helper methods to write stuff into the file descriptor object\nthat we created earlier. In special, the `print()` method.\n\n\nThe `print()` method from this *writer* object is a \"print formatter\" type of a function.\nIn other words, this method works exactly like the `printf()` function from C,\nor, like `!println()` from Rust.\nIn the first argument of the function, you specify a template string, and,\nin the second argument, you provide a list of values (or objects) that you want to print in your message.\n\nIdeally, the template string in the first argument should contain some format specifier.\nEach format specifier is matched to a value (or object) that you listed in the second argument.\nSo, if you provided 5 different objects in the second argument, then, the template string\nshould contain 5 format specifiers, one for each object provided.\n\nEach format specifier is represented by a single letter, and\nyou provide this format specifier inside a pair of curly braces. So, if you want to format\nyour object as a string, then, you can insert the text `{s}` in your template string.\nHere is a quick list of the most used format specifiers:\n\n- `d`: for printing integers.\n- `f`: for printing floating-point numbers.\n- `c`: for printing characters.\n- `s`: for printing strings.\n- `p`: for printing memory addresses.\n- `x`: for printing hexadecimal values.\n\nThe code example below, gives you an example of use of this `print()` method\nwith the `d` format specifier.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nfn add(x: u8, y: u8) u8 {\n    return x + y;\n}\n\npub fn main() !void {\n    const result = add(34, 16);\n    try stdout.print(\"Result: {d}\", .{result});\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nResult: 50\n```\n\n\n:::\n:::\n\n\nIs important to emphasize that, the `stdout.print()` method, as you would expect,\nprint your template string into the `stdout` channel of your system.\nHowever, you can also print your template string into the `stderr` channel\nif your prefer. All you need to do, is to replace the `stdout.print()`\ncall with the function `std.debug.print()`. Like this:\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nfn add(x: u8, y: u8) u8 {\n    return x + y;\n}\n\npub fn main() !void {\n    const result = add(34, 16);\n    try std.debug.print(\"Result: {d}\", .{result});\n}\n```\n:::\n\n\n```\nResult: 50\n```\n\n\n\n## Debugging through debuggers\n\nAlthough *print debugging* is a valid and very useful strategy,\nmost programmers prefer to use a debugger to debug their programs.\nSince Zig is a low-level language, you can use either GDB (GNU Debugger),\nor LLDB (LLVM Project Debugger) as your debugger.\n\nBoth debuggers can work with Zig code, and it's a matter of taste here.\nYou choose the debugger of your preference, and you work with it.\nIn this book, I will use LLDB as my debugger on the examples.\n\n\n### Compile your source code in Debug mode\n\nIn order to debug your program through a debugger, you must compile\nyour code in Debug mode. Because when you compile your\nsource code in other modes (such as Release), the compiler usually\nstrips out some essential information that is used by the debugger\nto read and track your program.\n\nBy compiling your source code in Debug mode, you ensure that the debugger\nwill find the necessary information in your program to debug it.\nBy default, the compiler uses the Debug mode. So, when you compile your program with the `build-exe`\ncommand (that we exposed at @sec-compile-code), if you don't specify an explicit mode through the `-O` command-line [^oargument]\nargument, then, the compiler will compile your code in Debug mode.\n\n[^oargument]: See <https://ziglang.org/documentation/master/#Debug>.\n\n\n### Let's debug a program\n\nAs an example, let's debug some Zig code, and demonstrate\nhow can we use LLDB to navigate and check the following\npiece of Zig code:\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\n\nfn add_and_increment(a: u8, b: u8) u8 {\n    const sum = a + b;\n    const incremented = sum + 1;\n    return incremented;\n}\n\npub fn main() !void {\n    var n = add_and_increment(2, 3);\n    n = add_and_increment(n, n);\n    try stdout.print(\"Result: {d}!\\n\", .{n});\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nResult: 13!\n```\n\n\n:::\n:::\n\n\nThere is nothing wrong with this program. But it is\na good start for us. First, we need to compile\nthis program with this `zig build-exe` command.\n\nFor this example, suppose that I compiled the above\nZig code into a binary executable called `add_program`.\nNow, we can start LLDB with `add_program`, like this:\n\n```bash\nlldb add_program\n```\n\nFrom now on, LLDB is started, and you can know that I'm\nexecuting LLDB commands by looking at the prefix `(lldb)`.\nIf something is prefixed with `(lldb)`, then you know\nthat it is a LLDB command.\n\nThe first thing I will do, is to set a breakpoint in\nthe `main()` function, by executing `b main`.\nAfter that, I just start the execution of the program\nwith `run`.\n\nYou can see in the output below, that the execution\nstopped at the first line in the function `main()`, as we expected.\nBecause we setted the breakpoint at this function.\n\n```bash\n(lldb) b main\nBreakpoint 1: where = debugging`debug1.main + 22\n    at debug1.zig:11:30, address = 0x00000000010341a6\n(lldb) run\nProcess 8654 launched: 'add_program' (x86_64)\nProcess 8654 stopped\n* thread #1, name = 'add_program',\n    stop reason = breakpoint 1.1\n    frame #0: 0x00000000010341a6\n    add_program`debug1.main at add_program.zig:11:30\n   8   \t}\n   9   \t\n   10  \tpub fn main() !void {\n-> 11  \t    var n = add_and_increment(2, 3);\n   12  \t    n = add_and_increment(n, n);\n   13  \t    try stdout.print(\"Result: {d}!\\n\", .{n});\n   14  \t}\n```\n\n\n\n\n",
    "supporting": [
      "02-debugging_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}