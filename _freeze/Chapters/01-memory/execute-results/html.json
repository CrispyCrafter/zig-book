{
  "hash": "c4b75b1d878bd52f657dcfe6991ccc62",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n# Memory and Allocators in Zig\n\n## Introduction\n\nIn this chapter, we will talk about memory. How does Zig controls memory? What\ncommom tools are used? Are there any important aspect that makes memory\ndifferent/special in Zig? You will find the answers here.\n\nEvery computer needs memory. Is by having memory that computers can temporarily store\nthe values/results of your calculations. Without memory, programming languages would never have\nconcepts such as \"variables\", or \"objects\", to store the values that you generate.\n\n\n## Memory spaces\n\nEvery variable that you create in your Zig source code needs to be stored somewhere,\nin your computer's memory. Depending on where or how you define this variable, Zig\nwill store the value of this variable in a different \"memory space\", or a different\ntype of memory.\n\nEach type of memory normally serves for different purposes, and they live in different \"memory spaces\".\nIn Zig, there are 3 types of memory (or 3 different memory spaces) that we care about. They are:\n\n- Global data register (or the \"global constant data\");\n- Stack;\n- Heap;\n\n### Compile-time known versus runtime known\n\nOne way that Zig decides where exactly to store each variable that you declare, is by looking\nat the value of this particular variable. More specifically, by investigating if this value is\nknown at \"compile-time\" or \"runtime\".\n\nWhen you write a program in Zig, some values that you write in your program are *known\nat compile time*. Meaning that, when you compile your Zig source code, during the compilation process,\nthe `zig` compiler can figure it out what is the exact value of a particular variable (or object)\nthat exists in your source code.\n\nFor example, in the source code below, we have two constant variables (`name` and `array`) declared.\nBecause the values of these particular variables are written down, in the source code itself (`\"Pedro\"`\nand the number sequence from 1 to 4), the `zig` compiler can easily discover the values of these constant\nvariables (`name` and `array`) during the compilation process.\n\n\nThis is what \"known at compile time\" means. It refers to any variable that you have in your Zig source code\nwhose value can be identified at compile time.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst name = \"Pedro\";\nconst array = [_]u8{1, 2, 3, 4};\n_ = name; _ = array;\n\nfn input_length(input: []const u8) usize {\n    return input.len;\n}\n```\n:::\n\n\nThe other side of the spectrum are variables whose values are not known at compile time.\nFunction arguments are a classic example of this. Because the value of each function\nargument depends on the value that you assign to this particular argument,\nwhen you call the function.\n\nFor example, the function `input_length()` contains an argument named `input`, which is an array of `u8` integers (`[]const u8`).\nIs impossible to know at compile time the value of this particular argument. We know that it will be an array of `u8` integers.\nBut we can't know which exact array of `u8` integers this argument will store, before we execute this function.\nIt is only *known at runtime*, which is the period of time when you program is executed.\n\nSo depending on which input your apply this `input_length()` function over, the `input` argument\nwill probably have a different value in each case.\nBecause of this intrinsic characteristic of any function, the value of the argument `input` is not \"compile-time known\".\nIt is known only at runtime.\n\n\n\n### Global data register\n\nThe global data register is a specific section of the executable of your Zig program, that is responsible\nfor storing any value that is known at compile time.\n\nEvery constant variable whose value is known at compile time that you declare in your source code,\nis stored in the global data register. Also, every literal value that you write in your source code,\nsuch as the string `\"this is a string\"`, or the integer `10`, or a boolean value such as `true`,\nis also stored in the global data register.\n\nHonestly, you don't need to care much about this memory space. Because you can't control it,\nyou can't deliberately access it or use it for your own purposes.\nAlso, this memory space does not affect the logic of your program.\nIt simply exists in your program.\n\n\n### Stack vs Heap\n\nIf you are familiar with system's programming, or just low-level programming in general, you\nprobably have heard of the \"duel\" between Stack vs Heap. These are two different types of memory,\nor different memory spaces, which are both available in Zig.\n\nThese two types of memory don't actually duel with\neach other. This is a commom mistake that beginners have, when seeing \"x vs y\" styles of\ntabloid headlines. These two types of memory are actually complementary to each other.\nSo, in almost every Zig program that you might ever write, you will likely use a combination of both.\nI will describe each memory space in detail over the next sections. But for now, I just want to\nstablish the main difference between these two types of memory.\n\nIn essence, the stack memory is normally used to store values whose length is fixed and known\nat compile time. In contrast, the heap memory is a much more *dinamic* type of memory space, meaning that, it is\nused to store values whose length might grow during the execution (runtime) of your program [@jenny2022].\nLengths that grow during runtime are intrinsically \"runtime known\" type of values.\nIn other words, if you have a variable whose length might grow during runtime, then, the length\nof this variable becomes not known at compile time. These types of variables are usually stored\nin the heap memory space.\n\n\n\n### Stack\n\nThe stack memory is a memory space that work by using the power of the *stack data structure*, hence the name. \nA \"stack\" is a type of *data structure* that uses a \"last in, first out\" (LIFO) mechanism to store the values\nyou give it to. I imagine you are familiar with this data structure,\nsince it is such an iconic and popular data structure in computer science.\nBut, if you are not, the [Wikipedia page](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))[^wiki-stack]\n, or, the [Geeks For Geeks page](https://www.geeksforgeeks.org/stack-data-structure/)[^geek-stack] are both\nexcellent and easy resources to fully understand how this data structure works.\n\n[^wiki-stack]: <https://en.wikipedia.org/wiki/Stack_(abstract_data_type)>\n[^geek-stack]: <https://www.geeksforgeeks.org/stack-data-structure/>\n\n\nSo, the stack memory space is a type of memory that stores values using a stack data structure.\nIt adds and removes values from the memory by following a \"last in, first out\" (LIFO) principle.\n\nIn general, the local variables that you declare inside any function scope in your\nZig source code are normally stored in the stack memory space. \n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst Person = struct {\n    name: []const u8,\n    age: u32,\n    age_group: []const u8,\n\n    pub fn init(name: []const u8, age: u32) Person {\n        var age_group = \"Children\";\n        if (age >= 18 and age < 60) {\n            age_group = \"Adult\";\n        }\n        if (age >= 60) {\n            age_group = \"Third age\";\n        }\n\n        return Person {\n            .name = name,\n            .age = age,\n            .age_group = age_group\n        };\n    }\n};\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}