{
  "hash": "0308ff44c68c81e3e297f1591a7bb17d",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n\n\n\n\n\n# Introducing Vectors and SIMD\n\nIn this chapter, I'm going to discuss vectors in Zig, which are\nrelated to SIMD operations. Before we dive into the subject, is worth\nmentioning that vectors in Zig have no relationship with the `std::vector` class\nfrom C++. Remember, as we discussed at @sec-dynamic-array,\ndynamic/growable arrays in Zig are represented by the `std.ArrayList()` structure\nfrom the Zig Standard Library.\n\n\n## What is SIMD?\n\nSIMD (*Single Instruction/Multiple Data*) is a group of operations that are widely used\non video/audio editing programs, and also in graphics applications. SIMD is not a new technology,\nbut the massive use of SIMD on normal desktop computers is somewhat recent. In the old days, SIMD\nwas only used on \"supercomputers models\".\n\nMost modern CPU models (from AMD, Intel, etc.) these days (either in a desktop or in a\nnotebook model) have support for SIMD operations. If you have a very old CPU model installed in your\ncomputer, then, is possible that you have no support for SIMD operations in your computer.\n\nBut why people have started using SIMD on their software? The answer is performance.\nBut what SIMD precisely do to achieve better performance? In essence, SIMD is a different\nway to get parallel computing, and therefore, make faster calculations.\n\nThe basic idea behind SIMD is to have a single instruction that operates over multiple data\nat the same time. When you perform a normal scalar operation, like for example, four add instructions,\neach addition is performed separately, one after another. But with SIMD, these four add instructions\nare translated into a single instruction, and, as consequence, the four additions are performed\nin parallel, at the same time.\n\n\n### Vectors\n\nSIMD operations are performed over a special type of object, which are\ncalled \"vectors\". A vector object is usually a fixed-sized block of 128 bits (16 bytes).\nAs consequence, most vector objects in the wild are arrays that contains 2 values of 8 bytes each,\nor, 4 values of 4 bytes each, or, 8 values of 2 bytes each, etc.\nHowever, different CPU models may have different extensions (or, \"implementations\") of SIMD,\nwhich may offer more types of vector objects that are bigger in size (256 bits or 512 bits)\nto accomodate more data into a single vector object.\n\nYou can create a new vector object in Zig by using the `@Vector()` built-in function. Inside this function,\nyou specify the vector length (number of elements in the vector), and the data type of the elements\nof the vector. In the example below, I'm creating two vector objects (`v1` and `v2`) of 4 elements of type `u32` each.\n\nAlso notice in the example below, that a third vector object (`v3`) is created from the\nsum of the previous two vector objects (`v1` plus `v2`). Therefore,\nmath operations over vector objects take place element-wise by default, because\nthe same operation (in this case, addition) is replicated in parallel, across\nall elements of the vector.\n\n\n\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst v1 = @Vector(4, u32){4, 12, 37, 9};\nconst v2 = @Vector(4, u32){10, 22, 5, 12};\nconst v3 = v1 + v2;\ntry stdout.print(\"{any}\\n\", .{v3});\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{ 14, 34, 42, 21 }\n```\n\n\n:::\n:::\n\n\n\n\n\nThis is how SIMD creates more performance in our program. Instead of using a for or a while loop\nto iterate through the elements of `v1` and `v2`, and adding them together, one element at a time,\nwe enjoy the benefits of SIMD, which performs all 4 additions in parallel, at the same time.\n\nTherefore, the `@Vector` structure in Zig is essentially, the Zig representation of SIMD vector objects.\nThe elements on these vector objects will be operated in parallel, if, and only if your current CPU model\nsupports SIMD operation.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}