{
  "hash": "d950af484ed8fca4950d1594c833c95e",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n\n# Building a HTTP Server from scratch\n\nIn this chapter, I want to implement a new\nsmall project with you. This time, we are going\nto implement a basic HTTP Server from scratch.\n\nThe Zig Standard Library already have a HTTP Server\nimplemented, which is available at `std.http.Server`.\nBut again, our objective here in this chapter, is to implement\nit **from scratch**. So we can't use this server `struct` available\nfrom the Zig Standard Library.\n\n## What is a HTTP Server?\n\nFirst of all, what is a HTTP Server?\nA HTTP server, as any other type of server, is essentially\na program that runs indefinetly, on a infinite loop, waiting for incoming connections\nfrom clients. Once the server receives an incoming connection, it will\naccept this connection, and it will send messages back-and-forth to the client\nthrough this connection.\n\nBut the messages that are transmitted inside this connection are in a\nspecific format. They are HTTP messages\n(i.e. messages that uses the HTTP Protocol specification).\nThe HTTP Protocol is the backbone of the modern web.\nThe world wide web as we know it today, would not exist without the \nHTTP Protocol.\n\nSo, Web servers (which is just a fancy name to\nHTTP Servers) are servers that exchange HTTP messages with clients.\nAnd these HTTP servers and the HTTP Protocol specification\nare simply essential to the operation of the internet of today.\n\nThat is the whole picture of the process.\nAgain, we have two subjects involved here, a server (which is\na program that is running indefinetly, waiting for connections),\nand a client (which is someone that wants to connect to\nand exchange HTTP messages with the server).\n\n## How a HTTP Server works?\n\nImagine a HTTP Server as if it were the receptionist of a large hotel. In a hotel,\nyou have a reception, and inside that reception there is a receptionist\nwaiting for customers to arrive. A HTTP Server is essentially a receptionist\nthat is indefinetly waiting for new customers (or, in the context of HTTP, new clients)\nto arrive in the hotel.\n\nWhen a customer arrives at the hotel, \nthat customer starts a conversation with the\nreceptionist. He tells the receptionist how many days he wants to stay at the hotel.\nThen, the receptionist search for an available apartment. If there is an available apartment\nat the moment, the customer pays the hotel fees, then, he gets the keys to the apartment,\nand then, he goes to the apartment to rest.\n\nAfter this entire process of dealing with the customer (searching for available rooms, receiving payment, handing over the keys),\nthe receptionist goes back to what he was doing earlier, which is to wait.\nWait for new customers to arrive.\n\nThat is, in a nutshell, what a HTTP Server do. It waits for clients to connect to the\nserver. When a client attempts to connect to the server, the server accepts this connection,\nand it starts to exchange messages with the client through this connection.\nThe first message that happens inside this connection is always a message from the client\nto the server. This message is called the *HTTP Request*.\n\nThis HTTP Request is a HTTP message that contains what\nthe client wants from the server. Is literally a request. The client\nthat connected to the server is asking this server to do something for him.\n\nThere are different \"types of request\" that any client can do to a HTTP Server.\nBut the most basic type of request, is when a client ask to the\nHTTP Server to serve (i.e. to send) some specific web page (which is a HTML file) to him.\nWhen you type `google.com` in your web browser, you are essentially sending a HTTP Request to Google's\nHTTP servers, which asks these servers to send the Google webpage to you.\n\nNonetheless, when the server reiceves this first message, the *HTTP Request*, it\nanalyzes this request, to understand: who the client is? what he wants the server to do?\nthis client provided all the necessary information to perform the action that he\nasked? Etc.\n\nOnce the server understands what the client wants, he simply perform the action\nthat was requested, and, to finish the whole process, the server sends back\na HTTP message to the client, informing if the action performed was succesful or not,\nand, at last, the server ends (or closes) the connection with the client.\n\nThis last HTTP message sent from the server to the client, is called the *HTTP Response*.\nBecause the server is responding to the action that was requested by the client.\nThe main objective of this response message is let the client knows if the\naction requested was succesful or not, before the server closes the connection.\n\n\n## How a HTTP server is normally implemented?\n\nLet's use the C language as an example. In C, we normally implement a HTTP server\nby performing the following steps:\n\n1. Create a socket object.\n1. Bind a name (or more specifically, an address) to this socket object.\n1. Make this socket object to start listening and waiting for incoming connections.\n1. When a connection arrive, we accept this connection, and we exchange the HTTP messages (HTTP Request and HTTP Response).\n1. Then, we simply close this connection.\n\n\nA socket object (which uses the WebSocket technology) is essentially a channel of communication.\nYou are creating a channel where people can send messages to.\nWhen you create a socket object, this object is not binded to any particular\naddress. This means that with this object you have a representation of a channel of communication\nin your hands. But this channel is not currently available, or, it is not currently accessible,\nbecause it do not have a known address where you can find it.\n\nThat is what the \"bind\" operation do. It binds a name (or more specifically, an address) to\nthis socket object, or, this channel of communication, so that it becomes available,\nor, accessible through this address. While the \"listen\" operation makes the socket object to\nlisten for incoming connections in this address. In other words, the \"listen\" operation\nmakes the socket to wait for incoming connections.\n\nNow, when a client actually attempts to connect to the server through the address we specify,\nthen, the socket object needs to accept this incoming connection. When we\naccept it, then, the connection is established, client and server are now\nconnected to each other, and they can read or write messages in this\nestablished connection.\n\nAfter we received the HTTP Request from the client,\nand sent the HTTP Response to the client,\nwe can now close the connection, and end\nthis communication.\n\n\nAll of this process, in C, would be something like this code example below.\nThere are lot of things happening in this code, and, I am also not doing\na lot of necessary things, like error handling. But this is just\nan simplified example of how this code in C would look like.\n\nAlso, this code would not compile on Windows, because in Windows\nwe need to use slightly different functions and patterns to\nmake the connections and also close them. So, this code example\nworks only on Linux[^c-funs].\n\n[^c-funs]: The functions used in this code example, such as `socket()`,\n`bind()`, `listen()` and `accept()`, and also, some\n`struct` objects, such as `sockaddr` and `sockaddr_in`,\ncome from the header files `sys/socket.h`, `netinet/in.h` and `arpa/inet.h`.\n\n\n```c\nint sock = socket(AF_INET, SOCK_STREAM, 0);\nuint16_t port = htons(PORT);\nstruct sockaddr_in socket_address;\nsocket_address.sin_family = AF_INET;\nsocket_address.sin_addr.s_addr = htonl(INADDR_ANY);\nsocket_address.sin_port = port;\nmemset(&(socket_address.sin_zero), '\\0', 8);\n\nbind(\n    sock,\n    (struct sockaddr *) &socket_address,\n    sizeof(socket_address)\n);\n\nlisten(sock, 10);\nstruct sockaddr_in their_addr;\nint client_connected;\nsocklen_t sock_addr_size = sizeof(struct sockaddr_in);\nclient_connected = accept(\n    sock,\n    (struct sockaddr *)&their_addr,\n    &sock_addr_size)\n);\nchar* msg = \"Hello, World!\";\nint len, bytes_sent;\nlen = strlen(msg);\nbytes_sent = send(client_connected, msg, len, 0);\n\nclose(client_connected);\nclose(sock);\n```\n\n",
    "supporting": [
      "04-http-server_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}