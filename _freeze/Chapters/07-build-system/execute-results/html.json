{
  "hash": "7f166d244f96d888c4a0a5b0b4dda727",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n# Build System in Zig\n\nOne advantage of Zig is that it includes a build system embedded in the language itself.\nThis is great, because then you do not have to depend on a external system, separated\nfrom the compiler, to build your code.\nSo, in this chapter, we are going to talk about the build system in Zig, and how\ncode is built in Zig.\n\n\n## How source code is built?\n\nWe already talked about the challenges of building source code in low-level languages\nat @sec-project-files. As we described at that section, programmers invented Build Systems\nto surpass these challenges on the building processes of low-level languages.\n\nLow-level languages uses a compiler to compile (or to build) your source code into binary instructions.\nIn C and C++, we normally use compilers like `gcc`, `g++` or `clang` to compile\nour C and C++ source code into these instructions.\nEvery language have it's own compiler, and this is no different in Zig.\n\nIn Zig, we have the `zig` compiler to compile our Zig source code into\nbinary instructions that can be executed by our computer.\nIn Zig, the compilation (or the build) process involves\nthe following components:\n\n- The Zig modules that contains your source code;\n- Library files (either a dynamic library or a static library);\n- Compiler flags that tailors the build process to your needs.\n\nThese are the things that you need to connect together in order to build your\nsource code. In C and C++, you would have an extra component, which is the header files of\nthe libraries you are using. But header files do not exist in Zig, so, you don't need\nto care about them here.\n\nYour build process is usually organized into a build script. In Zig, we normally\nwrite this build script into a Zig module in the root directory of our project,\nnamed as `build.zig`. You write a build script, then, when you run it, your project\nget's built into binary files that you can use and distribute.\n\nThis build script is normally organized around *target objects*. A target is simply\nsomething to be built, or, in other words, it's something that you want the `zig` compiler\nto build for you. This concept of \"targets\" is present in most Build Systems,\nspecially in CMake[^cmake].\n\n[^cmake]: <https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html>\n\nThere are three types of target objects that you can build in Zig, which are:\n\n- An executable, which is simply a binary executable file (e.g. a `.exe` file on Windows).\n- A shared library, which is simply a binary library file (e.g. a `.so` file in Linux or a `.dll` file on Windows).\n- A static library, which is simply a binary library file (e.g. a `.a` file in Linux or a `.lib` file on Windows).\n- An unit tests executable, which is an executable file that executes only unit tests.\n\nWe are going to talk more about these target objects at @sec-targets.\n\n\n\n## The `build()` function {#sec-build-fun}\n\nA build script in Zig always contains a public (and top-level) `build()` function.\nIt is like the `main()` function on the main Zig module of your project, that we discussed at @sec-main-file.\nBut instead of creating the entrypoint to your code, this `build()` function is the entrypoint to the build process.\n\nThis `build()` function accepts a pointer to a `Build` object as input, and uses this \"build object\" to perform\nthe necessary steps to build your project. The return type of this function is always `void`.\nThis `Build` struct comes directly from the Zig Standard Library (`std.Build`). So, you can \naccess this struct by just importing the Zig Standard Library into your module.\n\nJust as a very simple example, here you can see the source code necessary to build\nan executable file from the `hello.zig` Zig module.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\npub fn build(b: *std.Build) void {\n    const exe = b.addExecutable(.{\n        .name = \"hello\",\n        .root_source_file = b.path(\"hello.zig\"),\n        .target = b.host,\n    });\n    b.installArtifact(exe);\n}\n```\n:::\n\n\nYou can define and use other functions and objects in this build script. You can also import\nother Zig modules as you would normally do in any other module of your project.\nThe only real requirement for this build script, is to have a public and top-level\n`build()` function defined, that accepts a pointer to a `Build` struct as input.\n\n\n## Target objects {#sec-targets}\n\nAs we described over the previous sections, a build script is composed around target objects.\nEach target object is an output that you want to get from the build process. You can list\nmultiple target objects in your build script, so that the build process generates multiple\nbinary files for you at once.\n\nFor example, we could list two target objects in the build script.\nThe first one could be an executable file, while the second one, a static library file.\nThat is, we listed two different types of target objects in the build script, and, when we execute\nthis script, the `zig` compiler builds our project into two separate files at the same time.\n\nA target object is created by the following methods of the `Build` struct that we introduced\nat @sec-build-fun:\n\n- `addExecutable()` creates an executable file;\n- `addSharedLibrary()` creates a shared library file;\n- `addStaticLibrary()` creates a static library file;\n- `addTest()` creates an executable file that executes unit tests.\n\n\nThese functions are methods from the `Build` struct that you receive\nas input of the `build()` function. All of them, create as output\na `Compile` object, which represents an object to be compiled.\n\nAll these functions accept a similar struct literal as input.\nThis struct literal defines three essential specs about this target object you are building:\n`name`, `target` and `root_source_file`.\n\nWe already saw these three options being used on the previous example,\nwhere we used the `addExecutable()` method to create an executable target object.\nThis example is reproduced below. Notice the use of the `path()` method to define a path in\nthe `root_source_file` option.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nexe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n});\n```\n:::\n\n\nThe `name` option specificy the name that you want to give to the binary file defined\nby this target. So, in this example, we are building an executable file named `hello`.\nIs traditional to set this `name` option to the name of our project.\n\n\nFurthermore, the `target` option specify the target computer architecture (or operational system) of this\nbinary file. For example, if you want this target object to run on a Windows machine\nthat uses a `x86_64` architecture, you can set this `target` option to the `x86_64-windows-gnu` target.\nThis will make the `zig` compiler to compile the project to run on a `x86_64` Windows machine.\n\nNow, if you are building the project to run on the current machine\nthat you are using to run this build script, you can set this `target`\noption to the `host` method of the `Build` object, like we did in the example above.\nThis `host` method which identifies the current machine where you are\ncurrently running the `zig` compiler.\n\n\nAt last, the `root_source_file` option specifies the root Zig module of your project.\nThat is the Zig module that contains the entrypoint to your application, or, the main API of your library.\nThis also means that, all the Zig modules that compose your project are automatically discovered\nfrom the import statements that you have inside this \"root source file\".\nThe `zig` compiler can detect when a Zig module depends on the other through the import statements,\nand, as a result, it can discover the entire map of Zig modules used in your project.\n\nThis is handy, and it is different than what happens in other build systems.\nIn CMake for example, you have to explicitly list the paths to all source files that you want to\ninclude in your build process. This is probably a symptom of the lack of conditional\ncompilation in C and C++ compilers. Because they lack this feature that Zig has, you have\nto explicitly choose which source files are sent to the compiler, since not\nevery C/C++ code is portable or supported in every operational system, and, therefore,\nwould cause a compilation error in the C/C++ compiler.\n\n\nNow, one important detail about the build process is that, you have to **explicitly\ninstall the target objects that you create in your build script**, by using the\n`installArtifact()` method of the `Build` struct.\n\nEverytime you invoke the build process of your project, by calling the `build` command\nof the `zig` compiler, a new directory named `zig-out` is created in the root\ndirectory of your project. This new directory contains the output of the build process,\nthat is, the binary files built from your source code.\n\nWhat the `installArtifact()` method do is to ask the `zig` compiler to copy the target object\nwhen is already built into the `zig-out` directory. This means that, if you do not\ninstall the target objects you define in your build script, these target objects are\nessentially discarded at the end of the build process.\n\nThe `installArtifact()` will by default install (or copy) the built target objects\nthat you defined to inside this `zig-out` directory. But the user, not you, the programmer\nthat created your project, I mean the actual user that will compile and install your application\nor library in their computers to use it; these users can define the prefix path where they\nwant to install your application/library in their computers, by providing the prefix\npath through the `--prefix` command line argument when they build your project\nwith the `build` command from the `zig` compiler.\n\nFor example, you might be building a project that uses a third party library that is built\ntogether with the project. So, when you build your project, you would need to first,\nbuild the third party library, and then, you link it with the source code of your project.\nSo, in this case, we have two binary files that are generated in the build process.\nBut only one is of interest, which is the executable file of our project.\nWe can discard the binary file of the third party library, by simply not installing it\ninto this `zig-out` directory.\n\nSo, is easy to use this `installArtifact()` method. Just remember to apply it to every\ntarget object that you define in your build script, and, that you want to save it into\nthe `zig-out` directory, like in the example below:\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nexe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n});\n\nb.installArtifact(exe);\n```\n:::\n\n\n\n## Setting the build mode\n\nWe talked about the three essential options that are set when you create a new target object.\nBut there is also a fourth option that you can use to set the build mode of this target object,\nwhich is the `optimize` option.\nThis option is called this way, because the build modes in Zig are treated more of\nan \"optimization vs safety\" problem. So optmization plays an important role here.\nDon't worry, I'm going back to this question very soon.\n\nIn Zig, we have the four build modes listed below. Each one of these build modes offer\ndifferent advantages and characteristics. As we described at @sec-compile-debug-mode, the `zig` compiler\nuses the `Debug` build mode by default, when you don't explicitly choose a build mode.\n\n- `Debug`, mode that produces and includes debugging information in the output of the build process (i.e. the binary file defined by the target object);\n- `ReleaseSmall`, mode that tries to produce a binary file that is small in size;\n- `ReleaseFast`, mode that tries to optimize your code, in order to produce a binary file that is as fast as possible;\n- `ReleaseSafe`, mode that tries to make your code as safe as possible, by including safeguards when possible.\n\n\nIn the example below, we are creating the same\ntarget object that we used on previous examples. But this time, we are specifying\nthe build mode of this target object to use the `ReleaseSafe` mode.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst exe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n    .optimize = .ReleaseSafe\n});\nb.installArtifact(exe);\n```\n:::\n\n\n\n## Setting the version of your build\n\nIn modern development flow, is commom to release new versions of the same software by\nmarking these different versions with a version number. This version\nnumber usually follows a semantic versioning framework, which defines a version\nnumber divided into three parts:\n\n- major number;\n- minor number;\n- patch number;\n\nYou can find more about semantic versioning by visiting the [Semantic Versioning website](https://semver.org/)[^semver].\nAnyway, in Zig,\nyou can specify the version of your build, by providing a `SemanticVersion` struct to\nthe `version` option, like in the example below:\n\n\n[^semver]: <https://semver.org/>\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst exe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n    .version = .{\n        .major = 2, .minor = 9, .patch = 7\n    }\n});\nb.installArtifact(exe);\n```\n:::\n\n\n\n## Detecting the OS in your build script\n\nIs very commom in Build Systems to use different options, or, to include different modules, or,\nto link against different libraries depending on the Operational System (OS)\nthat you are targeting in the build process.\n\nIn Zig, you can detect the target OS of the build process, by looking\nat the `os.tag` inside the `builtin` module from the Zig library.\nIn the example below, we are using an if statement to run some\narbitrary code when the target of the build process is the\nWindows system.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst builtin = @import(\"builtin\");\nif (builtin.target.os.tag == .windows) {\n    // Code that runs only when the target of\n    // the compilation process is Windows.\n}\n```\n:::\n\n\n\n## Adding a run step to your build process\n\n\n\n## Build for unit tests\n\nWe talk at length about writing unit tests in Zig, and we also talk about how to execute these unit tests through\nthe `test` command of the `zig` compiler at @sec-unittests. However,\nthe `test` command is used to run the unit tests from a single Zig module.\n\nBut how to run all unit tests in the project at once? Here is where a test target object comes into play.\nAs was described at @sec-targets, we can create a test target object by using the `addTest()` method of\nthe `Build` struct.\n\nA test target object essentially filter all `test` blocks in all Zig modules\nacross your project, and builds only the source code present inside\nthese `test` blocks in your project. As a result, this target object\ncreates an executable file, that when you execute it, you are\nexecuting the source in all of these `test` blocks, i.e. the unit tests.\n\nWhen we create a test target object and add a run step into this test target object,\nwe create a very useful shortcut to build all unit tests of your project, and\nexecute them, at once.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst test_exe = b.addTest(.{\n    .name = \"test\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n});\n\nb.installArtifact(test_exe);\nconst run_test = b.addRunArtifact(test_exe);\nconst run_step = b.step(\"run\", \"Run the unit tests\");\nrun_step.dependOn(&run_test.step);\n```\n:::\n\n\n\n\n## Tailoring your build process with user provided options\n\n\n## Linking with external libraries\n\n\n\n\n",
    "supporting": [
      "07-build-system_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}