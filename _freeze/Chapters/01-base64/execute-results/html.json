{
  "hash": "2f628267ee1e4bb35f198d88eaa8870f",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n# Building a base64 encoder/decoder\n\nAs our first small project, I want to implement with you a base64 encoder/decoder in Zig.\nBase64 is an encoding system which translates binary data to text.\nA big chunk of the web uses base64 to deliver binary data to systems\nthat can only read text data.\n\nThe biggest example of a modern use case for base64 is essentially any email system,\nlike GMail, Outlook, etc. Because email systems normally use\nthe Simple Mail Transfer Protocol (SMTP), which is a web protocol\nthat supports only text data. So, if you need, for any reason, to\nsend a binary file (like for example, a PDF, or an Excel file) as\nan attachment in your email, these binary files are normally\nconverted to base64, before they are included in the SMTP message.\nSo, the base64 encoding is largelly used in these email systems to include\nbinary data into the SMTP message.\n\n\n\n\n\n\n## How the base64 algorithm work? \n\nNow, how exactly the algorithm behind the base64 encoding works? Let's discuss that. First, I will\nexplain the base64 scale, which is the scale of 64 characters that represents the base64 encoding system.\n\nAfter that, I explain the algorithm behind a base64 encoder, which is the part of the algorithm that is responsible for encoding messages\ninto the base64 encoding system. Then, after that, I explain the algorithm behind a base64 decoder, which is\nthe part of the algorithm that is responsible for translating base64 messages back into their original meaning.\n\nIf you are unsure about the differences between an \"encoder\" and a \"decoder\",\ntake a look at @sec-encode-vs-decode.\n\n\n### The base64 scale\n\nIn essence, the base64 encoding system is based on a scale that goes from 0 to 64 (hence the name).\nEach index in this scale is represented by a character (it is a scale of 64 characters).\nSo, in order to convert some binary data, to the base64 encoding, we need to convert each binary number to the corresponding\ncharacter in this \"scale of 64 characters\".\n\nThe base64 scale starts with all ASCII uppercase letters (A to Z) which represents\nthe first 25 indexes in this scale (0 to 25). After that, we have all ASCII lowercase letters\n(a to z), which represents the range 26 to 51 in the scale. After that, we\nhave the one digit numbers (0 to 9), which represents the indexes from 52 to 61 in the scale.\nFinally, the last two indexes in the scale (62 and 63) are represented by the characters `+` and `/`,\nrespectively.\n\nThese are the 64 characters that compose the base64 scale. The equal sign character (`=`) is not part of the scale itself,\nbut it is a special character in the base64 encoding system. This character is used solely as a suffix, to mark the end of the character sequence,\nor, to mark the end of meaningful characters in the sequence.\n\nThe bulletpoints below summarises the base64 scale:\n\n- range 0 to 25 is represented by: ASCII uppercase letters `-> [A-Z]`;\n- range 26 to 51 is represented by: ASCII lowercase letters `-> [a-z]`;\n- range 52 to 61 is represented by: one digit numbers `-> [0-9]`;\n- index 62 and 63 are represented by the characters `+` and `/`, respectively;\n- the character `=` represents the end of meaningful characters in the sequence;\n\n\n\nEverytime that the base64 algorithm needs to fill some gap (which always occur at the end of\nthe input string) with a group of 6 bits filled with only zeros (`000000`), this group is automatically\nmapped to the character `=`. Because this group of 6 bits is meaningless, they represent nothing,\nthey are just filling the gap. As a result, the base64 algorithm maps this meaningless group\nto the character `=`, which represents the end of meaningful characters in the sequence.\nThis characteristic is explained in more details at @sec-base64-encoder-algo.\n\n\n\n### Creating the scale as a lookup table {#sec-base64-table}\n\nThe best way to represent this scale in code, is to represent it as a *lookup table*.\nLookup tables are a classic strategy in computer science to speed calculations. The basic idea\nis to replace a runtime calculation (which can take a long time to be done) by a basic array indexing\noperation.\n\nInstead of calculating the results everytime you need them, you calculate all possible results at once, and then, you store them in an array\n(which behaves lake a \"table\"). Then, every time that you need to use one of the characters in the base64 scale, instead of\nusing many resources to calculate the exact character to be used, you simply retrieve this character\nfrom the array where you stored all the possible characters in the base64 scale. So we retrieve the character that we need\ndirectly from memory.\n\nWe can start building a Zig struct to store our base64 decoder/encoder logic.\nWe start with the `Base64` struct below. You can see that, for now, we only have an `init()` function,\nto create a new instance of a `Base64` object, and, a `_char_at()` function, which is a\n\"get chat at index ...\" type of function.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst Base64 = struct {\n    _table: *const [64]u8,\n\n    pub fn init() Base64 {\n        const upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        const lower = \"abcdefghijklmnopqrstuvwxyz\";\n        const numbers_symb = \"0123456789+/\";\n        return Base64{\n            ._table = upper ++ lower ++ numbers_symb,\n        };\n    }\n\n    pub fn _char_at(self: Base64, index: u8) u8 {\n        return self._table[index];\n    }\n};\n```\n:::\n\n\n\nIn other words, the `_char_at()` function is responsible for getting the character in the lookup table (i.e. the `_table` variable) that\ncorresponds to a particular index in the \"base64 scale\". So, in the example below, we know that\nthe character that corresponds to the index 28 in the \"base64 scale\" is the character \"c\".\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst base64 = Base64.init();\ntry stdout.print(\n    \"Character at 28 index: {c}\\n\",\n    .{base64._char_at(28)}\n);\n```\n:::\n\n\n```\nCharacter at 28 index: c\n```\n\n\n\n### A base64 encoder {#sec-base64-encoder-algo}\n\nThe algorithm behind a base64 encoder usually works on a window of 3 bytes. Because each byte have\n8 bits, so, 3 bytes forms a set of $8 \\times 3 = 24$ bits. This is desirable for the base64 algorithm, because\n24 bits is divisble by 6, which form a set of 4 groups of 6 bits each.\n\nSo the base64 algorithm work by converting 3 bytes at a time\ninto 4 characters in the base64 scale. It keeps iterating through the input string,\n3 bytes at a time, and converting them into the base64 scale, producing 4 characters\nper iteration. It keeps iterating, and producing these \"new characters\"\nuntil it hits the end of the input string.\n\nNow you may think, what if you have a particular string that have a number of bytes\nthat is not divisible by 3? What happens? For example, if you have a string\nthat contains only two characters/bytes, such as \"Hi\". How the\nalgorithm behaves in such situation? You find the answer at @fig-base64-algo1.\nYou can see at @fig-base64-algo1 that the string \"Hi\", when converted to base64,\nbecomes the string \"SGk=\":\n\n![The logic behind a base64 encoder](./../Figures/base64-encoder-flow.png){#fig-base64-algo1}\n\nIn the example of the string \"Hi\" we have 2 bytes, or, 16 bits in total. So, we lack a full byte (8 bits)\nto complete the window of 24 bits that the base64 algorithm likes to work on. In essence,\neverytime that the algorithm does not meet this requirement, it simply add extra zeros\nuntil it fills the space that it needs.\n\nThat is why at @fig-base64-algo1, on the third group after the 6-bit transformation,\n2 extra zeros were added to fill the gap in this group, and also, the fourth group (which is the last 6-bit group)\nafter the 6-bit transformation is entirely made by zeros that were added by the algorithm.\n\nSo every time that the base64 algorithm can't produce a full group of 6 bits, it\nsimply fills the gap in this group with zeros, until it get's the 6 bits that it needs.\n\nIs worth mentioning that, everytime that the algorithm produces a group of 6 bits that\nis entirely composed by zeros, this group of 6 bits is automatically mapped to\nthe character `=` (equal sign). In other works, the group `000000` is translated into the\ncharacter `=`. Because it represents the end of meaningful characters in the sequence.\n\n\n### A base64 decoder {#sec-base64-decoder-algo}\n\nThe algorithm behind a base64 decoder is essentially the inverse process of a base64 encoder.\nA base64 decoder needs to be able to translate base64 messages back into their original meaning,\ni.e. into the original sequence of binary data.\n\nA base64 decoder usually works on a window of 4 bytes. Because it wants to convert these 4 bytes\nback into the original sequence of 3 bytes, that was converted into 4 groups of 6 bits by the\nbase64 encoder. Remember, in a base64 decoder we are essentially reverting the process made\nby the base64 encoder.\n\nEach byte in the input string (the base64 encoded string) normally contributes to re-create two different bytes in the output (the original binary data).\nIn other words, each byte that comes out of a base64 decoder is created by transforming merging two different\nbytes in the input together. You can see this fact at @fig-base64-algo2:\n\n![The logic behind a base64 decoder](./../Figures/base64-decoder-flow.png){#fig-base64-algo2}\n\nThe exact transformations, or, the exact steps applied to each byte from the input to transform them\ninto the bytes in the output, are a bit tricky to visualize in a figure like this. Because of that, I\nsummarized these transformations as \"Some bit shifting and additions ...\". These transformations\nwill be described in depth later.\n\nBesides that, if you look again at @fig-base64-algo2, you will notice that the character `=` was completly\nignored in the algorithm. Remember, this is just a special character that marks the end of meaninful characters\nin the base64 sequence. So, every `=` character in a base64 encoded sequence should be ignored.\n\n\n## Difference between encode and decode {#sec-encode-vs-decode}\n\nIf you don't have any previous experience with base64, you might be confused about\nwhat is the differente between \"encode\" and \"decode\". Essentially, the terms \"encode\" and \"decode\" here\nhave the exact same meaning as they have in the field of encryption (i.e. they mean the same thing as \"encode\" and \"decode\" in hashing\nalgorithms, like the MD5 algorithm).\n\nSo, \"encode\" means that we want to encode, or, in other words, we want to translate some message into\nthe base64 encoding system. We want to produce the sequence of base64 characters that represent this\noriginal message in the base64 encoding system.\n\nIn contrast, \"decode\" represents the inverse process.\nWe want to decode, or, in other words, translate a base64 message back to it's original content.\nSo, in this process we get a sequence of base64 characters as input, and produce as output,\nthe binary data that is represented by this sequence of base64 characters.\n\nSo, any base64 library is normally composed by these two parts: 1) the encoder, which is a function that encodes\n(i.e. it converts) any sequence of binary data into a sequence of base64 characters; 2) the decoder, which is a function\nthat converts a sequence of base64 characters back into the original sequence of binary data.\n\n\n\n## Calculating the size of the output\n\nOne task that we need to do is to calculate how much space we need to reserve for the\noutput, both of the encoder and decoder. This is simple math, and can be done easily in Zig\nbecause every array have it's length (it's number of bytes) easily accesible by consulting\nthe `.len` property of the array.\n\nFor the encoder, the logic is the following: for each 3 bytes that we find in the input,\n4 new bytes are created in the output. So, we take the number of bytes in the input, divide it\nby 3, use a ceiling function, then, we multiply the result by 4. That way, we get the total\nnumber of bytes that will be produced by the encoder in it's output.\n\nThe `_calc_encode_length()` function below encapsulates this logic. Notice that we convert\nthe `.len` property of the array, which is always a integer (more precisely, an `usize` value),\ninto a floating point number of 64 bits (`f64`). We do this, because the ceiling function (`@ceil()`) works\nonly with floating point numbers. So, we convert it so that the division with the number `3.0` results in\na floating point number. Then, after the ceiling process, we can convert the result back into an\ninteger value (with the `@intFromFloat()` function).\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nfn _calc_encode_length(input: []const u8) u64 {\n    if (input.len < 3) {\n        const n_output: u64 = 4;\n        return n_output;\n    }\n    const len_as_float: f64 = @floatFromInt(input.len);\n    const n_output: u64 = @intFromFloat(@ceil(len_as_float / 3.0) * 4.0);\n    return n_output;\n}\n```\n:::\n\n\nIs important to notice that, when I am using the built-in functions from Zig to convert data types (`@floatFromInt()` and `intFromFloat()`),\nI'm always annotating explicitly the type of the variable that stores the result of these functions.\nI do that, because these functions need this information. `@floatFromInt()` needs to know\nwhich type of floating point number I want to use in it's output. Is it `f16`? `f32`? `f64`? etc.\nThe same goes to `@intFromFloat()`.\n\nAlso, you might have notice that, if the input length is less than 3 bytes, then, the output length of the encoder will\nbe always 4 bytes. This is because the algorithm will always fill the gap in the input with zeroes, until it fits\nthe window of 24 bits that the algorithm likes to work on, as I described at @sec-base64-encoder-algo. So the output\nof the algorithm will always be 4 bytes in this specific case.\n\n\nNow, for the decoder, we just need to apply the inverse logic: for each 4 bytes in the input, 3 bytes\nwill be produced in the output of the decoder. I mean, this is roughly true, because we need to account\nfor the `=` character, which is ignored by the decoder, as we described at @sec-base64-decoder-algo, and,\nat @fig-base64-algo2.\n\nSo, the function `_calc_decode_length()` summarizes this logic that we described. It is very similar\nto the function `_calc_encode_length()`, only the division part is twisted, and also, in the special\ncase where we have less than 4 bytes in the input to work on.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nfn _calc_decode_length(input: []const u8) u64 {\n    if (input.len < 4) {\n        const n_output: u64 = 3;\n        return n_output;\n    }\n    const len_as_float: f64 = @floatFromInt(input.len);\n    const n_output: u64 = @intFromFloat(@floor(len_as_float / 4.0) * 3.0);\n    return n_output;\n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}