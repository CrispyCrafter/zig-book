{
  "hash": "d7cf472584e40bdb2112ce4a782779ed",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n\n\n\n\n# Introducing threads and concurrency in Zig\n\nThreads and concurrency is available in Zig through the `Thread` struct\nfrom the Zig Standard Library. This struct represents a kernel thread, and it follows a POSIX Thread pattern,\nmeaning that, it works similar to a thread from the `pthread` library from the C Standard Library.\n\nIf you are not familiar with a thread, let's dive in first, before we show how a\nthread is used in Zig.\n\n\n## What are threads?\n\nThreads create concurrency. In other words, they create certain amount of confusion and complexity,\nbecause we get different tasks being performed at the same time. As consequence, depending on the\nsize, or, the complexity of your program, or the amount of threads created, it might be difficult\nto track the tasks, and understand what is happening in a particular moment inside your program.\n\nA hole set of problems emerge from concurrency and multi-threaded programming, which are usually\ncategorized as \"race conditions\". A race condition problem is any bug in your program that depends\non \"who get's there first\". In other words, in each execution of your program,\nyou get a different answer, because a different person, or, a different function, or, a different part of the code is finishing\nits tasks (or it is reaching a location) first than the others.\n\n\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst Thread = std.Thread;\nfn do_some_work(thread_id: *const u8) !void {\n    _ = try stdout.print(\"Starting thread {d}.\\n\", .{thread_id.*});\n    std.time.sleep(100 * std.time.ns_per_ms);\n    _ = try stdout.print(\"Finishing thread {d}.\\n\", .{thread_id.*});\n}\n\npub fn main() !void {\n    const id1: u8 = 1;\n    const id2: u8 = 2;\n    const thread1 = try Thread.spawn(.{}, do_some_work, .{&id1});\n    const thread2 = try Thread.spawn(.{}, do_some_work, .{&id2});\n    thread1.join();\n    thread2.join();\n}\n```\n:::\n\n\n\n\n\n```\nStarting thread 1.\nStarting thread 2.\nFinishing thread Finishing thread 2.\n1.\n```\n\n\n\n\n## Creating a thread\n\nWe create new threads in Zig, by first, importing the `Thread` struct into\nour current Zig module, and then, calling the `spawn()` method of this struct,\nwhich creates (or, \"spawns\") a new thread of execution.\nThis method have three arguments, which are, respectively:\n\n1. a `SpawnConfig` object, which contains configurations for the spawn process.\n1. the name of the function that is going to be executed (or, that is going to be \"called\") in this new thread.\n1. a list of arguments (or inputs) to be passed to the function provided in the second argument.\n\nWith these three arguments, you can control how the thread get's created, and also, specify which\nwork will be performed (or executed) inside this new thread. A thread is just a separate context of execution,\nand we usually create new threads in our code, because we want to perform some work inside this\nnew context of execution. And we specify which exact work, or, which exact steps that are going to be\nperformed inside this context, by providing the name of a function on the second argument of the `spawn()` method.\n\nThus, when this new thread get's created, this function that you provided as input to the `spawn()`\nmethod get's called, or, get's executed inside this new thread. You can control the\narguments, or, the inputs that are passed to this function when it get's called, by providing\na list of arguments (or a list of inputs) on the third argument of the `spawn()` method.\nThese arguments are passed to the function in the same order that they are\nprovided to `spawn()`.\n\nFurthermore, the `SpawnConfig` is a struct object with only two possible fields, or, two possible members, that you\ncan set to tailor the spawn behaviour. These fields are:\n\n- `stack_size`: you can provide an `usize` value to specify the size (in bytes) of the thread's stack frame. By default, this value is: $16 \\times 1024 \\times 1024$.\n- `allocator`: you can provide an allocator object to be used when allocating memory for the thread.\n\nTo use one of these two fields (or, \"configs\") you just have to create a new object of type `SpawnConfig`,\nand provide this object as input to the `spawn()` method. But, if you are not interested in using\none of these configs, and you are ok with using just the defaults, you can just provide a anonymous\nstruct literal (`.{}`) in the place of this `SpawnConfig` argument.\n\nAs our first, and very simple example, consider the code exposed below.\nInside the same program, you can create multiple threads of execution if you want to.\nBut, in this first example, we are creating just a single thread of execution, because\nwe call `spawn()` only once.\n\nAlso, notice in this example that we are executing the function `do_some_work()`\ninside the new thread. Since this function receives no inputs, because it has\nno arguments, in this instance, we have passed an empty list, or, more precisely, an empty struct\nobject in the third argument of `spawn()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst Thread = std.Thread;\nfn do_some_work() !void {\n    _ = try stdout.write(\"Starting the work.\\n\");\n    std.time.sleep(100 * std.time.ns_per_ms);\n    _ = try stdout.write(\"Finishing the work.\\n\");\n}\n\npub fn main() !void {\n    const thread = try Thread.spawn(.{}, do_some_work, .{});\n    thread.join();\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStarting the work.Finishing the work.\n```\n\n\n:::\n:::\n\n\n\n\n\nNotice the use of `try` when calling the `spawn()` method. This means\nthat this method can return an error in some circunstances. One circunstance\nin particular is when you attempt to create a new thread, when you have already\ncreated too much (i.e. you have excedeed the quota of concurrent threads in your system).\n\nIf the new thread is succesfully created, the `spawn()` method returns a handler\nobject (which is just an object of type `Thread`) to this new thread. You can use\nthis handler object to effectively control all aspects of the thread, e.g. to kill the thread,\nor, to make it yield, to detach it from it's \"parent thread\", etc.\n\nThe instant that you create the new thread, the function that you provided as input to `spawn()`\nget's invoked (i.e. get's called) to start the execution on this new thread.\nIn other words, everytime you call `spawn()`, not only a new thread get's created,\nbut also, the \"start work button\" of this thread get's automatically pressed.\nSo the work being performed in this thread starts at the moment that the thread is created.\nThis is similar to how `pthread_create()` from the `pthreads` library in C works,\nwhich also starts the execution at the moment that the thread get's created.\n\n\n## Syncronizing threads\n\nWe learned in the previous section that the execution of the thread starts at the moment\nthat the thread get's created. So now, we need learn how to syncronize the execution of the new thread\nwith the execution of our main thread, or, the main process in our program.\n\nIn essence, syncronizing threads\nis made through the `join()` and `detach()` methods from the thread handler object.\nA thread may either be *joinable* or *detached* [@linux_pthread_create].\nIn most POSIX Thread implementations, when you create a new thread, this thread is\ncreated initially with a *joinable* status. But that usually depends on the system where your program is running (Windows, MacOS, Linux, etc.).\nEach system have a different implementation of threads, and, thus, might work shlightly different.\n\nEither way, you can turn a thread into a *detached* thread by calling the `detach()` method\nfrom the thread handler object. But if you call the `join()` method instead, then, this thread\nbecomes a *joinable* thread. A thread cannot be both *joinable* and *detached*. Which in general means\nthat you cannot call both `join()` and `detach()` on the same thread.\n\nWhen you do not call neither of these methods (`join()` or `detach()`), then, your thread is not syncronized\nwith the main thread, or, the main process of your program, and, as consequence, you become\na hostage to your own luck, which usually does not play in favor of you. In other words,\nwhen you do not call either `join()` or `detach()` on a thread, the chances of this thread\nproducing undefined behaviour and bugs in your program are sky-high.\n\n\n## Potential problems in threads\n\nTODO: joining with a thread that has already been joined leads to undefined behaviour.\nTODO: talk about zombie threads.\n\n## Killing a particular thread\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}