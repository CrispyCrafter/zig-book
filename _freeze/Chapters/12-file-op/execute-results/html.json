{
  "hash": "651aca4abba56060b61edbd8c173e964",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n# Filesystem and Input/Output (IO)\n\nIn this chapter we are going to discuss how to use the cross-platform structs and functions available\nin the Zig Standard Library that executes filesystem operations. Most of these functions and structs\ncomes from the `std.fs` module.\n\n\n## Filesystem basics\n\nIf you have ever programmed in your life, you probably know\nsome basics about filesystems and file operations, etc.\nBut, since I don't know you, I don't know what is your background, maybe\nthese concepts that I will describe are clear in your mind, but maybe not.\nAnyhow, I will spend some time just to put everyone on the same basis.\n\n\n### The concept of current working directory (CWD)\n\nThe working directory is the folder on your computer where you is currently rooted,\nor in other words, it is the folder that your program is currently looking at.\nTherefore, whenever you are executing a program, it will necessarily be working with\na specific folder on your computer. It will be in this folder that the program will initially\nlook for the files you require, and it will also be in this folder that the program\nwill initially save all the files you ask it to save.\n\nThe working directory is determined by the folder from which you invoke your program\nin the terminal. In other words, if you are in the terminal of your OS, and you\nexecute a binary file (i.e. a program) from this terminal, the folder to which your terminal\nis pointing at is the current working directory of your program that is being executed.\n\nAt @fig-cwd we have an example of me executing a program from the terminal. We are executing\nthe program outputted by the `zig` compiler by compiling the Zig module named `hello.zig`.\nThe CWD in this case is the `zig-book` folder. In other words, while the `hello.zig` program\nis executing, it will be looking at the `zig-book` folder, and any file operation that we perform\ninside this program, will be using this `zig-book` folder as the \"starting point\", or, as the \"central focus\".\n\n![An example of executing a program from the terminal](./../Figures/cwd.png){#fig-cwd}\n\nJust because we are rooted inside a particular folder (in the case of @fig-cwd, the `zig-book` folder) of our computer,\nit doesn't mean that we cannot access or write resources in other locations of our computer.\nThe current working directory (CWD) mechanism just defines where your program will look first\nfor the files you ask for. This does not prevent you from accessing files that are located\nelsewhere on your computer. However, to access any file that is in a folder other than your\ncurrent working directory, you must provide a path to that file or folder.\n\n\n### The concept of paths\n\nYou also probably know the concept paths, either by a lot of practice with computers and programming, or,\nby knowing a little bit about filesystems. But once again, I don't know you, so let's remember\nwhat a path is.\n\nA path is essentially a location. It points to a location in your filesystem. We use\npaths to describe the location of files and folders in our computer.\nOne important aspect is that paths are always written inside strings,\ni.e. they are always provided as text values.\n\nThere are two types of paths that you can provide to any program in any OS: a relative path, or a absolute path.\nAbsolute paths are paths that start at the root of your filesystem, and go all the way to the file name or the specfic folder\nthat you are referring to. This type of path is called absolute, because it points to a unique, absolute location on your computer.\nThat is, there is no other existing location on your computer that corresponds to this path. It is an unique identifier.\n\nIn contrast, a relative path is a path that start at the CWD. In other words, a relative path is\n\"relative to the CWD\". The path used to access the `hello.zig` file at @fig-cwd is an example of relative path. This path\nis reproduced below. This path begins at the CWD, which in the context of @fig-cwd, is the `zig-book` folder,\nthen, it goes to the `ZigExamples` folder, then, into `zig-basics`, then, to the `hello.zig` file.\n\n```\nZigExamples/zig-basics/hello_world.zig\n```\n\n\n### Path wildcards\n\nWhen providing paths, specially relative paths, you have the option of using a *wildcard*.\nThere are two commonly used *wildcards* in paths, which are \"one period\" (.) and \"two periods\" (..).\nIn other words, these two specific characters have special meanings when used in paths,\nand can be used on any operating system (Mac, Windows, Linux, etc.). That is, they\nare \"cross platform\".\n\nThe \"one period\" represents an alias for your current working directory.\nThis means that the relative paths `\"./Course/Data/covid.csv\"` and `\"Course/Data/covid.csv\"` are equivalent.\nOn the other hand, the \"two periods\" refers to the previous directory.\nFor example, the path `\"Course/..\"` is equivalent to the path `\".\"`, that is, the current working directory.\n\nTherefore, the path `\"Course/..\"` refers to the folder before the `Course` folder.\nAs another example, the path `\"src/writexml/../xml.cpp\"` refers to the file `xml.cpp`\nthat is inside the folder before the `writexml` folder, which in this example is the `src` folder.\nTherefore, this path is equivalent to `\"src/xml.cpp\"`.\n\n\n\n## The current working directory handler\n\nIn Zig, filesystem operations are usually made through a directory handler.\nA directory handler in Zig is an object of type `Dir`, which is a struct that comes from the `std.fs` module.\nYou normally create such `Dir` object, by calling the `std.fs.cwd()` function.\nThis function returns a `Dir` object that points to, or, that represents the CWD.\n\nThrough this `Dir` object, you can create new files, or modify, or read existing ones that are\ninside your CWD. In the example below, we are creating this `Dir` object, and storing it\ninside the `cwd` object. Through this `cwd` object we can perform filesystem operations in\nthe CWD, creating, deleting, reading or modifying files inside the CWD.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst cwd = std.fs.cwd();\n_ = cwd;\n```\n:::\n\n\n\n## CRUD operations on files\n\nIn this section, we will describe how to perform basic CRUD (Create, Read, Update and Delete) operations\non files. This section describes which methods from the `Dir` object are used to perform\nthese operations, and we also describes the available flags for each operation.\n\n\n### Creating files\n\nWe create new files by using the `createFile()` method from the `Dir` object.\nJust provide the name of the file that you want to create, and this function will\ndo the necessary steps to create such file. You can also provide a relative path to this function,\nand it will create the file by following this path, which is relative to the CWD.\n\nThis function might return an error, so, you should use `try`, `catch`, or any of the other methods presented\nat @sec-error-handling to handle this possible error. But if everything goes well,\nthis `createFile()` method returns a `File` object as result.\n\nTake this code example below. In this example, we are creating a new text file\nnamed `foo.txt`. If the function `createFile()` succeeds, the object named `file` will contain a file handler,\nwhich is pretty much the same thing as a file descriptor object created from the famous C function `fopen()`[^fopen-doc].\n\n[^fopen-doc]: <https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm>\n\nNow, a quick note, when we create a file descriptor with the C function `fopen()`, we must always close the file\nat the end of our program, or, as soon as we completed all operations that we wanted to perform\non the file. In Zig, this is no different. So everytime we create a new file, this file remains\n\"open\", waiting for some operation to be performed. As soon as we are done with it, we always have\nto close this file, to free the resources associated with it. This is true both for Zig and C.\nIn Zig, we do this by calling the method `close()` from the file handler object.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst cwd = std.fs.cwd();\nconst file = try cwd.createFile(\"foo.txt\", .{});\n// Do things with the file ...\n// Don't forget to close the file at the end.\ndefer file.close();\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}