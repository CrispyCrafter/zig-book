---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
knitr::opts_chunk$set(
    auto_main = TRUE,
    build_type = "run"
)
```

# Pointers in Zig {#sec-pointer}

On the next chapter, we are going to build a HTTP server from scratch.
But in order to do that,
we need to learn more about what are pointers, and how they work in Zig.

Pointers in Zig are similar to pointers in C. A pointer is an object
that contains a memory address. This memory address is the address where
a particular value is stored in the memory. It can be any value. Most of the times,
it is a value that comes from another object (or variable) present in our code.

In the example below, I'm creating two objects (`number` and `pointer`).
The `pointer` object contains the memory address where the value of the `number` object
(the number 5) is stored. So, that is a pointer in a nutshell. It is a memory
address that points to a particular existing value in the memory. You could
also say, that, the `pointer` object points to the memory address where the `number` object is
stored.


```{zig}
#| eval: false
const number: u8 = 5;
const pointer = &number;
```

We create a pointer object in Zig by using the `&` operator. When you put this operator
before the name of an existing object, you get the memory address of this object as result.
When you store this memory address inside an object, this object becomes a pointer object.
Because this object stores a memory address.

People mostly use pointers as an alternative way to access a particular value.
For example, I can use the `pointer` object to access the value stored by
the `number` object. We call this operation (i.e. accessing the value that the
pointer points to) of *dereferencing the pointer*. So, we can dereference
a pointer by using the `*` method of the pointer object. Like in the example
below, where we are taking the number 5 pointed by the `pointer` object,
and doubling it.

```{zig}
#| eval: false
const doubled = 2 * pointer.*;
std.debug.print("{d}\n", .{doubled});
```

```
10
```

This syntax to dereference the pointer is nice. Because we can easily chain it with
methods of the value pointed by the pointer. We can use the `User` struct that we
created at @sec-structs-and-oop as an example. If you comeback to that section,
you will see that this struct have a method named `print_name()`.

So, for example, if we have an user object, and a pointer that points to this user object,
we can use the pointer to access this user object, and, at the same time, call the method `print_name()`
on it, by chaining the dereference method (`*`) with the `print_name()` method. Like in the
example below:


```{zig}
#| eval: false
const u = User.init(1, "pedro", "email@gmail.com");
const pointer = &u;
try pointer.*.print_name();
```

```
pedro
```

We can also use pointers to effectively alter the value of an object.
For example, I could use the `pointer` object to set
the value of the object `number` to 6, like in the example below.


```{zig}
var number: u8 = 5;
const pointer = &number;
pointer.* = 6;
try stdout.print("{d}\n", .{number});
```


Therefore, as I mentioned earlier, people use pointers as an alternative way to access a particular value.
And they use it specially when they do not want to "move"
the values they produce in their code. There are situations where,
you want to access a particular value in a different scope of your code,
but you do not want to "move" this value to the new scope that you are in.

This matters especially if this value is big in size. Because if it is, then,
moving this value becomes an expensive operation to do.
The computer will have to spend a considerable amount of time
copying this value to a new location.

That is why, many programmers avoid this heavy operation of copying the value,
by accessing it through pointers.
We are going to talk more about this "moving operation" on the next sections.
For now, just keep in your mind that avoiding this "move operation" is
one of main reasons why pointers are used in programming languages.





## Constant objects vs variable objects

You can have a pointer to a constant object, or, a pointer to a variable object.
A pointer must always respect the characteristics of the object that it points to.
If the pointer points to a constant object, then, you cannot use this pointer
to change the value that it points to. Because it points to a value that is constant.

For example, if I have a `number` object, which is constant, I cannot execute
the expression below where I'm trying to change the value of `number` to 6 through
the `pointer` object. As demonstrated below, we get a compile time error:

```{zig}
#| eval: false
const number = 5;
const pointer = &number;
pointer.* = 6;
```

```
p.zig:6:12: error: cannot assign to constant
    pointer.* = 6;
```

So, if I change the `number` object to a variable object,
then I can change the value of this object through
a pointer.

```{zig}
var number: u8 = 5;
const pointer = &number;
pointer.* = 6;
try stdout.print("{d}\n", .{number});
```

Now, what about the pointer object itself? I mean, what happens
if the pointer object is constant or not? Think about it.
We can have a constant pointer that points to a constant value.
But we can also have a constant pointer that points to a
variable value.

Until this point, the `pointer` object was always constant,
but what this means for us? What is the consequence of the
`pointer` object being constant? The consequence is that
we cannot change the pointer object. We can use the
pointer object in multiple ways, but we cannot change the
memory address that is inside this pointer object.

However, if we mark the `pointer` object as a variable object,
then, we can change the memory address pointed by this `pointer` object.
The example below demonstrates that. Notice that the value pointed
by the `pointer` object changes from 5 to 6.

```{zig}
#| eval: false
const c1: u8 = 5;
const c2: u8 = 6;
var pointer = &c1;
try stdout.print("{d}\n", .{pointer.*});
pointer = &c2;
try stdout.print("{d}\n", .{pointer.*});
```

```
5
6
```

Thus, by setting the `pointer` object to a `var` or `const` object,
you specify if the memory address contained in this pointer object can change or not
in your program. On the other side, you can change the value pointed by the pointer,
if, and only if this value is stored in a variable object. If this value
is in a constant object, then, you cannot change this value through a pointer.


## Types of pointer

In Zig, there are two types of pointers [@zigdocs], which are:

- single-item pointer (`*`);
- many-item pointer (`[*]`);


Single-item pointer objects are objects whose data types are in the format `*T`.
So, for example, if an object have a data type `*u32`, it means that, this
object contains a pointer that points to an unsigned 32-bit integer value.
As another example, if an object have type `*User`, then, it contains
a pointer to a `User` value.

In contrast, many-item pointer objects are objects whose data types are in the format `[*]T`.
Notice that the star symbol (`*`) is now inside a pair of brackets (`[]`). If the star
symbol is inside a pair of brackets, you know that this object is a many-item pointer.

When you apply the `&` operator over an object, you will always get a single-item pointer.
Many-item pointers are more of a "internal type" of the language, more closely
related to slices. So, when you deliberately create a pointer with the `&` operator,
you always get a single-item pointer as result. Remember that.
