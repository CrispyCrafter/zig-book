---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
```


# Building a base64 encoder/decoder

As our first small project, I want to implement with you a base64 encoder/decoder in Zig.
Base64 is an encoding system which translates binary data to text.
A big chunk of the web uses base64 to deliver binary data to systems
that can only read text data.

The biggest example of modern use case is email systems,
like GMail, Outlook, etc. Because email systems normally use
the Simple Mail Transfer Protocol (SMTP), which is a web protocol
that supports only text data. So, if you need, for any reason, to
send a binary file (like for example, a PDF, or an Excel file) as
an attachment in your email, these binary files are normally
converted to base64 before they be included in the SMTP message.




## How strings work in Zig?

In order to build this Base64 decoder/encoder, we need to understand better how strings work in Zig.
In Zig, a string literal (or a string object if you prefer) is a pointer to a null-terminated array
of bytes. Each byte in this array is represented by an `u8` value, which is an unsigned 8 bit integer,
so, it is equivalent to the C data type `unsigned char`.

Zig always assumes that this sequence of bytes is UTF-8 encoded. This might not be true for every
sequence of bytes you have it, but is not really Zig’s job to fix the encoding of your string
(you can use [`iconv`](https://www.gnu.org/software/libiconv/)[^libiconv] for that).
Today, most of the text in our modern world, specially on the web, should be UTF-8 encoded.
So if your string literal is not UTF-8 encoded, then, you will likely
have problems in Zig.

[^libiconv]: <https://www.gnu.org/software/libiconv/>

Let’s take for example the word “Hello”. In UTF-8, this sequence of characters (H, e, l, l, o)
is represented by the sequence of decimal numbers 72, 101, 108, 108, 111. In xecadecimal, this
is the sequence 0x48, 0x65, 0x6C, 0x6C, 0x6F. So if I take this sequence of hexadecimal values,
and ask Zig to print this sequence of bytes as a sequence of characters (i.e. a string), then,
the text “Hello” will be printed into the terminal:

```{zig}
const std = @import("std");
const stdout = std.io.getStdOut().writer();
pub fn main() !void {
    const bytes = [_]u8{0x48, 0x65, 0x6C, 0x6C, 0x6F};
    try stdout.print("{s}\n", .{bytes});
}
```


If you want to see the actual bytes that represents a string in Zig, you can use
a `for` loop to iterate trough each byte in the string, and ask Zig to print each byte as an hexadecimal
value to the terminal. You do that by using a `print()` statement with the `X` formatting specifier,
like you would normally do with the [`printf()` function](https://cplusplus.com/reference/cstdio/printf/)[^printfs] in C.

[^printfs]: <https://cplusplus.com/reference/cstdio/printf/>

```{zig}
const std = @import("std");
const stdout = std.io.getStdOut().writer();
pub fn main() !void {
    const string_literal = "This is an example of string literal in Zig";
    try stdout.print("Bytes that represents the string object: ", .{});
    for (string_literal) |byte| {
        try stdout.print("{X} ", .{byte});
    }
    try stdout.print("\n", .{});
}
```

### Strings in C

At first glance, this looks very similar to how C treats strings as well. That is, string values
in C are also treated internally as an array of bytes, and this array is also null-terminated.

But one key difference between a Zig string and a C string, is that Zig also stores the length of
the array inside the string object. This small detail makes your code safer, because is much
easier for the Zig compiler to check if you are trying to access an element out of bounds, or if
your trying to access memory that does not belong to you.

To achieve this same kind of safety in C, you have to do a lot of work, that kind of seems pointless.
So getting this kind of safety is not automatic and much harder to do in C. For example, if you want
to track the length of your string troughout your program in C, then, you first need to loop through
the array of bytes that represents this string, and find the null element (`'\0'`) position to discover
where exactly the array ends, or, in other words, to find how much elements the array of bytes contain.

To do that, you would need something like this in C. In this example, the C string is 25 bytes long:

```c
#include <stdio.h>
int main() {
    char* array = "An example of string in C";
    int index = 0;
    while (1) {
        if (array[index] == '\0') {
        break;
    }
        index++;
    }
    printf("Number of elements in the array: %d\n", index);
}
```

```
Number of elements in the array: 25
```

But in Zig, you do not have to do this, because the object already contains a `len`
field which stores the length information of the array. As an example, the `string_literal` object below is 43 bytes long:


```{zig}
const std = @import("std");
const stdout = std.io.getStdOut().writer();
pub fn main() !void {
    const string_literal = "This is an example of string literal in Zig";
    try stdout.print("{d}\n", .{string_literal.len});
}
```



### A better look at the object type

Now, we can inspect better the type of objects that Zig create. To check the type of any object in Zig, you can use the
`@TypeOf()` function. If we look at the type of the `simple_array` object below, you will find that this object
is a array of 4 elements. Each element is a signed integer of 32 bits which corresponds to the data type `i32` in Zig.
That is what an object of type `[4]i32` is.

But if we look closely at the type of the `string_literal` object below, you will find that this object is a
constant pointer (hence the `*const` annotation) to an array of 43 elements (or 43 bytes). Each element is a
single byte (more precisely, an unsigned 8 bit integer - `u8`), that is why we have the `[43:0]u8` portion of the type below.
In other words, the string stored inside the `string_literal` object is 43 bytes long.
That is why you have the type `*const [43:0]u8` below.

In the case of `string_literal`, it is a constant pointer (`*const`) because the object `string_literal` is declared
as constant in the source code (in the line `const string_literal = ...`). So, if we changed that for some reason, if
we declare `string_literal` as a variable object (i.e. `var string_literal = ...`), then, `string_literal` would be
just a normal pointer to an array of unsigned 8-bit integers (i.e. `* [43:0]u8`).

Now, if we create an pointer to the array object, then, we get a constant pointer to an array of 4 elements (*const [4]i32), which is very similar to the type of the string_literal object. This demonstrates that a string object (or a string literal) in Zig is already a pointer to an array.

Just remember that a "pointer to an array" is different than an "array". So a string object in Zig is a pointer to an array
of bytes, and not simply an array of bytes.


```{zig}
const std = @import("std");
const stdout = std.io.getStdOut().writer();
pub fn main() !void {
    const string_literal = "This is an example of string literal in Zig";
    const simple_array = [_]i32{1, 2, 3, 4};
    try stdout.print("Type of array object: {}\n", .{@TypeOf(simple_array)});
    try stdout.print("Type of string object: {}\n", .{@TypeOf(string_literal)});
    try stdout.print("Type of a pointer that points to the array object: {}\n", .{@TypeOf(&simple_array)});
}
```




## The base64 encoding system

In essence, the base64 encoding system is based on a numeral system
that have 64 items (hence the name). So, in order to convert some binary data, to
the base64 encoding, we need to convert each binary number
to the corresponding item in this "64 scale".

