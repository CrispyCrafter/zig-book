---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
```


# Building a base64 encoder/decoder

As our first small project, I want to implement with you a base64 encoder/decoder in Zig.
Base64 is an encoding system which translates binary data to text.
A big chunk of the web uses base64 to deliver binary data to systems
that can only read text data.

The biggest example of a modern use case for base64 is essentially any email system,
like GMail, Outlook, etc. Because email systems normally use
the Simple Mail Transfer Protocol (SMTP), which is a web protocol
that supports only text data. So, if you need, for any reason, to
send a binary file (like for example, a PDF, or an Excel file) as
an attachment in your email, these binary files are normally
converted to base64, before they are included in the SMTP message.
So, the base64 encoding is largelly used in these email systems to include
binary data into the SMTP message.






## How the base64 algorithm work? 

Now, how exactly the algorithm behind the base64 encoding works? Let's discuss that. First, I will
explain the base64 scale, which is the scale of 64 characters that represents the base64 encoding system.

After that, I explain the algorithm behind a base64 encoder, which is the part of the algorithm that is responsible for encoding messages
into the base64 encoding system. Then, after that, I explain the algorithm behind a base64 decoder, which is
the part of the algorithm that is responsible for translating base64 messages back into their original meaning.

If you are unsure about the differences between an "encoder" and a "decoder",
take a look at @sec-encode-vs-decode.


### The base64 scale

In essence, the base64 encoding system is based on a scale that goes from 0 to 64 (hence the name).
Each index in this scale is represented by a character (it is a scale of 64 characters).
So, in order to convert some binary data, to the base64 encoding, we need to convert each binary number to the corresponding
character in this "scale of 64 characters".

The base64 scale starts with all ASCII uppercase letters (A to Z) which represents
the first 25 indexes in this scale (0 to 25). After that, we have all ASCII lowercase letters
(a to z), which represents the range 26 to 51 in the scale. After that, we
have the one digit numbers (0 to 9), which represents the indexes from 52 to 61 in the scale.
Finally, the last two indexes in the scale (62 and 63) are represented by the characters `+` and `/`,
respectively.

These are the 64 characters that compose the base64 scale. The equal sign character (`=`) is not part of the scale itself,
but it is a special character in the base64 encoding system. This character is used solely as a suffix, to mark the end of the character sequence,
or, to mark the end of meaningful characters in the sequence.

The bulletpoints below summarises the base64 scale:

- range 0 to 25 is represented by: ASCII uppercase letters `-> [A-Z]`;
- range 26 to 51 is represented by: ASCII lowercase letters `-> [a-z]`;
- range 52 to 61 is represented by: one digit numbers `-> [0-9]`;
- index 62 and 63 are represented by the characters `+` and `/`, respectively;
- the character `=` represents the end of meaningful characters in the sequence;



Everytime that the base64 algorithm needs to fill some gap (which always occur at the end of
the input string) with a group of 6 bits filled with only zeros (`000000`), this group is automatically
mapped to the character `=`. Because this group of 6 bits is meaningless, they represent nothing,
they are just filling the gap. As a result, the base64 algorithm maps this meaningless group
to the character `=`, which represents the end of meaningful characters in the sequence.
This characteristic is explained in more details at @sec-base64-encoder-algo.



### Creating the scale as a lookup table {#sec-base64-table}

The best way to represent this scale in code, is to represent it as a *lookup table*.
Lookup tables are a classic strategy in computer science to speed calculations. The basic idea
is to replace a runtime calculation (which can take a long time to be done) by a basic array indexing
operation.

Instead of calculating the results everytime you need them, you calculate all possible results at once, and then, you store them in an array
(which behaves lake a "table"). Then, every time that you need to use one of the characters in the base64 scale, instead of
using many resources to calculate the exact character to be used, you simply retrieve this character
from the array where you stored all the possible characters in the base64 scale. So we retrieve the character that we need
directly from memory.

We can start building a Zig struct to store our base64 decoder/encoder logic.
We start with the `Base64` struct below. You can see that, for now, we only have an `init()` function,
to create a new instance of a `Base64` object, and, a `_char_at()` function, which is a
"get chat at index ..." type of function.


```{zig}
#| eval: false
const Base64 = struct {
    _table: *const [64]u8,

    pub fn init() Base64 {
        const upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        const lower = "abcdefghijklmnopqrstuvwxyz";
        const numbers_symb = "0123456789+/";
        return Base64{
            ._table = upper ++ lower ++ numbers_symb,
        };
    }

    pub fn _char_at(self: Base64, index: u8) u8 {
        return self._table[index];
    }
};
```


In other words, the `_char_at()` function is responsible for getting the character in the lookup table (i.e. the `_table` variable) that
corresponds to a particular index in the "base64 scale". So, in the example below, we know that
the character that corresponds to the index 28 in the "base64 scale" is the character "c".


```{zig}
#| eval: false
const base64 = Base64.init();
try stdout.print(
    "Character at 28 index: {c}\n",
    .{base64._char_at(28)}
);
```

```
Character at 28 index: c
```



### A base64 encoder {#sec-base64-encoder-algo}

The algorithm behind a base64 encoder usually works on a window of 3 bytes. Because each byte have
8 bits, so, 3 bytes forms a set of $8 \times 3 = 24$ bits. This is desirable for the base64 algorithm, because
24 bits is divisble by 6, which form a set of 4 groups of 6 bits each.

So the base64 algorithm work by converting 3 bytes at a time
into 4 characters in the base64 scale. It keeps iterating through the input string,
3 bytes at a time, and converting them into the base64 scale, producing 4 characters
per iteration. It keeps iterating, and producing these "new characters"
until it hits the end of the input string.

Now you may think, what if you have a particular string that have a number of bytes
that is not divisible by 3? What happens? For example, if you have a string
that contains only two characters/bytes, such as "Hi". How the
algorithm behaves in such situation? You find the answer at @fig-base64-algo1.
You can see at @fig-base64-algo1 that the string "Hi", when converted to base64,
becomes the string "SGk=":

![The logic behind a base64 encoder](./../Figures/base64-encoder-flow.png){#fig-base64-algo1}

In the example of the string "Hi" we have 2 bytes, or, 16 bits in total. So, we lack a full byte (8 bits)
to complete the window of 24 bits that the base64 algorithm likes to work on. In essence,
everytime that the algorithm does not meet this requirement, it simply add extra zeros
until it fills the space that it needs.

That is why at @fig-base64-algo1, on the third group after the 6-bit transformation,
2 extra zeros were added to fill the gap in this group, and also, the fourth group (which is the last 6-bit group)
is entirely made by zeros that were added by the algorithm.

So every time that the base64 algorithm can't produce a full group of 6 bits, it
simply fills the gap in this group with zeros, until it get's the 6 bits that it needs.

Is worth mentioning that, everytime that the algorithm produces a group of 6 bits that
is entirely composed by these extra zeros added by the algorithm, then, this group of 6 bits is automatically mapped to
the character `=` (equal sign). However, notice that a group of 6-bit entirely made by **extra zeros**,
is different than a group of 6-bit entirely made by **zeros**.

In other words, if the algorithm produces a 6-bit group made by zeros, without
needing to include extra-zeros to fill any gap, then, this "group of zeros" is interpreted as is. In binary,
the 6-bit group `000000` simply means zero. So, if we give the index zero to the function `_char_at()`,
this zero index is mapped to the first character in the base64 scale, which is "A".

So be aware of this important distinction. A group of "extra-zeros" that are "filling the gap"
is different than a group of actual zeros that were calculated by the 6-bit transformation.
As an example, if you give the string "0" as input to a base64 encoder, this string is
translated into the base64 sequence "MA==".

The character "0" is, in binary, the sequence `00110000`[^zero-note]. So, with the 6-bit transformation
exposed at @fig-base64-algo1, this single character would produce these two 6-bit groups: `001100`, `000000`.
The other two 6-bit groups are entirely made by extra-zeros, and that is why the last
two characters in the output sequence (MA==) are `==`.


[^zero-note]: Notice that, the character "0" is different than the actual number 0, which is simply zero in binary.

### A base64 decoder {#sec-base64-decoder-algo}

The algorithm behind a base64 decoder is essentially the inverse process of a base64 encoder.
A base64 decoder needs to be able to translate base64 messages back into their original meaning,
i.e. into the original sequence of binary data.

A base64 decoder usually works on a window of 4 bytes. Because it wants to convert these 4 bytes
back into the original sequence of 3 bytes, that was converted into 4 groups of 6 bits by the
base64 encoder. Remember, in a base64 decoder we are essentially reverting the process made
by the base64 encoder.

Each byte in the input string (the base64 encoded string) normally contributes to re-create two different bytes in the output (the original binary data).
In other words, each byte that comes out of a base64 decoder is created by transforming merging two different
bytes in the input together. You can see this fact at @fig-base64-algo2:

![The logic behind a base64 decoder](./../Figures/base64-decoder-flow.png){#fig-base64-algo2}

The exact transformations, or, the exact steps applied to each byte from the input to transform them
into the bytes in the output, are a bit tricky to visualize in a figure like this. Because of that, I
summarized these transformations as "Some bit shifting and additions ...". These transformations
will be described in depth later.

Besides that, if you look again at @fig-base64-algo2, you will notice that the character `=` was completly
ignored in the algorithm. Remember, this is just a special character that marks the end of meaninful characters
in the base64 sequence. So, every `=` character in a base64 encoded sequence should be ignored.


## Difference between encode and decode {#sec-encode-vs-decode}

If you don't have any previous experience with base64, you might be confused about
what is the differente between "encode" and "decode". Essentially, the terms "encode" and "decode" here
have the exact same meaning as they have in the field of encryption (i.e. they mean the same thing as "encode" and "decode" in hashing
algorithms, like the MD5 algorithm).

So, "encode" means that we want to encode, or, in other words, we want to translate some message into
the base64 encoding system. We want to produce the sequence of base64 characters that represent this
original message in the base64 encoding system.

In contrast, "decode" represents the inverse process.
We want to decode, or, in other words, translate a base64 message back to it's original content.
So, in this process we get a sequence of base64 characters as input, and produce as output,
the binary data that is represented by this sequence of base64 characters.

So, any base64 library is normally composed by these two parts: 1) the encoder, which is a function that encodes
(i.e. it converts) any sequence of binary data into a sequence of base64 characters; 2) the decoder, which is a function
that converts a sequence of base64 characters back into the original sequence of binary data.



## Calculating the size of the output {#sec-base64-length-out}

One task that we need to do is to calculate how much space we need to reserve for the
output, both of the encoder and decoder. This is simple math, and can be done easily in Zig
because every array have it's length (it's number of bytes) easily accesible by consulting
the `.len` property of the array.

For the encoder, the logic is the following: for each 3 bytes that we find in the input,
4 new bytes are created in the output. So, we take the number of bytes in the input, divide it
by 3, use a ceiling function, then, we multiply the result by 4. That way, we get the total
number of bytes that will be produced by the encoder in it's output.

The `_calc_encode_length()` function below encapsulates this logic. Notice that we convert
the `.len` property of the array, which is always a integer (more precisely, an `usize` value),
into a floating point number of 64 bits (`f64`). We do this, because the ceiling function (`@ceil()`) works
only with floating point numbers. So, we convert it so that the division with the number `3.0` results in
a floating point number. Then, after the ceiling process, we can convert the result back into an
integer value (with the `@intFromFloat()` function).

```{zig}
#| eval: false
fn _calc_encode_length(input: []const u8) u64 {
    if (input.len < 3) {
        const n_output: u64 = 4;
        return n_output;
    }
    const len_as_float: f64 = @floatFromInt(input.len);
    const n_output: u64 = @intFromFloat(@ceil(len_as_float / 3.0) * 4.0);
    return n_output;
}
```

Is important to notice that, when I am using the built-in functions from Zig to convert data types (`@floatFromInt()` and `intFromFloat()`),
I'm always annotating explicitly the type of the variable that stores the result of these functions.
I do that, because these functions need this information. `@floatFromInt()` needs to know
which type of floating point number I want to use in it's output. Is it `f16`? `f32`? `f64`? etc.
The same goes to `@intFromFloat()`.

Also, you might have notice that, if the input length is less than 3 bytes, then, the output length of the encoder will
be always 4 bytes. This is because the algorithm will always fill the gap in the input with zeroes, until it fits
the window of 24 bits that the algorithm likes to work on, as I described at @sec-base64-encoder-algo. So the output
of the algorithm will always be 4 bytes in this specific case.


Now, for the decoder, we just need to apply the inverse logic: for each 4 bytes in the input, 3 bytes
will be produced in the output of the decoder. I mean, this is roughly true, because we also need to
take the `=` character into account, which is always ignored by the decoder, as we described at @sec-base64-decoder-algo, and,
at @fig-base64-algo2. But we can ignore this fact for now, to make things simpler.

So, the function `_calc_decode_length()` summarizes this logic that we described. It is very similar
to the function `_calc_encode_length()`, only the division part is twisted, and also, in the special
case where we have less than 4 bytes in the input to work on.


```{zig}
#| eval: false
fn _calc_decode_length(input: []const u8) u64 {
    if (input.len < 4) {
        const n_output: u64 = 3;
        return n_output;
    }
    const len_as_float: f64 = @floatFromInt(input.len);
    const n_output: u64 = @intFromFloat(@floor(len_as_float / 4.0) * 3.0);
    return n_output;
}
```


## Building the encoder logic

In this section, we can start building the logic behind the `encode()` function, which
will be responsible for encoding messages into the base64 encoding system.



### The 6-bit transformation

The 6-bit transformation presented at @fig-base64-algo1 is the core part of the base64 encoder algorithm.
By understanding how this transformation is made in code, the rest of the algorithm becomes much simpler
to comprehend.

In essence, this 6-bit transformation is made with the help of bitwise operators.
Bitwise operators are essential to any type of low-level operation that is done at the bit-level. For the specific case of the base64 algorithm,
the operators *bif shift to the left* (`<<`), *bit shift to the right* (`>>`), and the *bitwise and* (`&`) are used. They
are the core solution for the 6-bit transformation.

We have 3 different scenarios that we need to account for in this transformation. First, is the perfect scenario,
where we have the perfect window of 3 bytes to work on. Second, we have the scenario where we have a window of only
two bytes to work with. And last, we have the scenario where we have a window of one single byte.

In each of these 3 scenarios, the 6-bit transformation works a bit different. To make the explanation
easier, I will use the variable `output` to refer to the bytes in the output of the base64 encoder,
and the variable `input` to refer to the bytes in the input of the encoder.


If you have the perfect window of 3 bytes, these are steps for the 6-bit transformation:

1. `output[0]` is produced by moving the bits from `input[0]` two positions to the right.
1. `output[1]` is produced by summing two components. First, take the last two bits from `input[0]`, then, move them four positions to the left. Second, move the bits from `input[1]` four positions to the right. Sum these two components.
1. `output[2]` is produced by summing two components. First, take the last four buts from `input[1]`, then, move them two positions to the left. Second, move the buts from `input[2]` six positions to the right.
1. `output[3]` is produced by taking the last six bits from `input[2]`.


If you have a window of 2 bytes, then, the steps 3 and 4, which produces the bytes `output[2]` and `output[3]`, change a little bit,
and they become:

- `output[2]` is produced by taking the last 4 bits from `input[1]`, then, move them two positions to the left.
- `output[3]` is the character `'='`.


At last, if you have a window of a single byte, then, the steps 2 to 4, which produces the bytes `output[1]`, `output[2]` and `output[3]` change,
becoming:

- `output[1]` is produced by taking the last two bits from `input[0]`, then, move them four positions to the left.
- `output[2]` and `output[3]` are the character `=`.


If these bulletpoints were a bit confusing for you, you may find the @tbl-transf-6bit more intuitive.
This table unifies all this logic into a simple table. Notice that
this table also provides the exact expression in Zig that creates the corresponding
byte in the output.


::: {#tbl-transf-6bit}

```{r}
#| echo: false
library(gt)
library(tibble)

table_data <- tibble(
  "Number of bytes in the window" = c(3L, 3L, 3L, 3L,
                                      2L, 2L, 2L, 2L,
                                      1L, 1L, 1L, 1L),
  "Byte index in the output" = c(0:3, 0:3, 0:3),
  "In code" = c(
    "`input[0] >> 2`",
    "`((input[0] & 0x03) << 4) +`\n\n`(input[1] >> 4)`",
    "`((input[1] & 0x0f) << 2) +`\n\n`(input[2] >> 6)`",
    "`input[2] & 0x3f`",

    "`input[0] >> 2`",
    "`((input[0] & 0x03) << 4) +`\n\n`(input[1] >> 4)`",
    "`((input[1] & 0x0f) << 2)`",
    "`'='`",

    "`input[0] >> 2`",
    "`((input[0] & 0x03) << 4)`",
    "`'='`",
    "`'='`"
  )
)


table <- table_data |>
  gt() |> 
  fmt_markdown(columns = "In code") |>
  cols_align(align="left") |>
  # cols_width(
  #   `Number of bytes in the window` ~ px(150),
  #   `Byte index in the output` ~ px(150)
  # ) |> 
  cols_label(
    `Number of bytes in the window` = md("**Number of bytes in the window**"),
    `Byte index in the output` = md("**Byte index in the output**"),
    `In code` = md("**In code**")
  )




if (knitr::is_html_output()) {
  table |> gt::as_raw_html()
} else {
  table |> gt::as_latex()
}

```

How the 6-bit transformation translates into code in different window settings.

:::


### Quick & dirty approach

To get a better understanding of what we need to do, let's implement just the bare minimum of code
to convert some input into the base64 encoding system. This will be a "quick and dirty" approach.
It doesn't need to be preety or good quality code. It just needs to work.

#### First byte in the output

Let's begin by building the first byte in the output of the encoder. This is the easiest byte of the 4 bytes in the output
to build. We only need to move the bits from the first byte in the input (`01001000`) two positions to the right,
with the *bit shift to the right* (`>>`) operator.

By moving the bits two places to the right, we get the sequence `00010010` as output. As a result, the first 6 bits
of the first byte in the input were moved to the end of the byte.
With this operation, we get the first byte of the ouput, which corresponds to the index in the base64 scale for the first character
in the base64 scale.



```{zig}
#| auto_main: true
const input = "Hi";
var output = [4]u8{0,0,0,0};
output[0] = input[0] >> 2;
```

#### Second byte in the output

The second byte in the output is produced by summing two components together. On the first component,
we need to select the last two bits in the first byte of the input. We do that, by using the "bitwise and" (`&`)
operator and the hexadecimal value `0x03`, which is, in binary, the sequence `00000011`. Notice
that only the last two bits in `0x03` are "on" (i.e. setted to one).

With this `&` operator and the `0x03` value, we essentially set all bits that we do not care about (in this case,
the first 6 bits) to zero. By setting them to zero, we essentially remove these bits from the equation.
Only the last two bits of the byte maintain their original values.
After this operation, we just move the resulting bits four positions to the left.

To produce the second component, we simply take second byte in the input, and then, we move it's bits
four positions to the right. At last, we just sum these two components together to form the second byte in the output.

```{zig}
#| eval: false
#| auto_main: true
const component1 = ((input[0] & 0x03) << 4)
const component2 = (input[1] >> 4)
output[1] = component1 + component2;
```


#### Third byte in the output

The third byte in the output is also produced by summing two components together.
In the first component, we need to take the last 4 bits in the second byte in the input. Then, we move
these bits two positions to the left. In the second component, we take the third byte in the input,
and move it's bits six positions to the right.


```{zig}
#| eval: false
#| auto_main: true
const component1 = ((input[1] & 0x0f) << 2);
const component2 = (input[2] >> 6);
output[2] = component1 + component2;
```


#### Fourth byte in the output

The fourth byte in the output is produced by taking the third byte in the input,
and selecting the last six bits, with the `&` operator and the hexadecimal
value `0x3f`.

```{zig}
#| eval: false
#| auto_main: true
output[3] = input[2] & 0x3f;
```

#### The end result

With this dirty code, we get the end result, which is the string `SGk=`.
We can print this string at the end of the program to see this end result:

```{zig}
#| eval: false
#| auto_main: true
std.debug.print("Result: {s}\n", .{output});
```

```
Result: SGk=
```



### Encapsulating this logic into a function

```{zig}
#| eval: false
fn encode(self: Base64,
          input: []const u8,
          allocator: std.mem.Allocator) ![]u8 {

    if (input.len == 0) {
        return "";
    }

    const n_out = _calc_encode_length(input);
    var out = try allocator.alloc(u8, n_out);
    var buf = [3]u8{ 0, 0, 0 };
    var count: u8 = 0;
    var iout: u64 = 0;

    for (input, 0..) |_, i| {
        buf[count] = input[i];
        count += 1;
        if (count == 3) {
            out[iout] = self._char_at(buf[0] >> 2);
            out[iout + 1] = self._char_at(
                ((buf[0] & 0x03) << 4) + (buf[1] >> 4)
            );
            out[iout + 2] = self._char_at(
                ((buf[1] & 0x0f) << 2) + (buf[2] >> 6)
            );
            out[iout + 3] = self._char_at(buf[2] & 0x3f);
            iout += 4;
            count = 0;
        }
    }

    if (count == 1) {
        out[iout] = self._char_at(buf[0] >> 2);
        out[iout + 1] = self._char_at(
            (buf[0] & 0x03) << 4
        );
        out[iout + 2] = '=';
        out[iout + 3] = '=';
    }

    if (count == 2) {
        out[iout] = self._char_at(buf[0] >> 2);
        out[iout + 1] = self._char_at(
            ((buf[0] & 0x03) << 4) + (buf[1] >> 4)
        );
        out[iout + 2] = self._char_at(
            (buf[1] & 0x0f) << 2
        );
        out[iout + 3] = '=';
        iout += 4;
    }

    return out;
}
```
