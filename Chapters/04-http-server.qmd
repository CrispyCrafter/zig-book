---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
knitr::opts_chunk$set(
    auto_main = FALSE,
    build_type = "run"
)
```



# Building a HTTP Server from scratch

In this chapter, I want to implement a new
small project with you. This time, we are going
to implement a basic HTTP Server from scratch.

The Zig Standard Library already have a HTTP Server
implemented, which is available at `std.http.Server`.
But again, our objective here in this chapter, is to implement
it **from scratch**. So we can't use this server `struct` available
from the Zig Standard Library.

## What is a HTTP Server?

First of all, what is a HTTP Server?
A HTTP server, as any other type of server, is essentially
a program that runs indefinetly, on a infinite loop, waiting for incoming connections
from clients. Once the server receives an incoming connection, it will
accept this connection, and it will send messages back-and-forth to the client
through this connection.

But the messages that are transmitted inside this connection are in a
specific format. They are HTTP messages
(i.e. messages that uses the HTTP Protocol specification).
The HTTP Protocol is the backbone of the modern web.
The world wide web as we know it today, would not exist without the 
HTTP Protocol.

So, Web servers (which is just a fancy name to
HTTP Servers) are servers that exchange HTTP messages with clients.
And these HTTP servers and the HTTP Protocol specification
are simply essential to the operation of the internet of today.

That is the whole picture of the process.
Again, we have two subjects involved here, a server (which is
a program that is running indefinetly, waiting for connections),
and a client (which is someone that wants to connect to
and exchange HTTP messages with the server).

## How a HTTP Server works?

Imagine a HTTP Server as if it were the receptionist of a large hotel. In a hotel,
you have a reception, and inside that reception there is a receptionist
waiting for customers to arrive. A HTTP Server is essentially a receptionist
that is indefinetly waiting for new customers (or, in the context of HTTP, new clients)
to arrive in the hotel.

When a customer arrives at the hotel, 
that customer starts a conversation with the
receptionist. He tells the receptionist how many days he wants to stay at the hotel.
Then, the receptionist search for an available apartment. If there is an available apartment
at the moment, the customer pays the hotel fees, then, he gets the keys to the apartment,
and then, he goes to the apartment to rest.

After this entire process of dealing with the customer (searching for available rooms, receiving payment, handing over the keys),
the receptionist goes back to what he was doing earlier, which is to wait.
Wait for new customers to arrive.

That is, in a nutshell, what a HTTP Server do. It waits for clients to connect to the
server. When a client attempts to connect to the server, the server accepts this connection,
and it starts to exchange messages with the client through this connection.
The first message that happens inside this connection is always a message from the client
to the server. This message is called the *HTTP Request*.

This HTTP Request is a HTTP message that contains what
the client wants from the server. Is literally a request. The client
that connected to the server is asking this server to do something for him.

There are different "types of request" that any client can do to a HTTP Server.
But the most basic type of request, is when a client ask to the
HTTP Server to serve (i.e. to send) some specific web page (which is a HTML file) to him.
When you type `google.com` in your web browser, you are essentially sending a HTTP Request to Google's
HTTP servers, which asks these servers to send the Google webpage to you.

Nonetheless, when the server reiceves this first message, the *HTTP Request*, it
analyzes this request, to understand: who the client is? what he wants the server to do?
this client provided all the necessary information to perform the action that he
asked? Etc.

Once the server understands what the client wants, he simply perform the action
that was requested, and, to finish the whole process, the server sends back
a HTTP message to the client, informing if the action performed was succesful or not,
and, at last, the server ends (or closes) the connection with the client.

This last HTTP message sent from the server to the client, is called the *HTTP Response*.
Because the server is responding to the action that was requested by the client.
The main objective of this response message is let the client knows if the
action requested was succesful or not, before the server closes the connection.


## How a HTTP server is normally implemented? {#sec-http-how-impl}

Let's use the C language as an example. There are many materials
teaching how to write a simple HTTP server in C code, like @jeffrey_http,
or @nipun_http, or @eric_http.
Having this in mind, I will not show C code examples here, because you
can find them on the internet.
But I will describe the theory behind the necessary steps to perform in the C code.


In essence, we normally implement a HTTP server in C using WebSocket technology,
which involves the following steps:

1. Create a socket object.
1. Bind a name (or more specifically, an address) to this socket object.
1. Make this socket object to start listening and waiting for incoming connections.
1. When a connection arrive, we accept this connection, and we exchange the HTTP messages (HTTP Request and HTTP Response).
1. Then, we simply close this connection.


A socket object (which uses the WebSocket technology) is essentially a channel of communication.
You are creating a channel where people can send messages to.
When you create a socket object, this object is not binded to any particular
address. This means that with this object you have a representation of a channel of communication
in your hands. But this channel is not currently available, or, it is not currently accessible,
because it do not have a known address where you can find it.

That is what the "bind" operation do. It binds a name (or more specifically, an address) to
this socket object, or, this channel of communication, so that it becomes available,
or, accessible through this address. While the "listen" operation makes the socket object to
listen for incoming connections in this address. In other words, the "listen" operation
makes the socket to wait for incoming connections.

Now, when a client actually attempts to connect to the server through the address we specify,
then, the socket object needs to accept this incoming connection. When we
accept it, then, the connection is established, client and server are now
connected to each other, and they can read or write messages in this
established connection.

After we received the HTTP Request from the client,
and sent the HTTP Response to the client,
we can now close the connection, and end
this communication.


## Implementing the server

Let's begin with creating the socket for our server. In Zig, we can create a web socket using
the `std.posix.socket()` function, from the Zig Standard Library.


### Creating the socket object {#sec-create-socket}

As I meantioned earlier at @sec-http-how-impl, every socket object we create
represents a communication channel, and we need to bind this channel to a specific address.
An "address" is defined as an IP address, or, more specifically, an IPv4 address^[It can be also an IPv6 address. But normally, we use a IPv4 address for that.].
Every IPv4 address is composed by two components. The first component is the host,
which is a sequence of 4 numbers separated by dot characters (`.`) that identifies the machine used.
While the second component is a port number, which identifies the specific
door, or, the specific port to use in the host.

The sequence of 4 numbers (i.e. the host) identifies the machine (i.e. the computer itselft) where
this socket will live in. Every computer normally have multiple "doors" available inside him, because 
this allows the computer to receive multiple connections at the same time.
He simply use a single door for each connection. So the port number, is
essentially a number that identifies the specific door in the computer that will be resposible
for receiving the connection. That is, it identifies the "door" in the computer that the socket will use
to receive incoming connections.

To make things simpler, I will use an IP address that identifies our current machine in this example.
This means that, our socket object will reside on the same computer that we are currently using
(this is also known as the "localhost") to write this Zig source code.

By convention, the IP address that identifies the "locahost", which is the current machine we
are using, is the IP `127.0.0.1`. So, that is the IP
address we are going to use in our server. I can declare it in Zig
by using an array of 4 integers, like this: `[4]u8{ 127, 0, 0, 1 }`.

Now, we need to decide which port number to use. By convention, there are some
port numbers that are reserved, meaning that, we cannot use them for our own
purposes, like the port 22 (which is normally used for SSH connections).
For TCP connections, which is our case here,
a port number is a 16-bit unsigned integer (type `u16` in Zig),
thus ranging from 0 to 65535 [@wikipedia_port].
So, we can choose
a number from 0 to 65535 for our port number. In the 
example of this book, I will use the port number 3490
(just a random number).


Now that we have these two informations at hand, I can
finally create our socket object, using the `std.posix.socket()` function.
First, we use the host and the port number to create an `Address` object,
with the `std.net.Address.initIp4()` function, like in the example below.
After that, I use this address object inside the `socket()` function
to create our socket object.

The `Socket` struct defined below summarizes all the logic behind this
this process. In this struct, we have two data members, which are:
1)  the address object; 2) and a stream object, which is
the object we will use to read and write the messages into any connection we establish.

Notice that, inside the constructor method of this struct,
when we create the socket object, we are using the `IPROTO.TCP` property as an input to
tell the function to create a socket for TCP connections.


```{zig}
#| build_type: "lib"
const std = @import("std");
const builtin = @import("builtin");
const net = @import("std").net;

pub const Socket = struct {
    _address: std.net.Address,
    _stream: std.net.Stream,

    pub fn init() !Socket {
        const host = [4]u8{ 127, 0, 0, 1 };
        const port = 3490;
        const addr = net.Address.initIp4(host, port);
        const socket = try std.posix.socket(addr.any.family, std.posix.SOCK.STREAM, std.posix.IPPROTO.TCP);
        const stream = net.Stream{ .handle = socket };
        return Socket{ ._address = addr, ._stream = stream };
    }
};
```


### Listening and receiving connections

Notice in the example below that, we stored the `Socket` struct
declaration that we built at @sec-create-socket inside a Zig module named `config.zig`.
Then, I imported this module into our main module as the `SocketConf` object,
to access the `Socket` struct.

Once we created our socket object, we can focus now on making this socket object to
listen and receive new incoming connections. We do that, by calling the `listen()`
method from the `Address` object that is contained in the socket object, and then,
we call the `accept()` method over the result.

The `listen()` method from the `Address` object produces a server object,
which is an object that will stay open and running indefinitely, waiting
to receive an incoming connection. Therefore, if you run the Zig
code below, by calling the `run` command from the `zig` compiler,
you will notice that the programs keeps running indefinitely,
without a clear end.

This happens, because the program is waiting for something to happen.
It is waiting for someone to try to connect to the address (`http://127.0.0.1:3490`) where
the server is running and listening for incoming connections. This is what
the `listen()` method do, it makes the socket to be active waiting for someone
to connect.

On the other side, the `accept()` method is the function that establish the connection
when someone try to connect to the socket. This means that, the `accept()` method
returns a new connection object as a result. And you can use this connection object
to read or write messages from or to the client.

For now, we are not doing anything with this connection object.
But we are going to use it on the next section.


```{zig}
#| eval: false
const std = @import("std");
const SocketConf = @import("config.zig");
const stdout = std.io.getStdOut().writer();

pub fn main() !void {
    const socket = try SocketConf.Socket.init();
    try stdout.print("Server Addr: {any}\n", .{socket._address});
    var server = try socket._address.listen(.{});
    const connection = try server.accept();
    _ = connection;
}
```

This code example allows one single connection. In other words, the
server will wait for one incoming connection, and as soon as the
server is done with the first connection it establishs, the
program ends, and the server stops.

This is not the norm on the real world. Most people that write
a HTTP server like this, usually put the `accept()` method
inside a `while` (infinite) loop, where if a connection
is created with accept, a new thread is created to deal with
this new connection and the client.

With this design, the server simply accepts the connection,
and the whole process of dealing with the client, and receiving
the HTTP Request, and sending the HTTP Response, all of this
is done in the background, on a separate execution thread.

So, as soon as the server accepts the connection, and creates
the separate thread, the server goes back to what he was doing,
which is to wait indefinitely for a new connection to accept.
Having this in mind, the code example exposed above, is a
server that serves only a single client. Because the program
terminates as soon as the connection is accepted.