---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
knitr::opts_chunk$set(
    auto_main = FALSE,
    zig_test = TRUE
)
```



# Building a HTTP Server from scratch

In this chapter, I want to implement a new
small project with you. This time, we are going
to implement a basic HTTP Server from scratch.

The Zig Standard Library already have a HTTP Server
implemented, which is available at `std.http.Server`.
But again, our objective here in this chapter, is to implement
it **from scratch**. So we can't use this server `struct` available
from the Zig Standard Library.

## What is a HTTP Server?

First of all, what is a HTTP Server?
A HTTP server, as any other type of server, is essentially
a program that runs indefinetly, on a infinite loop, waiting for incoming connections
from clients. Once the server receives an incoming connection, it will
accept this connection, and it will send messages back-and-forth to the client
through this connection.

But the messages that are transmitted inside this connection are in a
specific format. They are HTTP messages
(i.e. messages that uses the HTTP Protocol specification).
The HTTP Protocol is the backbone of the modern web.
The world wide web as we know it today, would not exist without the 
HTTP Protocol.

So, Web servers (which is just a fancy name to
HTTP Servers) are servers that exchange HTTP messages with clients.
And these HTTP servers and the HTTP Protocol specification
are simply essential to the operation of the internet of today.

That is the whole picture of the process.
Again, we have two subjects involved here, a server (which is
a program that is running indefinetly, waiting for connections),
and a client (which is someone that wants to connect to
and exchange HTTP messages with the server).

## How a HTTP Server works?

Imagine a HTTP Server as if it were the receptionist of a large hotel. In a hotel,
you have a reception, and inside that reception there is a receptionist
waiting for customers to arrive. A HTTP Server is essentially a receptionist
that is indefinetly waiting for new customers (or, in the context of HTTP, new clients)
to arrive in the hotel.

When a customer arrives at the hotel, 
that customer starts a conversation with the
receptionist. He tells the receptionist how many days he wants to stay at the hotel.
Then, the receptionist search for an available apartment. If there is an available apartment
at the moment, the customer pays the hotel fees, then, he gets the keys to the apartment,
and then, he goes to the apartment to rest.

After this entire process of dealing with the customer (searching for available rooms, receiving payment, handing over the keys),
the receptionist goes back to what he was doing earlier, which is to wait.
Wait for new customers to arrive.

That is, in a nutshell, what a HTTP Server do. It waits for clients to connect to the
server. When a client attempts to connect to the server, the server accepts this connection,
and it starts to exchange messages with the client through this connection.
The first message that happens inside this connection is always a message from the client
to the server. This message is called the *HTTP Request*.

This HTTP Request is a HTTP message that contains what
the client wants from the server. Is literally a request. The client
that connected to the server is asking this server to do something for him.

There are different "types of request" that any client can do to a HTTP Server.
But the most basic type of request, is when a client ask to the
HTTP Server to serve (i.e. to send) some specific web page (which is a HTML file) to him.
When you type `google.com` in your web browser, you are essentially sending a HTTP Request to Google's
HTTP servers, which asks these servers to send the Google webpage to you.

Nonetheless, when the server reiceves this first message, the *HTTP Request*, it
analyzes this request, to understand: who the client is? what he wants the server to do?
this client provided all the necessary information to perform the action that he
asked? Etc.

Once the server understands what the client wants, he simply perform the action
that was requested, and, to finish the whole process, the server sends back
a HTTP message to the client, informing if the action performed was succesful or not,
and, at last, the server ends (or closes) the connection with the client.

This last HTTP message sent from the server to the client, is called the *HTTP Response*.
Because the server is responding to the action that was requested by the client.
The main objective of this response message is let the client knows if the
action requested was succesful or not, before the server closes the connection.


## How a HTTP server is normally implemented?

Let's use the C language as an example. In C, we normally implement a HTTP server
by performing the following steps:

1. Create a socket object.
1. Bind a name (or more specifically, an address) to this socket object.
1. Make this socket object to start listening and waiting for incoming connections.
1. When a connection arrive, we accept this connection, and we exchange the HTTP messages (HTTP Request and HTTP Response).
1. Then, we simply close this connection.


A socket object (which uses the WebSocket technology) is essentially a channel of communication.
You are creating a channel where people can send messages to.
When you create a socket object, this object is not binded to any particular
address. This means that with this object you have a representation of a channel of communication
in your hands. But this channel is not currently available, or, it is not currently accessible,
because it do not have a known address where you can find it.

That is what the "bind" operation do. It binds a name (or more specifically, an address) to
this socket object, or, this channel of communication, so that it becomes available,
or, accessible through this address. While the "listen" operation makes the socket object to
listen for incoming connections in this address. In other words, the "listen" operation
makes the socket to wait for incoming connections.

Now, when a client actually attempts to connect to the server through the address we specify,
then, the socket object needs to accept this incoming connection. When we
accept it, then, the connection is established, client and server are now
connected to each other, and they can read or write messages in this
established connection.

After we received the HTTP Request from the client,
and sent the HTTP Response to the client,
we can now close the connection, and end
this communication.


All of this process, in C, would be something like this code example below.
There are lot of things happening in this code, and, I am also not doing
a lot of necessary things, like error handling. But this is just
an simplified example of how this code in C would look like.

Also, this code would not compile on Windows, because in Windows
we need to use slightly different functions and patterns to
make the connections and also close them. So, this code example
works only on Linux[^c-funs].

[^c-funs]: The functions used in this code example, such as `socket()`,
`bind()`, `listen()` and `accept()`, and also, some
`struct` objects, such as `sockaddr` and `sockaddr_in`,
come from the header files `sys/socket.h`, `netinet/in.h` and `arpa/inet.h`.


```c
int sock = socket(AF_INET, SOCK_STREAM, 0);
uint16_t port = htons(3490);
struct sockaddr_in socket_address;
socket_address.sin_family = AF_INET;
socket_address.sin_addr.s_addr = htonl(INADDR_ANY);
socket_address.sin_port = port;
memset(&(socket_address.sin_zero), '\0', 8);

bind(
    sock,
    (struct sockaddr *) &socket_address,
    sizeof(socket_address)
);

listen(sock, 10);
struct sockaddr_in their_addr;
int client_connected;
socklen_t sock_addr_size = sizeof(struct sockaddr_in);
client_connected = accept(
    sock,
    (struct sockaddr *)&their_addr,
    &sock_addr_size)
);
char* msg = "Hello, World!";
int len, bytes_sent;
len = strlen(msg);
bytes_sent = send(client_connected, msg, len, 0);

close(client_connected);
close(sock);
```

