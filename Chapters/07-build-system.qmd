---
engine: knitr
knitr: true
syntax-definition: "./Assets/zig.xml"
---

```{r}
#| include: false
source("./zig_engine.R")
```


# Build System in Zig

One advantage of Zig is that it includes a build system embedded in the language itself.
This is great, because then you do not have to depend on a external system, separated
from the compiler, to build your code.

So, in this chapter, we are going to talk about the build system in Zig, and how
code is built in Zig.


## How source code is built?

Everytime you write some source code in any existing programming language in
the world, you need to compile this source code into binary instructions
that are executed by your computer. In other words, instead of the
source code itself that you wrote, what really get's executed by your computer,
are the binary instructions that are equivalent to the source code your wrote.

So, again, your source code always needs to be compiled into binary instructions.
Usually, this is done by a compiler. In Javascript, we normally use the compiler
behind NodeJs, or Deno, or Bun to compile the Javascript into these instructions.
In C and C++, we normally use compilers like `gcc`, `g++` or `clang` to compile
our C and C++ source code into these instructions.
Every language have it's own compiler, and this is no different in Zig.

In Zig, we have the `zig` compiler to compile our Zig source code into
binary instructions that can be executed by our computer. Although
this looks like a simple piece of software, that just reads your Zig
source code and translates it into native binary instructions, compilers
are in general, complex pieces of software.

The biggest challenge that compilers face today is probably cross-compatibility.
Building pieces of software that are cross-platform (work in every Operational System) is
incredible hard in our modern world.

In part, this is a result from having different computer manufacturers that chooses
to use different architectures in their products, and use different CPUs and other types of hardware
that are incompatible with the pieces of their competitors.
But it also is a result simply from the complexity of our world. We have to use different tools
to solve different types of problems. All this reflects on big differences between
the plataforms we use in our computers.

So, we use Build Systems



