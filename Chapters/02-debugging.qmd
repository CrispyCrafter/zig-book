---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
knitr::opts_chunk$set(
    auto_main=TRUE
)
```

# Debugging Zig applications

Being able to debug your programs is essential to any programmer who wants to
do serious programming in any language. That is why, in this chapter, we are going to talk about the
available strategies and tools to debug applications written in Zig.


## Printing debugging

We begin with the classic and battle-tested *print debugging* strategy.
The key advantage that debugging offers you is *visibility*.
With debugging, you can easily see what results and objects
that are being generated within your functions.

That is the key essence of *print debugging*. Is to use
print expressions to see the values that are being generated by your program,
and, as a result, get a much better understanding of how your program
is behaving.

So, many programmers often resort to the print functions in Zig, such as the `stdout.print()`,
or, the `std.debug.print()`, to get a better understanding of their programs.
This is an known and old strategy that is very simple and effective, and it is better known within
the programming community as *print debugging*.

In Zig, you can print information to the `stdout` channel of your system. First, you
need to get access to the `stdout`, by calling the `getStdOut()` method, from
the Zig standard library. This method returns a *file descriptor* object,
and, through this object you can read/write to the `stdout`.
I recommend you to check out all methods available in this object, by [checking the page in
the Zig Standard Library Official Reference for the type `File`](https://ziglang.org/documentation/master/std/#std.fs.File)[^zig-fiile-reference].

[^zig-fiile-reference]: <https://ziglang.org/documentation/master/std/#std.fs.File>.

For our purpose here, which is to write something to the `stdout`, specially to debug our
program, I recommend you to use the `writer()` method, which gives your a *writer* object.
This *writer* object offers some helper methods to write stuff into the file descriptor object
that we created earlier. In special, the `print()` method.


The `print()` method from this *writer* object is a "print formatter" type of a function.
In other words, this method works exactly like the `printf()` function from C,
or, like `!println()` from Rust.
In the first argument of the function, you specify a template string, and,
in the second argument, you provide a list of values (or objects) that you want to print in your message.

Ideally, the template string in the first argument should contain some format specifier.
Each format specifier is matched to a value (or object) that you listed in the second argument.
So, if you provided 5 different objects in the second argument, then, the template string
should contain 5 format specifiers, one for each object provided.

Each format specifier is represented by a single letter, and
you provide this format specifier inside a pair of curly braces. So, if you want to format
your object as a string, then, you can insert the text `{s}` in your template string.
Here is a quick list of the most used format specifiers:

- `d`: for printing integers.
- `f`: for printing floating-point numbers.
- `c`: for printing characters.
- `s`: for printing strings.
- `p`: for printing memory addresses.
- `x`: for printing hexadecimal values.

The code example below, gives you an example of use of this `print()` method
with the `d` format specifier.

```{zig}
#| auto_main: false
const std = @import("std");
const stdout = std.io.getStdOut().writer();
fn add(x: u8, y: u8) u8 {
    return x + y;
}

pub fn main() !void {
    const result = add(34, 16);
    try stdout.print("Result: {d}", .{result});
}
```

Is important to emphasize that, the `stdout.print()` method, as you would expect,
print your template string into the `stdout` channel of your system.
However, you can also print your template string into the `stderr` channel
if your prefer. All you need to do, is to replace the `stdout.print()`
call with the function `std.debug.print()`. Like this:

```{zig}
#| auto_main: false
#| eval: false
const std = @import("std");
fn add(x: u8, y: u8) u8 {
    return x + y;
}

pub fn main() !void {
    const result = add(34, 16);
    try std.debug.print("Result: {d}", .{result});
}
```

```
Result: 50
```



## Debugging through debuggers

Although *print debugging* is a valid and very useful strategy,
most programmers prefer to use a debugger to debug their programs.
Since Zig is a low-level language, you can use either GDB (GNU Debugger),
or LLDB (LLVM Project Debugger) as your debugger.

Both debuggers can work with Zig code, and it's a matter of taste here.
You choose the debugger of your preference, and you work with it.
In this book, I will use LLDB as my debugger on the examples.


### Compile your source code in Debug mode

In order to debug your program through a debugger, you must compile
your code in Debug mode. Because when you compile your
source code in other modes (such as Release), the compiler usually
strips out some essential information that is used by the debugger
to read and track your program.

By compiling your source code in Debug mode, you ensure that the debugger
will find the necessary information in your program to debug it.
By default, the compiler uses the Debug mode. So, when you compile your program with the `build-exe`
command (that we exposed at @sec-compile-code), if you don't specify an explicit mode through the `-O` command-line [^oargument]
argument, then, the compiler will compile your code in Debug mode.

[^oargument]: See <https://ziglang.org/documentation/master/#Debug>.


### Let's debug a program

As an example, let's debug some Zig code, and demonstrate
how can we use LLDB to navigate and check the following
piece of Zig code:

```{zig}
#| auto_main: false
const std = @import("std");
const stdout = std.io.getStdOut().writer();

fn add_and_increment(a: u8, b: u8) u8 {
    const sum = a + b;
    const incremented = sum + 1;
    return incremented;
}

pub fn main() !void {
    var n = add_and_increment(2, 3);
    n = add_and_increment(n, n);
    try stdout.print("Result: {d}!\n", .{n});
}
```

There is nothing wrong with this program. But it is
a good start for us. First, we need to compile
this program with this `zig build-exe` command.

For this example, suppose that I compiled the above
Zig code into a binary executable called `add_program`.
Now, we can start LLDB with `add_program`, like this:

```bash
lldb add_program
```

From now on, LLDB is started, and you can know that I'm
executing LLDB commands by looking at the prefix `(lldb)`.
If something is prefixed with `(lldb)`, then you know
that it is a LLDB command.

The first thing I will do, is to set a breakpoint in
the `main()` function, by executing `b main`.
After that, I just start the execution of the program
with `run`.

You can see in the output below, that the execution
stopped at the first line in the function `main()`, as we expected.
Because we setted the breakpoint at this function.

```bash
(lldb) b main
Breakpoint 1: where = debugging`debug1.main + 22
    at debug1.zig:11:30, address = 0x00000000010341a6
(lldb) run
Process 8654 launched: 'add_program' (x86_64)
Process 8654 stopped
* thread #1, name = 'add_program',
    stop reason = breakpoint 1.1
    frame #0: 0x00000000010341a6
    add_program`debug1.main at add_program.zig:11:30
   8   	}
   9   	
   10  	pub fn main() !void {
-> 11  	    var n = add_and_increment(2, 3);
   12  	    n = add_and_increment(n, n);
   13  	    try stdout.print("Result: {d}!\n", .{n});
   14  	}
```




