---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
knitr::opts_chunk$set(
    auto_main = FALSE,
    build_type = "run"
)
```



# Error handling and unions in Zig {#sec-error-handling}

In this chapter, I want to discuss how error handling is done in Zig.
Not every low-level language have an explicit system to handle errors.
In C for example, we normally check for errors by looking at the return value of
the function calls, and see if there is an "error status code" or
a valid value returned from the function.

But, in Zig, we use a *try catch* pattern to handle errors,
using the keywords `try` and `catch`.
If you remember of the previous section,
we already learned about the `try` keyword at @sec-main-file.
We use the `try` keyword whenever the expression that we are executing
might return an error.
But we still haven't learned about the `catch` keyword yet. So let's 
get into business, shall we?


## Learning more about errors in Zig

Before we get into `try` and `catch`, we need to learn more about errors in Zig.
Errors are values in Zig [@zigoverview]. In other words, they are like any integer (or a string) value that you create in your code.
You can pass error values as inputs to functions, and you can cast them into a different error value.


Although they are normal values as any other, you cannot ignore error values in your code. Meaning that, if an error
value appears somewhere in your source code, this error value must be explicitly handled in some way.
This also means that you cannot discard error values, by assigning them to a underscore,
as you would do with normal values and objects.

Take the source code below as an example. Here we are trying to open a file that does not exist
in my computer, and as a result, an obvious error of `FileNotFound` is returned from the `openFile()`
function. But because I'm assigning the result of this function to an underscore, I end up
trying to discard an error value.

The `zig` compiler detects this mistake, and raises an
error telling me that I'm trying to discard an error value.
It also adds a note message that suggests the use of `try`,
`catch` or an if statement to explicitly handle this error value.


```{zig}
#| eval: false
#| auto_main: true
const dir = std.fs.cwd();
_ = dir.openFile("doesnt_exist.txt", .{});
```

```
t.zig:8:17: error: error union is discarded
t.zig:8:17: note: consider using 'try', 'catch', or 'if'
```

### Returning errors from functions

As we described at @sec-main-file, when we have a function that might return an error
value, this function normally includes an exclamation mark (`!`) in it's return type
annotation. The presence of this exclamation mark indicates that this function might
return an erro value as result, and, as consequence, you should always handle explicitly
the case of this function returning an error value.


The `print_name()` function below might return an error in the `stdout.print()` function call,
and, as a consequence, it's return type `!void` includes an exclamation mark in it, warning us 
that this function might fail.

```{zig}
#| eval: false
fn print_name() !void {
    const stdout = std.getStdOut().writer();
    try stdout.print("My name is Pedro!", .{});
}
```

In the example above, we are using the exclamation mark, to tell the `zig` compiler
that this function might return some error. But which error exactly is returned from
this function? For now, we are not especifying a specific error value. We only
known for now that some error value (whatever it is) might be returned.

But in fact, you can (if you want to) specify clearly which exact error values
might be returned from your function. There are lot of examples of
this in the Zig Standard Library. Take this `fill()` function from
the `http.Client` module as an example. This function returns
either a error value of type `ReadError`, or `void`.

```{zig}
#| eval: false
pub fn fill(conn: *Connection) ReadError!void {
    // The body of this function ...
}
```

This idea of specifying the exact error values that you expect to be returned
from the function is interesting. Because they automatically become a type of documentation
of your function, and also, it allows the `zig` compiler to perform extra checks over
your code. Because it can check if there is any other type of error value
that is being generated inside your function, and, that it is not being accounted
for in this return type annotation.

Anyway, so, you can list the types of errors that can be returned from the function
by listing them on the left side of the exclamation mark. So the syntax format
become:

```zig
<error-value>!<valid-value>
```

### Error unions

But what about when we have a single function that might return different types of errors?
When you have such a function, you can list
all of these different types of errors that can be returned from this function,
through a structure in Zig that we call of *error union*.

An error union is a literally an union that contains error values in it.
Not all programming languages have a notion of an union object.
But in summary, an union is just a list of the options that
an object can be. For example, a union of `x`, `y` and `z`, means that,
an object of this union can either be a `x`, `y` or a `z` object.

We are going to talk in more depth about unions later.
But you can write an error union by writing the keyword `error` before
a pair of curly braces, and you list the error values that can be
returned from the function inside this pair of curly braces.

Take the `resolvePath()` function below as an example, which comes from the
`introspect.zig` module of the Zig Standard Library. We can see in the return type annotation, that this
function might return three different types of error values. This is an example
of an error union.


```{zig}
#| eval: false
pub fn resolvePath(
    ally: mem.Allocator,
    p: []const u8,
) error{
    OutOfMemory,
    CurrentWorkingDirectoryUnlinked,
    Unexpected,
    }![]u8 {
    // The body of the function ...
}
```


This is a valid way of annotating the return value of a Zig function. But, if you navigate through
the modules that composes the Zig Standard Library, you will notice that, for the majority of cases,
the programmers prefer to give a descriptive name to this error union, and then, use this name (or this "label")
of the error union in the return type annotation, instead of using the error union directly.

We can see that in the `ReadError` error union defined in the `http.Client` module.
You can see that, we are grouping all of these errors into a single object, called `ReadError`,
and then, we use this object into the return type of the function. Like the `fill()` function
that we showed ealier, or, the `readvDirect()` function from the same module.

```{zig}
#| eval: false
pub const ReadError = error{
    TlsFailure,
    TlsAlert,
    ConnectionTimedOut,
    ConnectionResetByPeer,
    UnexpectedReadFailure,
    EndOfStream,
};
// Some lines of code
pub fn readvDirect(
        conn: *Connection,
        buffers: []std.posix.iovec
    ) ReadError!usize {
    // The body of the function ...
}
```



## The *try catch* pattern


If you remember of what we learned in this section, when we say that an expression might
return an error, we are basically referring to an expression that have
a return type in the format `!T`.
The `!` indicates that this expression returns either an error or a value of type `T`.


```{zig}
#| auto_main: true
const x = 5;
_ = x;
```
