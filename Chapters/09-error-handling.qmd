---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
knitr::opts_chunk$set(
    auto_main = FALSE,
    build_type = "run"
)
```



# Error handling and unions in Zig {#sec-error-handling}

In this chapter, I want to discuss how error handling is done in Zig.
Not every low-level language have an explicit system to handle errors.
In C for example, we don't have either *try catch* or *exceptions* patterns.

We normally check for errors in C by looking at the return value of each function call,
and seing if this value is "error status code" or not. On the other side, in C++,
we normally deal with errors in our program by using exceptions in conjunction with
a *try catch* pattern.


## The *try catch* pattern

In Zig, we handle errors with a *try catch* pattern, using the keywords `try` and `catch`.
We already learned about the `try` keyword at @sec-main-file. The `try` keyword is
used whenever an expression might return error.

If you remember of what we learned in this section, when we say that an expression might
return an error, we are basically referring to an expression that have
a return type in the format `!T`.
The `!` indicates that this expression returns either an error or a value of type `T`.



