---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
knitr::opts_chunk$set(
    auto_main = FALSE,
    build_type = "run"
)
```



# Error handling and unions in Zig {#sec-error-handling}

In this chapter, I want to discuss how error handling is done in Zig.
Not every low-level language have an explicit system to handle errors.
In C for example, we normally check for errors by looking at the return value of
the function calls, and see if there is an "error status code" or
a valid value returned from the function.

But, in Zig, we use a *try catch* pattern to handle errors,
using the keywords `try` and `catch`.
We already learned about the `try` keyword at @sec-main-file.
But we still haven't learned about the `catch` keyword.


## Learning more about errors in Zig

Before we get into `try` and `catch`, we need to learn more about what errors in Zig are.
An error is actually a value in Zig [@zigoverview]. In other words, when an error occurs inside your Zig program,
it means that somewhere in your Zig codebase, an error value is being generated.
An error value is similar to any integer value that you create in your Zig code.
You can take an error value and pass it as input to a function,
and you can also cast it into a different type of error value.

This have some similarities with exceptions in C++ and Python.
Because in C++ and Python, when an exception happens inside a `try` block,
you can use a `catch` block (in C++) or an `except` block (in Python)
to capture the exception value produced in the `try` block,
and pass it to functions as an input.


Although they are normal values as any other, you cannot ignore error values in your Zig code. Meaning that, if an error
value appears somewhere in your source code, this error value must be explicitly handled in some way.
This also means that you cannot discard error values, by assigning them to a underscore,
as you would do with normal values and objects.

Take the source code below as an example. Here we are trying to open a file that does not exist
in my computer, and as a result, an obvious error of `FileNotFound` is returned from the `openFile()`
function. But because I'm assigning the result of this function to an underscore, I end up
trying to discard an error value.

The `zig` compiler detects this mistake, and raises an
error telling me that I'm trying to discard an error value.
It also adds a note message that suggests the use of `try`,
`catch` or an if statement to explicitly handle this error value
This note is remembering you that every error value must be explicitly handled.


```{zig}
#| eval: false
#| auto_main: true
const dir = std.fs.cwd();
_ = dir.openFile("doesnt_exist.txt", .{});
```

```
t.zig:8:17: error: error set is discarded
t.zig:8:17: note: consider using 'try', 'catch', or 'if'
```

### Returning errors from functions

As we described at @sec-main-file, when we have a function that might return an error
value, this function normally includes an exclamation mark (`!`) in it's return type
annotation. The presence of this exclamation mark indicates that this function might
return an error value as result, and, the `zig` compiler forces you to always handle explicitly
the case of this function returning an error value.

Take a look at the `print_name()` function below. This function might return an error in the `stdout.print()` function call,
and, as a consequence, it's return type (`!void`) includes an exclamation mark in it,
which warns us that this function might fail.

```{zig}
#| eval: false
fn print_name() !void {
    const stdout = std.getStdOut().writer();
    try stdout.print("My name is Pedro!", .{});
}
```

In the example above, we are using the exclamation mark to tell the `zig` compiler
that this function might return some error. But which error exactly is returned from
this function? For now, we are not specifying a specific error value. We only
known for now that some error value (whatever it is) might be returned.

But in fact, you can (if you want to) specify clearly which exact error values
might be returned from this function. There are lot of examples of
this in the Zig Standard Library. Take this `fill()` function from
the `http.Client` module as an example. This function returns
either a error value of type `ReadError`, or `void`.

```{zig}
#| eval: false
pub fn fill(conn: *Connection) ReadError!void {
    // The body of this function ...
}
```

This idea of specifying the exact error values that you expect to be returned
from the function is interesting. Because they automatically become some sort of documentation
of your function, and also, it allows the `zig` compiler to perform some extra checks over
your code. Because it can check if there is any other type of error value
that is being generated inside your function, and, that it is not being accounted
for in this return type annotation.

Anyway, you can list the types of errors that can be returned from the function
by listing them on the left side of the exclamation mark. While the valid values
stay on the right side of the exclamation mark. So the syntax format become:

```
<error-value>!<valid-value>
```

### Error sets

But what about when we have a single function that might return different types of errors?
When you have such a function, you can list
all of these different types of errors that can be returned from this function,
through a structure in Zig that we call of *error set*.

An error set is a special type of an union object.
It essentially is an union that contains error values in it.
Not all programming languages have a notion of an "union object".
But in summary, an union is just a list of the options that
an object can be. For example, a union of `x`, `y` and `z`, means that
an object can be either of type `x`, or type `y` or type `z`.

We are going to talk in more depth about unions at @sec-unions.
But you can write an error set by writing the keyword `error` before
a pair of curly braces, then you list the error values that can be
returned from the function inside this pair of curly braces.

Take the `resolvePath()` function below as an example, which comes from the
`introspect.zig` module of the Zig Standard Library. We can see in the return type annotation, that this
function might return three different types of error values. This is an example
of an error set.


```{zig}
#| eval: false
pub fn resolvePath(
    ally: mem.Allocator,
    p: []const u8,
) error{
    OutOfMemory,
    CurrentWorkingDirectoryUnlinked,
    Unexpected,
}![]u8 {
    // The body of the function ...
}
```


This is a valid way of annotating the return value of a Zig function. But, if you navigate through
the modules that composes the Zig Standard Library, you will notice that, for the majority of cases,
the programmers prefer to give a descriptive name to this error set, and then, use this name (or this "label")
of the error set in the return type annotation, instead of using the error set directly.

We can see that in the `ReadError` error set that we showed earlier in the `fill()` function,
which is defined in the `http.Client` module.
So yes, I presented the `ReadError` as if it was just a standard and single error value, but in fact,
it is an error set defined in the `http.Client` module, and therefore, it actually represents
a set of different error values that might happen in the `fill()` and other functions.


Take a look at the `ReadError` definition reproduced below. Notice that we are grouping all of these
different error values into a single object, and then, we use this object into the return type annotation of the functions.
Like the `fill()` function that we showed earlier, or, the `readvDirect()` function from the same module,
which is reproduced below.

```{zig}
#| eval: false
pub const ReadError = error{
    TlsFailure,
    TlsAlert,
    ConnectionTimedOut,
    ConnectionResetByPeer,
    UnexpectedReadFailure,
    EndOfStream,
};
// Some lines of code
pub fn readvDirect(
        conn: *Connection,
        buffers: []std.posix.iovec
    ) ReadError!usize {
    // The body of the function ...
}
```

So, an error set is just a convenient way of grouping a set of
possible error values into a single object, or a single type of an error value.


### Casting error values



## The *try catch* pattern


As we described on previous sections, when we say that an expression might
return an error, we are basically referring to an expression that have
a return type in the format `!T`.
The `!` indicates that this expression returns either an error value, or a value of type `T`.

At @sec-main-file, I presented the `try` keyword, and I did tell you how we use
this keyword. But I did not talked about yet what exactly this keyword does to your code,
or, in other words, I have not explained yet what `try` means in your code.

In essence, when you use the `try` keyword in an expression, you are telling
the `zig` compiler the following: "Hey! Execute this expression for me,
and, if this expression return an error, please, return this error for me
and stop the execution of my program. But if this expression return a valid
value, then, return this value, and move on".

In other words, the `try` keyword is essentially, a strategy to enter in panic mode, and stop
the execution of your program in case an error occurs. That is exactly it.
With the `try` keyword, you are telling the `zig` compiler, that stopping the execution
of your program is the most reasonable strategy to take if an error occurs
in that particular expression.

Ok, now that we understand properly what `try` means, let's discuss `catch` now.
One important detail here, is that you can use `try` or `catch` to handle your errors,
but you **cannot use `try` and `catch` together**. In other words, `try` and `catch`
are different and completely separate strategies in the Zig language.

This is uncommon, and different than what happens in other languages. Most
programming languages that adopts the *try catch* pattern (such as C++, R, Python, Javascript, etc.), normally use
these two keywords in conjunction to form the complete logic to
properly handle the errors.
Anyway, Zig tries a different approach in the *try catch* pattern.

So, we learned already about what `try` means, and we also known that both
`try` and `catch` should be used alone, separate from each other. But
what exactly `catch` do in Zig? With `catch`, we can construct a
logic to handle the error value, in case it happens in the current expression.

Look at the code example below. Once again, we go back to the previous
example where we were trying to open a file that doesn't exist in my computer,
but this time, I use `catch` to actually implement a logic to handle the error, instead of
just stopping the execution right away.

More specifically, in this example, I'm using a logger object to record some logs into
the system, before I return the error, and stops the execution of the program. For example,
this could be some part of the codebase of a complex system that I do not have full control over,
and I want to record these logs before the program crashes, so that I can debug it later
(e.g. maybe I cannot compile the full program, and properly debug it with a debugger. So, these logs might
be a valid strategy to surpass this barrier).

```{zig}
#| eval: false
#| auto_main: true
const dir = std.fs.cwd();
const file = dir.openFile(
    "doesnt_exist.txt", .{}
) catch |err| {
    logger.record_context();
    logger.log_error(err);
    return err;
};
```


Therefore, we use `catch` to create a block of expressions that will handle the error.
I can return the error value from this block of expressions, like I did in the above example,
which, will make the program enter in panic mode, and, stop the execution.
But I could also, return a valid value from this block of code, which would
be stored in the `file` object.

Notice that, instead of writing the keyword before the expression that might return the error,
like we do with `try`,
we write `catch` after the expression. We can open the pair of pipes (`|`),
which captures the error value returned by the expression, and makes
this error value available in the scope of the `catch` block as the object named `err`.
In other words, because I wrote `|err|` in the code, I can access the error value
returned by the expression, by using the `err` object.

Although this being the most common use of `catch`, you can also use this keyword
to handle the error in a "default value" style. That is, if the expression returns
an error, we use the default value instead. Otherwise, we use the valid value returned
by the expression.


## Union objects in Zig {#sec-unions}

Unions in Zig are equivalent to [`typing.Union` in Python](https://docs.python.org/3/library/typing.html#typing.Union)[^pyunion]
for example. An union object is just a list of possible data types that an object can have.

[^pyunion]: <https://docs.python.org/3/library/typing.html#typing.Union>


