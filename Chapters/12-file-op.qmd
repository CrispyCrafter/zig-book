---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
knitr::opts_chunk$set(
    auto_main = FALSE,
    build_type = "lib"
)
```


# Filesystem and Input/Output (IO)

In this chapter we are going to discuss how to use the cross-platform structs and functions available
in the Zig Standard Library that executes filesystem operations. Most of these functions and structs
comes from the `std.fs` module.


## Filesystem basics

If you have ever programmed in your life, you probably know
some basics about filesystems and file operations, etc.
But, since I don't know you, I don't know what is your background, maybe
these concepts that I will describe are clear in your mind, but maybe not.
Anyhow, I will spend some time just to put everyone on the same basis.


### The concept of current working directory (CWD)

The working directory is the folder on your computer where you is currently rooted,
or in other words, it is the folder that your program is currently looking at.
Therefore, whenever you are executing a program, it will necessarily be working with
a specific folder on your computer. It will be in this folder that the program will initially
look for the files you require, and it will also be in this folder that the program
will initially save all the files you ask it to save.

The working directory is determined by the folder from which you invoke your program
in the terminal. In other words, if you are in the terminal of your OS, and you
execute a binary file (i.e. a program) from this terminal, the folder to which your terminal
is pointing at is the current working directory of your program that is being executed.

At @fig-cwd we have an example of me executing a program from the terminal. We are executing
the program outputted by the `zig` compiler by compiling the Zig module named `hello.zig`.
The CWD in this case is the `zig-book` folder. In other words, while the `hello.zig` program
is executing, it will be looking at the `zig-book` folder, and any file operation that we perform
inside this program, will be using this `zig-book` folder as the "starting point", or, as the "central focus".

![An example of executing a program from the terminal](./../Figures/cwd.png){#fig-cwd}

Just because we are rooted inside a particular folder (in the case of @fig-cwd, the `zig-book` folder) of our computer,
it doesn't mean that we cannot access or write resources in other locations of our computer.
The current working directory (CWD) mechanism just defines where your program will look first
for the files you ask for. This does not prevent you from accessing files that are located
elsewhere on your computer. However, to access any file that is in a folder other than your
current working directory, you must provide a path to that file or folder.


### The concept of paths

You also probably know the concept paths, either by a lot of practice with computers and programming, or,
by knowing a little bit about filesystems. But once again, I don't know you, so let's remember
what a path is.

A path is essentially a location. It points to a location in your filesystem. We use
paths to describe the location of files and folders in our computer.
One important aspect is that paths are always written inside strings,
i.e. they are always provided as text values.

There are two types of paths that you can provide to any program in any OS: a relative path, or a absolute path.
Absolute paths are paths that start at the root of your filesystem, and go all the way to the file name or the specfic folder
that you are referring to. This type of path is called absolute, because it points to a unique, absolute location on your computer.
That is, there is no other existing location on your computer that corresponds to this path. It is an unique identifier.

In contrast, a relative path is a path that start at the CWD. In other words, a relative path is
"relative to the CWD". The path used to access the `hello.zig` file at @fig-cwd is an example of relative path. This path
is reproduced below. This path begins at the CWD, which in the context of @fig-cwd, is the `zig-book` folder,
then, it goes to the `ZigExamples` folder, then, into `zig-basics`, then, to the `hello.zig` file.

```
ZigExamples/zig-basics/hello_world.zig
```


### Path wildcards

When providing paths, specially relative paths, you have the option of using a *wildcard*.
There are two commonly used *wildcards* in paths, which are "one period" (.) and "two periods" (..).
In other words, these two specific characters have special meanings when used in paths,
and can be used on any operating system (Mac, Windows, Linux, etc.). That is, they
are "cross platform".

The "one period" represents an alias for your current working directory.
This means that the relative paths `"./Course/Data/covid.csv"` and `"Course/Data/covid.csv"` are equivalent.
On the other hand, the "two periods" refers to the previous directory.
For example, the path `"Course/.."` is equivalent to the path `"."`, that is, the current working directory.

Therefore, the path `"Course/.."` refers to the folder before the `Course` folder.
As another example, the path `"src/writexml/../xml.cpp"` refers to the file `xml.cpp`
that is inside the folder before the `writexml` folder, which in this example is the `src` folder.
Therefore, this path is equivalent to `"src/xml.cpp"`.



## The current working directory handler

In Zig, filesystem operations are usually made through a directory handler.
A directory handler in Zig is an object of type `Dir`, which is a struct that comes from the `std.fs` module.
You normally create such `Dir` object, by calling the `std.fs.cwd()` function.
This function returns a `Dir` object that points to, or, that represents the CWD.

Through this `Dir` object, you can create new files, or modify, or read existing ones that are
inside your CWD. In the example below, we are creating this `Dir` object, and storing it
inside the `cwd` object. Through this `cwd` object we can perform filesystem operations in
the CWD, creating, deleting, reading or modifying files inside the CWD.

```{zig}
const cwd = std.fs.cwd();
_ = cwd;
```


## CRUD operations on files

In this section, we will describe how to perform basic CRUD (Create, Read, Update and Delete) operations
on files. This section describes which methods from the `Dir` object are used to perform
these operations, and we also describes the available flags for each operation.


### Creating files

We create new files by using the `createFile()` method from the `Dir` object.
Just provide the name of the file that you want to create, and this function will
do the necessary steps to create such file. You can also provide a relative path to this function,
and it will create the file by following this path, which is relative to the CWD.

This function might return an error, so, you should use `try`, `catch`, or any of the other methods presented
at @sec-error-handling to handle this possible error. But if everything goes well,
this `createFile()` method returns a `File` object as result.

Take this code example below. In this example, we are creating a new text file
named `foo.txt`. If the function `createFile()` succeeds, the object named `file` will contain a file handler,
which is pretty much the same thing as a file descriptor object created from the famous C function `fopen()`[^fopen-doc].

[^fopen-doc]: <https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm>

Now, a quick note, when we create a file descriptor with the C function `fopen()`, we must always close the file
at the end of our program, or, as soon as we completed all operations that we wanted to perform
on the file. In Zig, this is no different. So everytime we create a new file, this file remains
"open", waiting for some operation to be performed. As soon as we are done with it, we always have
to close this file, to free the resources associated with it. This is true both for Zig and C.
In Zig, we do this by calling the method `close()` from the file handler object.


```{zig}
#| eval: false
const cwd = std.fs.cwd();
const file = try cwd.createFile("foo.txt", .{});
// Do things with the file ...
// Don't forget to close the file at the end.
defer file.close();
```



